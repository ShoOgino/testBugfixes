{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","commits":[{"id":"b961ff1d2d65eab705046ed52539112d3a5f76e0","date":1463766553,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.err.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["73684368e131f1201fcf3bfba05533e89f5829d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.err.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73684368e131f1201fcf3bfba05533e89f5829d0","date":1470312728,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","sourceNew":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    //System.out.println(\"Finding intersection bounds\");\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.out.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      //System.out.println(\"X biggest\");\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      //System.out.println(\"Y biggest\");\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      //System.out.println(\"Z biggest\");\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","sourceOld":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.err.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","bugFix":["b961ff1d2d65eab705046ed52539112d3a5f76e0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","sourceNew":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    //System.out.println(\"Finding intersection bounds\");\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.out.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      //System.out.println(\"X biggest\");\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      //System.out.println(\"Y biggest\");\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      //System.out.println(\"Z biggest\");\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","sourceOld":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.err.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    //System.out.println(\"Finding intersection bounds\");\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.out.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      //System.out.println(\"X biggest\");\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      //System.out.println(\"Y biggest\");\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      //System.out.println(\"Z biggest\");\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findIntersectionBounds(PlanetModel,Bounds,Plane,Membership...).mjava","sourceNew":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    //System.out.println(\"Finding intersection bounds\");\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.out.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / zScaling d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      //System.out.println(\"X biggest\");\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      //System.out.println(\"Y biggest\");\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      //System.out.println(\"Z biggest\");\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","sourceOld":"  /**\n   * Record intersection points for planes with error bounds.\n   * This method calls the Bounds object with every intersection point it can find that matches the criteria.\n   * Each plane is considered to have two sides, one that is D + MINIMUM_RESOLUTION, and one that is \n   * D - MINIMUM_RESOLUTION.  Both are examined and intersection points determined.\n   */\n  protected void findIntersectionBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Plane q, final Membership... bounds) {\n    //System.out.println(\"Finding intersection bounds\");\n    // Unnormalized, unchecked...\n    final double lineVectorX = y * q.z - z * q.y;\n    final double lineVectorY = z * q.x - x * q.z;\n    final double lineVectorZ = x * q.y - y * q.x;\n    if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n      // Degenerate case: parallel planes\n      //System.out.println(\" planes are parallel - no intersection\");\n      return;\n    }\n\n    // The line will have the equation: A t + A0 = x, B t + B0 = y, C t + C0 = z.\n    // We have A, B, and C.  In order to come up with A0, B0, and C0, we need to find a point that is on both planes.\n    // To do this, we find the largest vector value (either x, y, or z), and look for a point that solves both plane equations\n    // simultaneous.  For example, let's say that the vector is (0.5,0.5,1), and the two plane equations are:\n    // 0.7 x + 0.3 y + 0.1 z + 0.0 = 0\n    // and\n    // 0.9 x - 0.1 y + 0.2 z + 4.0 = 0\n    // Then we'd pick z = 0, so the equations to solve for x and y would be:\n    // 0.7 x + 0.3y = 0.0\n    // 0.9 x - 0.1y = -4.0\n    // ... which can readily be solved using standard linear algebra.  Generally:\n    // Q0 x + R0 y = S0\n    // Q1 x + R1 y = S1\n    // ... can be solved by Cramer's rule:\n    // x = det(S0 R0 / S1 R1) / det(Q0 R0 / Q1 R1)\n    // y = det(Q0 S0 / Q1 S1) / det(Q0 R0 / Q1 R1)\n    // ... where det( a b / c d ) = ad - bc, so:\n    // x = (S0 * R1 - R0 * S1) / (Q0 * R1 - R0 * Q1)\n    // y = (Q0 * S1 - S0 * Q1) / (Q0 * R1 - R0 * Q1)\n    // We try to maximize the determinant in the denominator\n    final double denomYZ = this.y * q.z - this.z * q.y;\n    final double denomXZ = this.x * q.z - this.z * q.x;\n    final double denomXY = this.x * q.y - this.y * q.x;\n    if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n      //System.out.println(\"X biggest\");\n      // X is the biggest, so our point will have x0 = 0.0\n      if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomYZ;\n      // Each value of D really is two values of D.  That makes 4 combinations.\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        0.0, (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.y * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.y) * denom,\n        bounds);\n    } else if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n      //System.out.println(\"Y biggest\");\n      // Y is the biggest, so y0 = 0.0\n      if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXZ;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D+MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.z - this.z * -(q.D-MINIMUM_RESOLUTION)) * denom, 0.0, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom,\n        bounds);\n    } else {\n      //System.out.println(\"Z biggest\");\n      // Z is the biggest, so Z0 = 0.0\n      if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n        //System.out.println(\" Denominator is zero: no intersection\");\n        return;\n      }\n      final double denom = 1.0 / denomXY;\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D+MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D+MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D+MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D+MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n      recordLineBounds(planetModel, boundsInfo,\n        lineVectorX, lineVectorY, lineVectorZ,\n        (-(this.D-MINIMUM_RESOLUTION) * q.y - this.y * -(q.D-MINIMUM_RESOLUTION)) * denom, (this.x * -(q.D-MINIMUM_RESOLUTION) + (this.D-MINIMUM_RESOLUTION) * q.x) * denom, 0.0,\n        bounds);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"73684368e131f1201fcf3bfba05533e89f5829d0":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["73684368e131f1201fcf3bfba05533e89f5829d0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","73684368e131f1201fcf3bfba05533e89f5829d0"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["d470c8182e92b264680e34081b75e70a9f2b3c89","73684368e131f1201fcf3bfba05533e89f5829d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b961ff1d2d65eab705046ed52539112d3a5f76e0"],"b961ff1d2d65eab705046ed52539112d3a5f76e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","b961ff1d2d65eab705046ed52539112d3a5f76e0"],"73684368e131f1201fcf3bfba05533e89f5829d0":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["73684368e131f1201fcf3bfba05533e89f5829d0","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b961ff1d2d65eab705046ed52539112d3a5f76e0":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}