{"path":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","commits":[{"id":"6d2b17f10a0d622e1a8082a94957764dad150530","date":1097079592,"type":0,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  public Query rewrite(IndexReader reader) throws IOException {\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    \n    try {\n      do {\n        float minScore = 0.0f;\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          // terms come in alphabetical order, therefore if queue is full and score\n          // not bigger than minScore, we can skip\n          if(stQueue.size() < maxClauseCount || score > minScore){\n            stQueue.insert(new ScoreTerm(t, score));\n            minScore = ((ScoreTerm)stQueue.top()).score; // maintain minScore\n          }\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery();\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fe3732bab262f4cd83c8ea793dcd66b8b6da3321"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcbc8ed27f45a5a299f8414d7a886340ce7bb3db","date":1110223587,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  public Query rewrite(IndexReader reader) throws IOException {\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    \n    try {\n      do {\n        float minScore = 0.0f;\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          // terms come in alphabetical order, therefore if queue is full and score\n          // not bigger than minScore, we can skip\n          if(stQueue.size() < maxClauseCount || score > minScore){\n            stQueue.insert(new ScoreTerm(t, score));\n            minScore = ((ScoreTerm)stQueue.top()).score; // maintain minScore\n          }\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query rewrite(IndexReader reader) throws IOException {\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    \n    try {\n      do {\n        float minScore = 0.0f;\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          // terms come in alphabetical order, therefore if queue is full and score\n          // not bigger than minScore, we can skip\n          if(stQueue.size() < maxClauseCount || score > minScore){\n            stQueue.insert(new ScoreTerm(t, score));\n            minScore = ((ScoreTerm)stQueue.top()).score; // maintain minScore\n          }\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery();\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5241670df94f0524d3e8e9764331dea13b545564","date":1197914713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  public Query rewrite(IndexReader reader) throws IOException {\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query rewrite(IndexReader reader) throws IOException {\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    \n    try {\n      do {\n        float minScore = 0.0f;\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          // terms come in alphabetical order, therefore if queue is full and score\n          // not bigger than minScore, we can skip\n          if(stQueue.size() < maxClauseCount || score > minScore){\n            stQueue.insert(new ScoreTerm(t, score));\n            minScore = ((ScoreTerm)stQueue.top()).score; // maintain minScore\n          }\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["fe3732bab262f4cd83c8ea793dcd66b8b6da3321"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d308493f28656b4f3d6b6a9e13d5712b679db6ee","date":1232303054,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can't match\n      return new BooleanQuery();\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query rewrite(IndexReader reader) throws IOException {\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"322d95cfb0c59ace7533e19e5cec7f359ce6d6d3","date":1255442836,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can't match\n      return new BooleanQuery();\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can't match\n      return new BooleanQuery();\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4f6245da77656e0c8850dec612ccf4ff80cfffc","date":1255714636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can't match\n      return new BooleanQuery();\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20645c714ca2a7b7707c2707d58ee9fa384c7362","date":1256074979,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = (ScoreTerm) stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["fe3732bab262f4cd83c8ea793dcd66b8b6da3321"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe3732bab262f4cd83c8ea793dcd66b8b6da3321","date":1257538523,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    int maxSize = BooleanQuery.getMaxClauseCount();\n    PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>(1024);\n    FilteredTermEnum enumerator = getEnum(reader);\n    try {\n      ScoreTerm bottomSt = null;\n      do {\n        final Term t = enumerator.term();\n        if (t == null) break;\n        ScoreTerm st = new ScoreTerm(t, enumerator.difference());\n        if (stQueue.size() < maxSize) {\n          // record the current bottom item\n          if (bottomSt == null || st.compareTo(bottomSt) > 0) {\n            bottomSt = st;\n          }\n          // add to PQ, as it is not yet filled up\n          stQueue.offer(st);\n        } else {\n          assert bottomSt != null;\n          // only add to PQ, if the ScoreTerm is greater than the current bottom,\n          // as all entries will be enqueued after the current bottom and will never be visible\n          if (st.compareTo(bottomSt) < 0) {\n            stQueue.offer(st);\n          }\n        }\n        //System.out.println(\"current: \"+st.term+\"(\"+st.score+\"), bottom: \"+bottomSt.term+\"(\"+bottomSt.score+\")\");\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = Math.min(stQueue.size(), maxSize);\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.poll();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    FilteredTermEnum enumerator = getEnum(reader);\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    ScoreTermQueue stQueue = new ScoreTermQueue(maxClauseCount);\n    ScoreTerm reusableST = null;\n\n    try {\n      do {\n        float score = 0.0f;\n        Term t = enumerator.term();\n        if (t != null) {\n          score = enumerator.difference();\n          if (reusableST == null) {\n            reusableST = new ScoreTerm(t, score);\n          } else if (score >= reusableST.score) {\n            // reusableST holds the last \"rejected\" entry, so, if\n            // this new score is not better than that, there's no\n            // need to try inserting it\n            reusableST.score = score;\n            reusableST.term = t;\n          } else {\n            continue;\n          }\n\n          reusableST = stQueue.insertWithOverflow(reusableST);\n        }\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = stQueue.size();\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.pop();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":["6d2b17f10a0d622e1a8082a94957764dad150530","20645c714ca2a7b7707c2707d58ee9fa384c7362","5241670df94f0524d3e8e9764331dea13b545564"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6cac733bfe923fb362d2b289b2996b0bf10ae22e","date":1260443093,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/FuzzyQuery#rewrite(IndexReader).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if(!termLongEnough) {  // can only match if it's exact\n      return new TermQuery(term);\n    }\n\n    int maxSize = BooleanQuery.getMaxClauseCount();\n    PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>(1024);\n    FilteredTermEnum enumerator = getEnum(reader);\n    try {\n      ScoreTerm bottomSt = null;\n      do {\n        final Term t = enumerator.term();\n        if (t == null) break;\n        ScoreTerm st = new ScoreTerm(t, enumerator.difference());\n        if (stQueue.size() < maxSize) {\n          // record the current bottom item\n          if (bottomSt == null || st.compareTo(bottomSt) > 0) {\n            bottomSt = st;\n          }\n          // add to PQ, as it is not yet filled up\n          stQueue.offer(st);\n        } else {\n          assert bottomSt != null;\n          // only add to PQ, if the ScoreTerm is greater than the current bottom,\n          // as all entries will be enqueued after the current bottom and will never be visible\n          if (st.compareTo(bottomSt) < 0) {\n            stQueue.offer(st);\n          }\n        }\n        //System.out.println(\"current: \"+st.term+\"(\"+st.score+\"), bottom: \"+bottomSt.term+\"(\"+bottomSt.score+\")\");\n      } while (enumerator.next());\n    } finally {\n      enumerator.close();\n    }\n    \n    BooleanQuery query = new BooleanQuery(true);\n    int size = Math.min(stQueue.size(), maxSize);\n    for(int i = 0; i < size; i++){\n      ScoreTerm st = stQueue.poll();\n      TermQuery tq = new TermQuery(st.term);      // found a match\n      tq.setBoost(getBoost() * st.score); // set the boost\n      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6d2b17f10a0d622e1a8082a94957764dad150530":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"322d95cfb0c59ace7533e19e5cec7f359ce6d6d3":["d308493f28656b4f3d6b6a9e13d5712b679db6ee"],"6cac733bfe923fb362d2b289b2996b0bf10ae22e":["fe3732bab262f4cd83c8ea793dcd66b8b6da3321"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fe3732bab262f4cd83c8ea793dcd66b8b6da3321":["20645c714ca2a7b7707c2707d58ee9fa384c7362"],"d4f6245da77656e0c8850dec612ccf4ff80cfffc":["322d95cfb0c59ace7533e19e5cec7f359ce6d6d3"],"d308493f28656b4f3d6b6a9e13d5712b679db6ee":["5241670df94f0524d3e8e9764331dea13b545564"],"20645c714ca2a7b7707c2707d58ee9fa384c7362":["d4f6245da77656e0c8850dec612ccf4ff80cfffc"],"5241670df94f0524d3e8e9764331dea13b545564":["bcbc8ed27f45a5a299f8414d7a886340ce7bb3db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6cac733bfe923fb362d2b289b2996b0bf10ae22e"],"bcbc8ed27f45a5a299f8414d7a886340ce7bb3db":["6d2b17f10a0d622e1a8082a94957764dad150530"]},"commit2Childs":{"6d2b17f10a0d622e1a8082a94957764dad150530":["bcbc8ed27f45a5a299f8414d7a886340ce7bb3db"],"322d95cfb0c59ace7533e19e5cec7f359ce6d6d3":["d4f6245da77656e0c8850dec612ccf4ff80cfffc"],"6cac733bfe923fb362d2b289b2996b0bf10ae22e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6d2b17f10a0d622e1a8082a94957764dad150530"],"d308493f28656b4f3d6b6a9e13d5712b679db6ee":["322d95cfb0c59ace7533e19e5cec7f359ce6d6d3"],"fe3732bab262f4cd83c8ea793dcd66b8b6da3321":["6cac733bfe923fb362d2b289b2996b0bf10ae22e"],"d4f6245da77656e0c8850dec612ccf4ff80cfffc":["20645c714ca2a7b7707c2707d58ee9fa384c7362"],"20645c714ca2a7b7707c2707d58ee9fa384c7362":["fe3732bab262f4cd83c8ea793dcd66b8b6da3321"],"5241670df94f0524d3e8e9764331dea13b545564":["d308493f28656b4f3d6b6a9e13d5712b679db6ee"],"bcbc8ed27f45a5a299f8414d7a886340ce7bb3db":["5241670df94f0524d3e8e9764331dea13b545564"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}