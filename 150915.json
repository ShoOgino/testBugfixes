{"path":"solr/core/src/test/org/apache/solr/schema/EnumFieldTest#testMultivaluedSetQuery().mjava","commits":[{"id":"54ad8c9e9210e008dc7b8ad5a037ff20879150ea","date":1501889566,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/EnumFieldTest#testMultivaluedSetQuery().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMultivaluedSetQuery() throws Exception {\n    assumeFalse(\"Skipping testing of EnumFieldType without docValues, which is unsupported.\",\n        System.getProperty(\"solr.tests.EnumFieldType\").equals(\"solr.EnumFieldType\")\n            && System.getProperty(\"solr.tests.numeric.dv\").equals(\"false\"));\n    assumeFalse(\"Skipping testing of unindexed EnumField without docValues, which is unsupported.\",\n        System.getProperty(\"solr.tests.EnumFieldType\").equals(\"solr.EnumField\")\n            && System.getProperty(\"solr.tests.EnumFieldTest.indexed\").equals(\"false\")\n            && System.getProperty(\"solr.tests.numeric.dv\").equals(\"false\"));\n\n    clearIndex();\n\n    SchemaField sf = h.getCore().getLatestSchema().getField(MV_FIELD_NAME);\n    Set<String> enumStrs = ((AbstractEnumField)sf.getType()).getEnumMapping().enumStringToIntMap.keySet();\n    assertTrue(enumStrs.size() > SolrQueryParser.TERMS_QUERY_THRESHOLD);\n\n    Iterator<String> enumStrIter = enumStrs.iterator();\n    String prevEnumStr = \"x18\"; // wrap around\n    for (int i = 0 ; enumStrIter.hasNext() ; ++i) {\n      String thisEnumStr = enumStrIter.next();\n      assertU(adoc(\"id\", \"\" + i, MV_FIELD_NAME, thisEnumStr, MV_FIELD_NAME, prevEnumStr));\n      prevEnumStr = thisEnumStr; \n    }\n    assertU(commit());\n\n    StringBuilder builder = new StringBuilder(MV_FIELD_NAME + \":(\");\n    enumStrs.forEach(v -> builder.append(v.replace(\" \", \"\\\\ \")).append(' '));\n    builder.append(')');\n\n    if (sf.indexed()) { // SolrQueryParser should also be generating a TermInSetQuery if indexed\n      String setQuery = sf.getType().getSetQuery(null, sf, enumStrs).toString();\n      if (sf.getType() instanceof EnumField) { // Trie field TermInSetQuery non-XML chars serialize with \"#XX;\" syntax\n        Pattern nonXMLCharPattern = Pattern.compile(\"[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u0019]\");\n        StringBuffer munged = new StringBuffer();\n        Matcher matcher = nonXMLCharPattern.matcher(setQuery);\n        while (matcher.find()) {\n          matcher.appendReplacement(munged, \"#\" + (int)matcher.group(0).charAt(0) + \";\");\n        }\n        matcher.appendTail(munged);\n        setQuery = munged.toString();\n      }\n      assertQ(req(CommonParams.DEBUG, CommonParams.QUERY, \"q\", \"*:*\", \"fq\", builder.toString(),\n          \"fl\", \"id,\" + MV_FIELD_NAME, \"rows\", \"\" + enumStrs.size(), \"indent\", \"on\"),\n          \"//*[@numFound='\" + enumStrs.size() + \"']\",\n          \"//*[@name='parsed_filter_queries']/str[normalize-space(.)=normalize-space('TermInSetQuery(\" + setQuery + \")')]\");  // fix [\\r\\n] problems\n    } else {\n      // Won't use TermInSetQuery if the field is not indexed, but should match the same docs\n      assertQ(req(CommonParams.DEBUG, CommonParams.QUERY, \"q\", \"*:*\", \"fq\", builder.toString(), \"fl\", \"id,\" + MV_FIELD_NAME, \"indent\", \"on\"),\n          \"//*[@numFound='\" + enumStrs.size() + \"']\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/EnumFieldTest#testMultivaluedSetQuery().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMultivaluedSetQuery() throws Exception {\n    assumeFalse(\"Skipping testing of EnumFieldType without docValues, which is unsupported.\",\n        System.getProperty(\"solr.tests.EnumFieldType\").equals(\"solr.EnumFieldType\")\n            && System.getProperty(\"solr.tests.numeric.dv\").equals(\"false\"));\n    assumeFalse(\"Skipping testing of unindexed EnumField without docValues, which is unsupported.\",\n        System.getProperty(\"solr.tests.EnumFieldType\").equals(\"solr.EnumField\")\n            && System.getProperty(\"solr.tests.EnumFieldTest.indexed\").equals(\"false\")\n            && System.getProperty(\"solr.tests.numeric.dv\").equals(\"false\"));\n\n    clearIndex();\n\n    SchemaField sf = h.getCore().getLatestSchema().getField(MV_FIELD_NAME);\n    Set<String> enumStrs = ((AbstractEnumField)sf.getType()).getEnumMapping().enumStringToIntMap.keySet();\n    assertTrue(enumStrs.size() > SolrQueryParser.TERMS_QUERY_THRESHOLD);\n\n    Iterator<String> enumStrIter = enumStrs.iterator();\n    String prevEnumStr = \"x18\"; // wrap around\n    for (int i = 0 ; enumStrIter.hasNext() ; ++i) {\n      String thisEnumStr = enumStrIter.next();\n      assertU(adoc(\"id\", \"\" + i, MV_FIELD_NAME, thisEnumStr, MV_FIELD_NAME, prevEnumStr));\n      prevEnumStr = thisEnumStr; \n    }\n    assertU(commit());\n\n    StringBuilder builder = new StringBuilder(MV_FIELD_NAME + \":(\");\n    enumStrs.forEach(v -> builder.append(v.replace(\" \", \"\\\\ \")).append(' '));\n    builder.append(')');\n\n    if (sf.indexed()) { // SolrQueryParser should also be generating a TermInSetQuery if indexed\n      String setQuery = sf.getType().getSetQuery(null, sf, enumStrs).toString();\n      if (sf.getType() instanceof EnumField) { // Trie field TermInSetQuery non-XML chars serialize with \"#XX;\" syntax\n        Pattern nonXMLCharPattern = Pattern.compile(\"[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u0019]\");\n        StringBuffer munged = new StringBuffer();\n        Matcher matcher = nonXMLCharPattern.matcher(setQuery);\n        while (matcher.find()) {\n          matcher.appendReplacement(munged, \"#\" + (int)matcher.group(0).charAt(0) + \";\");\n        }\n        matcher.appendTail(munged);\n        setQuery = munged.toString();\n      }\n      assertQ(req(CommonParams.DEBUG, CommonParams.QUERY, \"q\", \"*:*\", \"fq\", builder.toString(),\n          \"fl\", \"id,\" + MV_FIELD_NAME, \"rows\", \"\" + enumStrs.size(), \"indent\", \"on\"),\n          \"//*[@numFound='\" + enumStrs.size() + \"']\",\n          \"//*[@name='parsed_filter_queries']/str[normalize-space(.)=normalize-space('TermInSetQuery(\" + setQuery + \")')]\");  // fix [\\r\\n] problems\n    } else {\n      // Won't use TermInSetQuery if the field is not indexed, but should match the same docs\n      assertQ(req(CommonParams.DEBUG, CommonParams.QUERY, \"q\", \"*:*\", \"fq\", builder.toString(), \"fl\", \"id,\" + MV_FIELD_NAME, \"indent\", \"on\"),\n          \"//*[@numFound='\" + enumStrs.size() + \"']\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"54ad8c9e9210e008dc7b8ad5a037ff20879150ea":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54ad8c9e9210e008dc7b8ad5a037ff20879150ea"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"54ad8c9e9210e008dc7b8ad5a037ff20879150ea":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}