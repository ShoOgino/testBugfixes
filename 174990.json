{"path":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","commits":[{"id":"1919b234a992d6438a59ccbb02bd0656162e602e","date":1242941438,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","pathOld":"/dev/null","sourceNew":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              public int doc() {\n                return pos-base;\n              }\n\n              public boolean next() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return pos>=0 && pos<max;\n              }\n\n              public boolean skipTo(int target) throws IOException {\n                pos = bs.nextSetBit(target+base);\n                return pos>=0 && pos<max;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19a6a2b00bd8d0dbd9684de00bb3018e4664a1e5","date":1247703137,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","pathOld":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","sourceNew":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              int adjustedDoc=-1;\n\n              @Override\n              public int docID() {\n                return adjustedDoc;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                if (target==NO_MORE_DOCS) return adjustedDoc=NO_MORE_DOCS;\n                pos = bs.nextSetBit(target+base);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              public int doc() {\n                return pos-base;\n              }\n\n              public boolean next() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return pos>=0 && pos<max;\n              }\n\n              public boolean skipTo(int target) throws IOException {\n                pos = bs.nextSetBit(target+base);\n                return pos>=0 && pos<max;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a923408680bb84f7886ffc3fc1ee74a426bc493","date":1253320441,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","pathOld":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","sourceNew":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              int adjustedDoc=-1;\n\n              @Override\n              public int docID() {\n                return adjustedDoc;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                if (target==NO_MORE_DOCS) return adjustedDoc=NO_MORE_DOCS;\n                pos = bs.nextSetBit(target+base);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n            };\n          }\n\n          @Override\n          public boolean isCacheable() {\n            return true;\n          }\n\n        };\n      }\n    };\n  }\n\n","sourceOld":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              int adjustedDoc=-1;\n\n              @Override\n              public int docID() {\n                return adjustedDoc;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                if (target==NO_MORE_DOCS) return adjustedDoc=NO_MORE_DOCS;\n                pos = bs.nextSetBit(target+base);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","pathOld":"src/java/org/apache/solr/search/DocSetBase[DocSet]#getTopFilter().mjava","sourceNew":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              int adjustedDoc=-1;\n\n              @Override\n              public int docID() {\n                return adjustedDoc;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                if (target==NO_MORE_DOCS) return adjustedDoc=NO_MORE_DOCS;\n                pos = bs.nextSetBit(target+base);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n            };\n          }\n\n          @Override\n          public boolean isCacheable() {\n            return true;\n          }\n\n        };\n      }\n    };\n  }\n\n","sourceOld":"  public Filter getTopFilter() {\n    final OpenBitSet bs = getBits();\n\n    return new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        int offset = 0;\n        SolrIndexReader r = (SolrIndexReader)reader;\n        while (r.getParent() != null) {\n          offset += r.getBase();\n          r = r.getParent();\n        }\n\n        if (r==reader) return bs;\n\n        final int base = offset;\n        final int maxDoc = reader.maxDoc();\n        final int max = base + maxDoc;   // one past the max doc in this segment.\n\n        return new DocIdSet() {\n          public DocIdSetIterator iterator() throws IOException {\n            return new DocIdSetIterator() {\n              int pos=base-1;\n              int adjustedDoc=-1;\n\n              @Override\n              public int docID() {\n                return adjustedDoc;\n              }\n\n              @Override\n              public int nextDoc() throws IOException {\n                pos = bs.nextSetBit(pos+1);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n\n              @Override\n              public int advance(int target) throws IOException {\n                if (target==NO_MORE_DOCS) return adjustedDoc=NO_MORE_DOCS;\n                pos = bs.nextSetBit(target+base);\n                return adjustedDoc = (pos>=0 && pos<max) ? pos-base : NO_MORE_DOCS;\n              }\n            };\n          }\n\n          @Override\n          public boolean isCacheable() {\n            return true;\n          }\n\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1919b234a992d6438a59ccbb02bd0656162e602e":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["0a923408680bb84f7886ffc3fc1ee74a426bc493"],"0a923408680bb84f7886ffc3fc1ee74a426bc493":["19a6a2b00bd8d0dbd9684de00bb3018e4664a1e5"],"19a6a2b00bd8d0dbd9684de00bb3018e4664a1e5":["1919b234a992d6438a59ccbb02bd0656162e602e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1919b234a992d6438a59ccbb02bd0656162e602e":["19a6a2b00bd8d0dbd9684de00bb3018e4664a1e5"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["1919b234a992d6438a59ccbb02bd0656162e602e"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"0a923408680bb84f7886ffc3fc1ee74a426bc493":["ad94625fb8d088209f46650c8097196fec67f00c"],"19a6a2b00bd8d0dbd9684de00bb3018e4664a1e5":["0a923408680bb84f7886ffc3fc1ee74a426bc493"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}