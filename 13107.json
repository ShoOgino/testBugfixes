{"path":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","commits":[{"id":"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5","date":1395042605,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.shutdown();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.shutdown();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c","date":1416362965,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["04f07771a2a7dd3a395700665ed839c3dae2def2","6613659748fe4411a7dcf85266e55db1f95f7315"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"431452b6326a9c17ba5bb1e1a6d89e23a8932e73","date":1417113370,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, PostingsEnum.FLAG_FREQS);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, PostingsEnum.FLAG_FREQS);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5b816df64f2b489d1e711be80f9416f9862c1b","date":1487973679,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, true);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e708f948b384f9aa85c665caee4486eb2d9e197d","date":1533106881,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36510a8e3c1ec60d366b45f8f716e9dc47589661","date":1561989412,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        for (int i = 0; i < subHits.scoreDocs.length; i++) {\n          subHits.scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4f6b0fb6f08ac48f438f03002a283a63cb9992","date":1561992803,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        for (int i = 0; i < subHits.scoreDocs.length; i++) {\n          subHits.scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        for (int i = 0; i < subHits.scoreDocs.length; i++) {\n          subHits.scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(new SortedDocValuesField(\"string\", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatDocValuesField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new NumericDocValuesField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof LeafReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    int numIters = atLeast(300); \n    for(int iter=0;iter<numIters;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, Integer.MAX_VALUE);\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits.value + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE, 1);\n\n      final TopDocs[] shardHits;\n      if (sort == null) {\n        shardHits = new TopDocs[subSearchers.length];\n      } else {\n        shardHits = new TopFieldDocs[subSearchers.length];\n      }\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits.value + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(from, size, shardHits, true);\n        } else {\n          mergedHits = TopDocs.merge(sort, from, size, (TopFieldDocs[]) shardHits, true);\n        }\n      } else {\n        if (sort == null) {\n          mergedHits = TopDocs.merge(numHits, shardHits);\n        } else {\n          mergedHits = TopDocs.merge(sort, numHits, (TopFieldDocs[]) shardHits);\n        }\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertConsistent(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"475584d5e08a22ad3fc7babefe006d77bc744567":["417142ff08fda9cf0b72d5133e63097a166c6458"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["9a5b816df64f2b489d1e711be80f9416f9862c1b","404d1ab7f6f396235047017c88d545fec15dafb7"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["417142ff08fda9cf0b72d5133e63097a166c6458","475584d5e08a22ad3fc7babefe006d77bc744567"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["d58e44159788900f4a2113b84463dc3fbbf80f20","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"404d1ab7f6f396235047017c88d545fec15dafb7":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"431452b6326a9c17ba5bb1e1a6d89e23a8932e73":["0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"],"417142ff08fda9cf0b72d5133e63097a166c6458":["1aad05eeff7818b0833c02ac6b743aa72054963b","9fc47cb7b4346802411bb432f501ed0673d7119e"],"0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["431452b6326a9c17ba5bb1e1a6d89e23a8932e73"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fccd4a691aac1aff06ab8110d8693514a34160c3"]},"commit2Childs":{"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6a47d642ab24da1a811adce4bda9cc52c520ca13":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"431452b6326a9c17ba5bb1e1a6d89e23a8932e73":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"417142ff08fda9cf0b72d5133e63097a166c6458":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c":["431452b6326a9c17ba5bb1e1a6d89e23a8932e73"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["fb17639909a369c1e64866842e5c213440acc17e"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["04c370507e5521b2eb998530736f1c19b851ed5a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}