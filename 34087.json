{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrConfig.severeErrors.add(e);\n      SolrException.logOnce(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["45903437caf2081e259d21447c117144056c6f78"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = System.getProperty(\"hostPort\");\n    if (hostPort == null) {\n      hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n    }\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n    boolean defaultCoreFound = false;\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n    \n    if(zkController != null) {\n      try {\n        synchronized (zkController.getZkStateReader().getUpdateLock()) {\n          zkController.getZkStateReader().makeShardZkNodeWatches(false);\n          zkController.getZkStateReader().updateCloudState(true);\n        }\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (IOException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4901f8624f774c2b648e66567b63c59e901ac7c8","date":1329431044,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    Config cfg = new Config(loader, null, cfgis, null);\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", false);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", 10000);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", \"8983\");\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", \"solr\");\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\"solr\", XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String name = DOMUtil.getAttr(node, \"name\", null);\n        if (null == name) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        if (name.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["45903437caf2081e259d21447c117144056c6f78"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"083df6f7d2115772bdcf0f53c63aa859e664c69e","date":1332809829,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"829761a123d59d7a3c39e5f13fbc03de63f55ce5","date":1334686329,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b560bb9e5a33049a66d34f96dacbcaa48825a7eb","date":1334773717,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e635cfcf66f9e8b914c54c24d337820e475f44a5","date":1335303739,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name;\n        if (rawName.equals(defaultCoreName)){\n          // for the default core we use a blank name,\n          // later on attempts to access it by it's full name will \n          // be mapped to this.\n          name=\"\";\n        } else {\n          name = rawName;\n        }\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c40f7e61f6e10a667a7d0f7d4678cc2a1119f9c","date":1335549453,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82daf78f1dbfb7509f45232a780921b83302af25","date":1335549554,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Exception ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73fcd0c74864800c15eed65525d4834e9d25ce9a","date":1335892123,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version\", ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45903437caf2081e259d21447c117144056c6f78","date":1342651318,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","4901f8624f774c2b648e66567b63c59e901ac7c8","b24326411db492f92ea49f6fb947c90bc73cf19e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, \"name\", null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, \"instanceDir\", null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, \"config\", null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, \"schema\", null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, \"shard\", null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"collection\", null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, \"roles\", null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, \"properties\", null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CoreAdminParams.DATA_DIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", \"180000\"); // 3 minutes\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", null);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"bugIntro":["98c6ef0fabf756c297d397f33729ffe46e760a4f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98c6ef0fabf756c297d397f33729ffe46e760a4f","date":1347661885,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", \"180000\"); // 3 minutes\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n        \t  p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   * @throws ParserConfigurationException\n   * @throws IOException\n   * @throws SAXException\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0f13c90eb0831e9400aab99a549a0d18506f8f2","date":1351527039,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      SolrCore core = null;\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        core  = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        SolrCore core = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n      }\n    }\n  }\n\n","bugFix":["b24326411db492f92ea49f6fb947c90bc73cf19e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b374d78db8148ec6796fdf37148b33897ab40a8c","date":1351606544,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores  var is now initialized to null, let's set it up right now.\n    cfg.substituteProperties();\n\n    allocateLazyCores(cfg);\n\n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      SolrCore core = null;\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n        if (opt != null) {\n          p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\".equalsIgnoreCase(opt)) ? true : false);\n        }\n\n        opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n        if (opt != null) {\n          p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\".equalsIgnoreCase(opt)) ? true : false);\n        }\n\n        if (! p.isSwappable() && p.isLoadOnStartup()) { // Just like current case.\n          core = create(p);\n          register(name, core, false);\n          // track original names\n          coreToOrigName.put(core, rawName);\n        } else {\n          // Store it away for later use. includes non-swappable but not loaded at startup cores.\n          dynamicDescriptors.put(rawName, p);\n        }\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)\n      throws ParserConfigurationException, IOException, SAXException {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg = new Config(loader, null, cfgis, null, false);\n    \n    // keep orig config for persist to consult\n    try {\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (TransformerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    cfg.substituteProperties();\n    \n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n//        else if( \"Log4j\".equals(fname) ) {\n//          logging = new Log4jWatcher(slf4jImpl);\n//        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      SolrCore core = null;\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        core  = create(p);\n        register(name, core, false);\n        \n        // track original names\n        coreToOrigName.put(core, rawName);\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ce60a6712f1e8ef7077bc4051aefc65f457f283","date":1352661483,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        SolrCore core = null;\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores  var is now initialized to null, let's set it up right now.\n    cfg.substituteProperties();\n\n    allocateLazyCores(cfg);\n\n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      SolrCore core = null;\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n        if (opt != null) {\n          p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\".equalsIgnoreCase(opt)) ? true : false);\n        }\n\n        opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n        if (opt != null) {\n          p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\".equalsIgnoreCase(opt)) ? true : false);\n        }\n\n        if (! p.isSwappable() && p.isLoadOnStartup()) { // Just like current case.\n          core = create(p);\n          register(name, core, false);\n          // track original names\n          coreToOrigName.put(core, rawName);\n        } else {\n          // Store it away for later use. includes non-swappable but not loaded at startup cores.\n          dynamicDescriptors.put(rawName, p);\n        }\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8d9daa29108c4330a5533a5cddaa9a95e7eb3061","c8c09c323959c458fb515b3f9a2ce29958ce1478","c8c09c323959c458fb515b3f9a2ce29958ce1478","c8c09c323959c458fb515b3f9a2ce29958ce1478","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","4cc2a5e90b34bfc6bb00b6261a7956c2c022c275","4cc2a5e90b34bfc6bb00b6261a7956c2c022c275"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fdc2efb81935be8f1653f02e3c0703235de3cd9a","date":1352662220,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        SolrCore core = null;\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n\n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores  var is now initialized to null, let's set it up right now.\n    cfg.substituteProperties();\n\n    allocateLazyCores(cfg);\n\n    // Initialize Logging\n    if(cfg.getBool(\"solr/logging/@enabled\",true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();\n        if(fname==null) {\n          if( slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\" );\n          }\n          else if( slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      }\n      catch(Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"+ex);\n      }\n      \n      // Now load the framework\n      if(fname!=null) {\n        if(\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          }\n          catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if( logging != null ) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\",50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\",null);\n          if(v.size>0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if(dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\" , null);\n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n\n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if(shareSchema){\n      indexSchemaCache = new ConcurrentHashMap<String ,IndexSchema>();\n    }\n    adminHandler  = cfg.get(\"solr/cores/@adminHandler\", null );\n    managementPath  = cfg.get(\"solr/cores/@managementPath\", null );\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\", Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info( \"loading shared library: \"+f.getAbsolutePath() );\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n\n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n\n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log,null,e);\n    }\n\n    NodeList nodes = (NodeList)cfg.evaluate(\"solr/cores/core\", XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n      SolrCore core = null;\n      try {\n        String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n        if (null == rawName) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                  \"Each core in solr.xml must have a 'name'\");\n        }\n        String name = rawName;\n        CoreDescriptor p = new CoreDescriptor(this, name, DOMUtil.getAttr(node, CORE_INSTDIR, null));\n\n        // deal with optional settings\n        String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n\n        if (opt != null) {\n          p.setConfigName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n        if (opt != null) {\n          p.setSchemaName(opt);\n        }\n\n        if (zkController != null) {\n          opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n          if (opt != null && opt.length() > 0) {\n            p.getCloudDescriptor().setShardId(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n          if (opt != null) {\n            p.getCloudDescriptor().setCollectionName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n          if(opt != null){\n            p.getCloudDescriptor().setRoles(opt);\n          }\n        }\n        opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n        if (opt != null) {\n          p.setPropertiesName(opt);\n        }\n        opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n        if (opt != null) {\n          p.setDataDir(opt);\n        }\n\n        p.setCoreProperties(readProperties(cfg, node));\n\n        opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n        if (opt != null) {\n          p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\".equalsIgnoreCase(opt)) ? true : false);\n        }\n\n        opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n        if (opt != null) {\n          p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\".equalsIgnoreCase(opt)) ? true : false);\n        }\n\n        if (! p.isSwappable() && p.isLoadOnStartup()) { // Just like current case.\n          core = create(p);\n          register(name, core, false);\n          // track original names\n          coreToOrigName.put(core, rawName);\n        } else {\n          // Store it away for later use. includes non-swappable but not loaded at startup cores.\n          dynamicDescriptors.put(rawName, p);\n        }\n      }\n      catch (Throwable ex) {\n        SolrException.log(log,null,ex);\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d9daa29108c4330a5533a5cddaa9a95e7eb3061","date":1355669188,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":["5ce60a6712f1e8ef7077bc4051aefc65f457f283"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69439d0df009e0bb0038d1e427159f449dd670d","date":1355704683,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f4821d05931759774f7fd656e31d449de2d1436","date":1355887327,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6b4b8d3d62eadaf42f3c2c0a23230275892d374","date":1355937334,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80ba0e0ced6273399ff97caaf301445b9fd24895","date":1356802943,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c33399cc2618223f11ba493f9a3a2026fe05b579","date":1356813042,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isTransient()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isSwappable()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isTransient()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5,\n        TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      // 4 threads at a time max\n      final AdjustableSemaphore semaphore = new AdjustableSemaphore(\n          coreLoadThreads);\n      \n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);\n          if (opt != null) {\n            p.setSwappable((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (!p.isSwappable() && p.isLoadOnStartup()) { // Just like current\n                                                         // case.\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  register(name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                semaphore.release();\n                \n                return c;\n              }\n            };\n            \n            try {\n              semaphore.acquire();\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Interrupted while loading SolrCore(s)\", e);\n            }\n            \n            try {\n              pending.add(completionService.submit(task));\n            } catch (RejectedExecutionException e) {\n              semaphore.release();\n              throw e;\n            }\n            \n          } else {\n            // Store it away for later use. includes non-swappable but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            // shouldn't happen since we catch exceptions ourselves\n            SolrException.log(SolrCore.log,\n                \"error sending update request to shard\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted waiting for shard update response\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isTransient()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isTransient()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isTransient()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4cc2a5e90b34bfc6bb00b6261a7956c2c022c275","4cc2a5e90b34bfc6bb00b6261a7956c2c022c275"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","c33399cc2618223f11ba493f9a3a2026fe05b579"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["d6b4b8d3d62eadaf42f3c2c0a23230275892d374"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"a69439d0df009e0bb0038d1e427159f449dd670d":["8d9daa29108c4330a5533a5cddaa9a95e7eb3061"],"5ce60a6712f1e8ef7077bc4051aefc65f457f283":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["33d0ed80b7b47e34ad3ff033a77544563aba3085","45903437caf2081e259d21447c117144056c6f78"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fdc2efb81935be8f1653f02e3c0703235de3cd9a":["5ce60a6712f1e8ef7077bc4051aefc65f457f283"],"d6b4b8d3d62eadaf42f3c2c0a23230275892d374":["7f4821d05931759774f7fd656e31d449de2d1436"],"b374d78db8148ec6796fdf37148b33897ab40a8c":["c0f13c90eb0831e9400aab99a549a0d18506f8f2"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["c26f00b574427b55127e869b935845554afde1fa"],"c0f13c90eb0831e9400aab99a549a0d18506f8f2":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"e635cfcf66f9e8b914c54c24d337820e475f44a5":["b560bb9e5a33049a66d34f96dacbcaa48825a7eb"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["73fcd0c74864800c15eed65525d4834e9d25ce9a"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["45903437caf2081e259d21447c117144056c6f78"],"73fcd0c74864800c15eed65525d4834e9d25ce9a":["82daf78f1dbfb7509f45232a780921b83302af25"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b374d78db8148ec6796fdf37148b33897ab40a8c","fdc2efb81935be8f1653f02e3c0703235de3cd9a"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"829761a123d59d7a3c39e5f13fbc03de63f55ce5":["083df6f7d2115772bdcf0f53c63aa859e664c69e"],"82daf78f1dbfb7509f45232a780921b83302af25":["9c40f7e61f6e10a667a7d0f7d4678cc2a1119f9c"],"9c40f7e61f6e10a667a7d0f7d4678cc2a1119f9c":["e635cfcf66f9e8b914c54c24d337820e475f44a5"],"083df6f7d2115772bdcf0f53c63aa859e664c69e":["4901f8624f774c2b648e66567b63c59e901ac7c8"],"b560bb9e5a33049a66d34f96dacbcaa48825a7eb":["829761a123d59d7a3c39e5f13fbc03de63f55ce5"],"7f4821d05931759774f7fd656e31d449de2d1436":["a69439d0df009e0bb0038d1e427159f449dd670d"],"a6378064655e76cd7b908b1cab4ce425b384b508":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"4901f8624f774c2b648e66567b63c59e901ac7c8":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"8d9daa29108c4330a5533a5cddaa9a95e7eb3061":["7530de27b87b961b51f01bd1299b7004d46e8823"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["73fcd0c74864800c15eed65525d4834e9d25ce9a","45903437caf2081e259d21447c117144056c6f78"],"45903437caf2081e259d21447c117144056c6f78":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a837c064b67fa63a9394136e31218b908cdcf783":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["c33399cc2618223f11ba493f9a3a2026fe05b579"],"7530de27b87b961b51f01bd1299b7004d46e8823":["fdc2efb81935be8f1653f02e3c0703235de3cd9a"],"98c6ef0fabf756c297d397f33729ffe46e760a4f":["a6378064655e76cd7b908b1cab4ce425b384b508"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a837c064b67fa63a9394136e31218b908cdcf783"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["98c6ef0fabf756c297d397f33729ffe46e760a4f"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"80ba0e0ced6273399ff97caaf301445b9fd24895":["c33399cc2618223f11ba493f9a3a2026fe05b579"],"c26f00b574427b55127e869b935845554afde1fa":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"a69439d0df009e0bb0038d1e427159f449dd670d":["7f4821d05931759774f7fd656e31d449de2d1436"],"5ce60a6712f1e8ef7077bc4051aefc65f457f283":["fdc2efb81935be8f1653f02e3c0703235de3cd9a"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"fdc2efb81935be8f1653f02e3c0703235de3cd9a":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"d6b4b8d3d62eadaf42f3c2c0a23230275892d374":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"b374d78db8148ec6796fdf37148b33897ab40a8c":["5ce60a6712f1e8ef7077bc4051aefc65f457f283","407687e67faf6e1f02a211ca078d8e3eed631027"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c0f13c90eb0831e9400aab99a549a0d18506f8f2":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"e635cfcf66f9e8b914c54c24d337820e475f44a5":["9c40f7e61f6e10a667a7d0f7d4678cc2a1119f9c"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["c0f13c90eb0831e9400aab99a549a0d18506f8f2"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["aba371508186796cc6151d8223a5b4e16d02e26e","45903437caf2081e259d21447c117144056c6f78"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["a6378064655e76cd7b908b1cab4ce425b384b508"],"73fcd0c74864800c15eed65525d4834e9d25ce9a":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"829761a123d59d7a3c39e5f13fbc03de63f55ce5":["b560bb9e5a33049a66d34f96dacbcaa48825a7eb"],"82daf78f1dbfb7509f45232a780921b83302af25":["73fcd0c74864800c15eed65525d4834e9d25ce9a"],"9c40f7e61f6e10a667a7d0f7d4678cc2a1119f9c":["82daf78f1dbfb7509f45232a780921b83302af25"],"083df6f7d2115772bdcf0f53c63aa859e664c69e":["829761a123d59d7a3c39e5f13fbc03de63f55ce5"],"b560bb9e5a33049a66d34f96dacbcaa48825a7eb":["e635cfcf66f9e8b914c54c24d337820e475f44a5"],"7f4821d05931759774f7fd656e31d449de2d1436":["d6b4b8d3d62eadaf42f3c2c0a23230275892d374"],"a6378064655e76cd7b908b1cab4ce425b384b508":["98c6ef0fabf756c297d397f33729ffe46e760a4f"],"4901f8624f774c2b648e66567b63c59e901ac7c8":["083df6f7d2115772bdcf0f53c63aa859e664c69e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"8d9daa29108c4330a5533a5cddaa9a95e7eb3061":["a69439d0df009e0bb0038d1e427159f449dd670d"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"45903437caf2081e259d21447c117144056c6f78":["aba371508186796cc6151d8223a5b4e16d02e26e","7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","4901f8624f774c2b648e66567b63c59e901ac7c8"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a837c064b67fa63a9394136e31218b908cdcf783":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7530de27b87b961b51f01bd1299b7004d46e8823":["8d9daa29108c4330a5533a5cddaa9a95e7eb3061"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["a837c064b67fa63a9394136e31218b908cdcf783"],"98c6ef0fabf756c297d397f33729ffe46e760a4f":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0d22ac6a4146774c1bc8400160fc0b6150294e92","aba371508186796cc6151d8223a5b4e16d02e26e","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}