{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9","date":1459984736,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude())));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(point)) {\n              if (shape.isWithin(point)) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        PointInShapeIntersectVisitor.decodeValueMin(cell.xMinEnc), PointInShapeIntersectVisitor.decodeValueMax(cell.xMaxEnc),\n                                                        PointInShapeIntersectVisitor.decodeValueMin(cell.yMinEnc), PointInShapeIntersectVisitor.decodeValueMax(cell.yMaxEnc),\n                                                        PointInShapeIntersectVisitor.decodeValueMin(cell.zMinEnc), PointInShapeIntersectVisitor.decodeValueMax(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+PointInShapeIntersectVisitor.decodeValueMin(cell.xMinEnc)+\" maxx=\"+PointInShapeIntersectVisitor.decodeValueMax(cell.xMaxEnc)+\n              \" miny=\"+PointInShapeIntersectVisitor.decodeValueMin(cell.yMinEnc)+\" maxy=\"+PointInShapeIntersectVisitor.decodeValueMax(cell.yMaxEnc)+\n              \" minz=\"+PointInShapeIntersectVisitor.decodeValueMin(cell.zMinEnc)+\" maxz=\"+PointInShapeIntersectVisitor.decodeValueMax(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        boolean expected = shape.isWithin(point);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"873caa2b3b10bf0e4724a950c3a11b841ebb0e4a","date":1460035668,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude())));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(point)) {\n              if (shape.isWithin(point)) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        boolean expected = shape.isWithin(point);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude())));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(point)) {\n              if (shape.isWithin(point)) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        PointInShapeIntersectVisitor.decodeValueMin(cell.xMinEnc), PointInShapeIntersectVisitor.decodeValueMax(cell.xMaxEnc),\n                                                        PointInShapeIntersectVisitor.decodeValueMin(cell.yMinEnc), PointInShapeIntersectVisitor.decodeValueMax(cell.yMaxEnc),\n                                                        PointInShapeIntersectVisitor.decodeValueMin(cell.zMinEnc), PointInShapeIntersectVisitor.decodeValueMax(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+PointInShapeIntersectVisitor.decodeValueMin(cell.xMinEnc)+\" maxx=\"+PointInShapeIntersectVisitor.decodeValueMax(cell.xMaxEnc)+\n              \" miny=\"+PointInShapeIntersectVisitor.decodeValueMin(cell.yMinEnc)+\" maxy=\"+PointInShapeIntersectVisitor.decodeValueMax(cell.yMaxEnc)+\n              \" minz=\"+PointInShapeIntersectVisitor.decodeValueMin(cell.zMinEnc)+\" maxz=\"+PointInShapeIntersectVisitor.decodeValueMax(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        boolean expected = shape.isWithin(point);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e853809f9b46699d2cefad0fac20220d48047b73","date":1460794030,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude())));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(point)) {\n              if (shape.isWithin(point)) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        boolean expected = shape.isWithin(point);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b961ff1d2d65eab705046ed52539112d3a5f76e0","date":1463766553,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd1db895ecdfc51fbe34b1d3e280f61587992d83","date":1465300613,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6448f67be45147de82a85cd903fec34e8930da75","date":1477041277,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bc94776f916d82610a187b5a0b025589659621b","date":1522334248,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  //@AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n  @Ignore\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  //@AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n  @Ignore\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6531d2d5e270ac1ccb114e6a380ab253e6ed1a7e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6531d2d5e270ac1ccb114e6a380ab253e6ed1a7e","date":1522413407,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":["8b879b14da40ab73551b75835099a61e622a83d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c6c784f777a2cc8fa014507ea129526822714d","date":1579733373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(200);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(200);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    PlanetModel planetModel = PlanetModel.CLARKE_1866;\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(planetModel, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID], planetModel);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX(), planetModel),\n                           encodeValueLenient(bounds.getMaximumX(), planetModel),\n                           encodeValueLenient(bounds.getMinimumY(), planetModel),\n                           encodeValueLenient(bounds.getMaximumY(), planetModel),\n                           encodeValueLenient(bounds.getMinimumZ(), planetModel),\n                           encodeValueLenient(bounds.getMaximumZ(), planetModel),\n                           planetModel,\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc, planetModel), Geo3DUtil.decodeValueCeil(cell.xMaxEnc, planetModel),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc, planetModel), Geo3DUtil.decodeValueCeil(cell.yMaxEnc, planetModel),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc, planetModel), Geo3DUtil.decodeValueCeil(cell.zMaxEnc, planetModel));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc, planetModel)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc, planetModel)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc, planetModel)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc, planetModel)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc, planetModel)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc, planetModel));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 planetModel,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 planetModel,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 planetModel,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 planetModel,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 planetModel,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 planetModel,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    int numDocs = atLeast(200);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    GeoPoint[] unquantizedDocs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      unquantizedDocs[docID] = new GeoPoint(PlanetModel.WGS84, toRadians(GeoTestUtil.nextLatitude()), toRadians(GeoTestUtil.nextLongitude()));\n      docs[docID] = quantize(unquantizedDocs[docID]);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID] + \"; unquantized: \"+unquantizedDocs[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomNumbers.randomIntBetween(random(), 5, 15);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape();\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(bounds.getMinimumX()),\n                           encodeValueLenient(bounds.getMaximumX()),\n                           encodeValueLenient(bounds.getMinimumY()),\n                           encodeValueLenient(bounds.getMaximumY()),\n                           encodeValueLenient(bounds.getMinimumZ()),\n                           encodeValueLenient(bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      // make sure the root cell (XYZBounds) does in fact contain all points that the shape contains\n      {\n        boolean fail = false;\n        for(int docID=0;docID<numDocs;docID++) {\n          if (root.contains(docs[docID]) == false) {\n            boolean expected = shape.isWithin(unquantizedDocs[docID]);\n            if (expected) {\n              log.println(\"    doc=\" + docID + \" is contained by shape but is outside the returned XYZBounds\");\n              log.println(\"      unquantized=\" + unquantizedDocs[docID]);\n              log.println(\"      quantized=\" + docs[docID]);\n              fail = true;\n            }\n          }\n        }\n\n        if (fail) {\n          log.println(\"  shape=\" + shape);\n          log.println(\"  bounds=\" + bounds);\n          System.out.print(sw.toString());\n          fail(\"invalid bounds for shape=\" + shape);\n        }\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            GeoPoint mappedPoint = unquantizedDocs[docID];\n            boolean pointWithinShape = shape.isWithin(point);\n            boolean mappedPointWithinShape = shape.isWithin(mappedPoint);\n            if (cell.contains(point)) {\n              if (mappedPointWithinShape) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!  Actual quantized point within: \"+pointWithinShape);\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match.  Quantized point within: \"+pointWithinShape);\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n                                                        Geo3DUtil.decodeValueFloor(cell.xMinEnc), Geo3DUtil.decodeValueCeil(cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.yMinEnc), Geo3DUtil.decodeValueCeil(cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueFloor(cell.zMinEnc), Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueFloor(cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueCeil(cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueFloor(cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueCeil(cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueFloor(cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueCeil(cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(docs[docID])) {\n                  log.println(\"    skip doc=\" + docID);\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomNumbers.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint mappedPoint = unquantizedDocs[docID];\n        boolean expected = shape.isWithin(mappedPoint);\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" should not have matched but did\");\n          } else {\n            log.println(\"doc=\" + docID + \" should match but did not\");\n          }\n          log.println(\"  point=\" + point);\n          log.println(\"  mappedPoint=\" + mappedPoint);\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2bc94776f916d82610a187b5a0b025589659621b":["6448f67be45147de82a85cd903fec34e8930da75"],"8b879b14da40ab73551b75835099a61e622a83d3":["2bc94776f916d82610a187b5a0b025589659621b"],"cd1db895ecdfc51fbe34b1d3e280f61587992d83":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["57c6c784f777a2cc8fa014507ea129526822714d"],"e853809f9b46699d2cefad0fac20220d48047b73":["873caa2b3b10bf0e4724a950c3a11b841ebb0e4a"],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["e853809f9b46699d2cefad0fac20220d48047b73","cd1db895ecdfc51fbe34b1d3e280f61587992d83"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e853809f9b46699d2cefad0fac20220d48047b73","b961ff1d2d65eab705046ed52539112d3a5f76e0"],"57c6c784f777a2cc8fa014507ea129526822714d":["6531d2d5e270ac1ccb114e6a380ab253e6ed1a7e"],"6531d2d5e270ac1ccb114e6a380ab253e6ed1a7e":["8b879b14da40ab73551b75835099a61e622a83d3"],"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["b4e444678504caf66a8060b1d514383aa4feac0c"],"6448f67be45147de82a85cd903fec34e8930da75":["cd1db895ecdfc51fbe34b1d3e280f61587992d83"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6448f67be45147de82a85cd903fec34e8930da75"],"873caa2b3b10bf0e4724a950c3a11b841ebb0e4a":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"b961ff1d2d65eab705046ed52539112d3a5f76e0":["e853809f9b46699d2cefad0fac20220d48047b73"]},"commit2Childs":{"2bc94776f916d82610a187b5a0b025589659621b":["8b879b14da40ab73551b75835099a61e622a83d3"],"8b879b14da40ab73551b75835099a61e622a83d3":["6531d2d5e270ac1ccb114e6a380ab253e6ed1a7e"],"cd1db895ecdfc51fbe34b1d3e280f61587992d83":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6448f67be45147de82a85cd903fec34e8930da75"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e853809f9b46699d2cefad0fac20220d48047b73":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","b961ff1d2d65eab705046ed52539112d3a5f76e0"],"b4e444678504caf66a8060b1d514383aa4feac0c":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["cd1db895ecdfc51fbe34b1d3e280f61587992d83"],"57c6c784f777a2cc8fa014507ea129526822714d":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"6531d2d5e270ac1ccb114e6a380ab253e6ed1a7e":["57c6c784f777a2cc8fa014507ea129526822714d"],"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["873caa2b3b10bf0e4724a950c3a11b841ebb0e4a"],"6448f67be45147de82a85cd903fec34e8930da75":["2bc94776f916d82610a187b5a0b025589659621b","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"873caa2b3b10bf0e4724a950c3a11b841ebb0e4a":["e853809f9b46699d2cefad0fac20220d48047b73"],"b961ff1d2d65eab705046ed52539112d3a5f76e0":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}