{"path":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","commits":[{"id":"ddc1ae5ff40afa2c5136ee382632ebe602e050e6","date":1474097671,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["63a1a94d02abb8cde5dd6ea0defbbc751ce71603"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63a1a94d02abb8cde5dd6ea0defbbc751ce71603","date":1521902895,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":["ddc1ae5ff40afa2c5136ee382632ebe602e050e6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fa95fb629298e03fe5e3d71a0ce792f1256f711","date":1521903809,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20c968c14aace7cf49843bf2c1fafc7fd3845659","date":1533133859,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = it.handler.coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a05f3f5161c62339ec5560b8f6958f3df8483618","date":1563550501,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ( params.getBool(GET_RANGES, false) ) {\n      handleGetRanges(it, cname);\n      return;\n    }\n\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ( params.getBool(GET_RANGES, false) ) {\n      handleGetRanges(it, cname);\n      return;\n    }\n\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: {}\", cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ( params.getBool(GET_RANGES, false) ) {\n      handleGetRanges(it, cname);\n      return;\n    }\n\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#execute(CoreAdminHandler.CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ( params.getBool(GET_RANGES, false) ) {\n      handleGetRanges(it, cname);\n      return;\n    }\n\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: {}\", cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          @SuppressWarnings({\"rawtypes\"})\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute(CoreAdminHandler.CallInfo it) throws Exception {\n    SolrParams params = it.req.getParams();\n\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ( params.getBool(GET_RANGES, false) ) {\n      handleGetRanges(it, cname);\n      return;\n    }\n\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null) {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: {}\", cname);\n    String methodStr = params.get(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    SolrIndexSplitter.SplitMethod splitMethod = SolrIndexSplitter.SplitMethod.get(methodStr);\n    if (splitMethod == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unsupported value of '\" + CommonAdminParams.SPLIT_METHOD + \"': \" + methodStr);\n    }\n    SolrCore parentCore = it.handler.coreContainer.getCore(cname);\n    List<SolrCore> newCores = null;\n    SolrQueryRequest req = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = it.handler.coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n            if (it.handler.coreContainer.isZooKeeperAware()) {\n              // this core must be the only replica in its shard otherwise\n              // we cannot guarantee consistency between replicas because when we add data to this replica\n              CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n              ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n              if (clusterState.getCollection(cd.getCollectionName()).getSlice(cd.getShardId()).getReplicas().size() != 1) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"Core with core name \" + newCoreName + \" must be the only replica in shard \" + cd.getShardId());\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n      req = new LocalSolrQueryRequest(parentCore, params);\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, it.rsp, paths, newCores, ranges, router, routeFieldName, splitKey, splitMethod);\n      parentCore.getUpdateHandler().split(cmd);\n\n      if (it.handler.coreContainer.isZooKeeperAware()) {\n        for (SolrCore newcore : newCores) {\n          // the index of the core changed from empty to have some data, its term must be not zero\n          CloudDescriptor cd = newcore.getCoreDescriptor().getCloudDescriptor();\n          ZkShardTerms zkShardTerms = it.handler.coreContainer.getZkController().getShardTerms(cd.getCollectionName(), cd.getShardId());\n          zkShardTerms.ensureHighestTermsAreNotZero();\n        }\n      }\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw e;\n    } finally {\n      if (req != null) req.close();\n      if (parentCore != null) parentCore.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ddc1ae5ff40afa2c5136ee382632ebe602e050e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba055e19afc289adcb5bedaf68513793a7254012":["575e66bd4b2349209027f6801184da7fc3cba13f"],"3fa95fb629298e03fe5e3d71a0ce792f1256f711":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","63a1a94d02abb8cde5dd6ea0defbbc751ce71603"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ddc1ae5ff40afa2c5136ee382632ebe602e050e6"],"575e66bd4b2349209027f6801184da7fc3cba13f":["a05f3f5161c62339ec5560b8f6958f3df8483618"],"a05f3f5161c62339ec5560b8f6958f3df8483618":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"20c968c14aace7cf49843bf2c1fafc7fd3845659":["3fa95fb629298e03fe5e3d71a0ce792f1256f711"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba055e19afc289adcb5bedaf68513793a7254012"],"63a1a94d02abb8cde5dd6ea0defbbc751ce71603":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"]},"commit2Childs":{"ddc1ae5ff40afa2c5136ee382632ebe602e050e6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ba055e19afc289adcb5bedaf68513793a7254012":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3fa95fb629298e03fe5e3d71a0ce792f1256f711":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ddc1ae5ff40afa2c5136ee382632ebe602e050e6","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"575e66bd4b2349209027f6801184da7fc3cba13f":["ba055e19afc289adcb5bedaf68513793a7254012"],"a05f3f5161c62339ec5560b8f6958f3df8483618":["575e66bd4b2349209027f6801184da7fc3cba13f"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["3fa95fb629298e03fe5e3d71a0ce792f1256f711","63a1a94d02abb8cde5dd6ea0defbbc751ce71603"],"20c968c14aace7cf49843bf2c1fafc7fd3845659":["a05f3f5161c62339ec5560b8f6958f3df8483618"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"63a1a94d02abb8cde5dd6ea0defbbc751ce71603":["3fa95fb629298e03fe5e3d71a0ce792f1256f711"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}