{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            Runner r = new Runner();\n            runners.add(r);\n            scheduler.execute(r);\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            Runner r = new Runner();\n            runners.add(r);\n            scheduler.execute(r);\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","date":1429031018,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            MDC.put(\"ConcurrentUpdateSolrClient.url\", client.getBaseURL());\n            try {\n              Runner r = new Runner();\n              runners.add(r);\n              scheduler.execute(r);\n            } finally {\n              MDC.remove(\"ConcurrentUpdateSolrClient.url\");\n            }\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            Runner r = new Runner();\n            runners.add(r);\n            scheduler.execute(r);\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50e202028300f452744bbd0e537a0f5c0cf044b6","date":1446478140,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list.  This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait(250);\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isShutdown())\n            break;\n                      \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            MDC.put(\"ConcurrentUpdateSolrClient.url\", client.getBaseURL());\n            try {\n              Runner r = new Runner();\n              runners.add(r);\n              scheduler.execute(r);\n            } finally {\n              MDC.remove(\"ConcurrentUpdateSolrClient.url\");\n            }\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":["945902ae43d8dd7e920418efe36981403c2ee669","6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7ca1cace44c816965501b934686a2354382f000","date":1487792658,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list.  This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait(250);\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isShutdown())\n            break;\n                      \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          // stall prevention\n          if (lastQueueSize != queueSize) {\n            // init, or no stall\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n//                Thread.currentThread().interrupt();\n//                break;\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          // stall prevention\n          if (lastQueueSize != queueSize) {\n            // init, or no stall\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n//                Thread.currentThread().interrupt();\n//                break;\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          // stall prevention\n          if (lastQueueSize != queueSize) {\n            // init, or no stall\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n//                Thread.currentThread().interrupt();\n//                break;\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has {} adding more runners to process remaining requests on queue\"\n                , queueSize);\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        // NOTE: if the executor is shut down, runners may never become empty (a scheduled task may never be run,\n        // which means it would never remove itself from the runners list. This is why we don't wait forever\n        // and periodically check if the scheduler is shutting down.\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          // Need to check if the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          // stall prevention\n          if (lastQueueSize != queueSize) {\n            // init, or no stall\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n//                Thread.currentThread().interrupt();\n//                break;\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            // TODO: can this still happen?\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          // try to avoid the worst case wait timeout\n          // without bad spin\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["c7ca1cace44c816965501b934686a2354382f000"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["bafca15d8e408346a67f4282ad1143b88023893b"],"a229cb50768e988c50a2106bdae3a92154f428bf":["c7ca1cace44c816965501b934686a2354382f000","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"50e202028300f452744bbd0e537a0f5c0cf044b6":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c7ca1cace44c816965501b934686a2354382f000":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"]},"commit2Childs":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["6dc613ed6f75d1988140301ee8de8fdb056fa337","a229cb50768e988c50a2106bdae3a92154f428bf"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"50e202028300f452744bbd0e537a0f5c0cf044b6":["c7ca1cace44c816965501b934686a2354382f000"],"c7ca1cace44c816965501b934686a2354382f000":["482ca6c86d7073e3c19096bdc74fe0e73da4554a","a229cb50768e988c50a2106bdae3a92154f428bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}