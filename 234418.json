{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"/dev/null","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"/dev/null","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2344a1c769566d8c85cffcacc5e55153fa54b86","date":1550661298,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    scratchBytesRef1.bytes = packedValue;\n    scratchBytesRef1.offset = 0;\n    scratchBytesRef1.length = packedBytesLength;\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76a51551f05a6c96a115b5a656837ecc8fd0b1ff","date":1551422476,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      assert pointWriter == null : \"Point writer is already initialized\";\n      //total point count is an estimation but the final point count must be equal or lower to that number.\n      if (totalPointCount > maxPointsSortInHeap) {\n        pointWriter = new OfflinePointWriter(tempDir, tempFileNamePrefix, packedBytesLength, \"spill\", 0);\n        tempInput = ((OfflinePointWriter)pointWriter).out;\n      } else {\n        pointWriter = new HeapPointWriter(Math.toIntExact(totalPointCount), packedBytesLength);\n      }\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    scratchBytesRef1.bytes = packedValue;\n    scratchBytesRef1.offset = 0;\n    scratchBytesRef1.length = packedBytesLength;\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      assert pointWriter == null : \"Point writer is already initialized\";\n      //total point count is an estimation but the final point count must be equal or lower to that number.\n      if (totalPointCount > maxPointsSortInHeap) {\n        pointWriter = new OfflinePointWriter(tempDir, tempFileNamePrefix, packedBytesLength, \"spill\", 0);\n        tempInput = ((OfflinePointWriter)pointWriter).out;\n      } else {\n        pointWriter = new HeapPointWriter(Math.toIntExact(totalPointCount), packedBytesLength);\n      }\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      assert pointWriter == null : \"Point writer is already initialized\";\n      //total point count is an estimation but the final point count must be equal or lower to that number.\n      if (totalPointCount > maxPointsSortInHeap) {\n        pointWriter = new OfflinePointWriter(tempDir, tempFileNamePrefix, packedBytesLength, \"spill\", 0);\n        tempInput = ((OfflinePointWriter)pointWriter).out;\n      } else {\n        pointWriter = new HeapPointWriter(Math.toIntExact(totalPointCount), packedBytesLength);\n      }\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != config.packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + config.packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      assert pointWriter == null : \"Point writer is already initialized\";\n      //total point count is an estimation but the final point count must be equal or lower to that number.\n      if (totalPointCount > maxPointsSortInHeap) {\n        pointWriter = new OfflinePointWriter(config, tempDir, tempFileNamePrefix, \"spill\", 0);\n        tempInput = ((OfflinePointWriter)pointWriter).out;\n      } else {\n        pointWriter = new HeapPointWriter(config, Math.toIntExact(totalPointCount));\n      }\n      System.arraycopy(packedValue, 0, minPackedValue, 0, config.packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, config.packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<config.numIndexDims;dim++) {\n        int offset = dim*config.bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + config.bytesPerDim, minPackedValue, offset, offset + config.bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, config.bytesPerDim);\n        }\n        if (Arrays.compareUnsigned(packedValue, offset, offset + config.bytesPerDim, maxPackedValue, offset, offset + config.bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, config.bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      assert pointWriter == null : \"Point writer is already initialized\";\n      //total point count is an estimation but the final point count must be equal or lower to that number.\n      if (totalPointCount > maxPointsSortInHeap) {\n        pointWriter = new OfflinePointWriter(tempDir, tempFileNamePrefix, packedBytesLength, \"spill\", 0);\n        tempInput = ((OfflinePointWriter)pointWriter).out;\n      } else {\n        pointWriter = new HeapPointWriter(Math.toIntExact(totalPointCount), packedBytesLength);\n      }\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["41f60ea1802fda42d3c91d023406066d00ddb5f8","9856095f7afb5a607bf5e65077615ed91273508c"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}