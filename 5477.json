{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,NumericType,Query,IndexSearcher,ScoreMode).mjava","commits":[{"id":"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","date":1449514606,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,NumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntField} or {@link LongField}\n   * @param numericType               either {@link NumericType#INT} or {@link NumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  \n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, NumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,NumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  \n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntField} or {@link LongField}\n   * @param numericType               either {@link NumericType#INT} or {@link NumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  \n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, NumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"770342641f7b505eaa8dccdc666158bff2419109":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["770342641f7b505eaa8dccdc666158bff2419109"]},"commit2Childs":{"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"770342641f7b505eaa8dccdc666158bff2419109":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}