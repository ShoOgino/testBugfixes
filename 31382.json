{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","commits":[{"id":"6e771d3bb64bb6db325ca1c015b256d08ad74424","date":1338972370,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    refreshInternalReader();\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    alreadyCalledFillCache = false;\n    \n    // update createTime as a taxonomy replace is just like it has be recreated\n    createTime = Long.toString(System.nanoTime());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b7a1bc6030c258e47d63eff3455a2b1bbf32683","date":1339494023,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update createTime as a taxonomy replace is just like it has be recreated\n    createTime = Long.toString(System.nanoTime());\n  }\n\n","sourceOld":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    refreshInternalReader();\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    alreadyCalledFillCache = false;\n    \n    // update createTime as a taxonomy replace is just like it has be recreated\n    createTime = Long.toString(System.nanoTime());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78e3613d9274c0d98ca67d976e415c82e9f9cf46","date":1352285414,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","sourceOld":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update createTime as a taxonomy replace is just like it has be recreated\n    createTime = Long.toString(System.nanoTime());\n  }\n\n","bugFix":["6e771d3bb64bb6db325ca1c015b256d08ad74424"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e718e9c24ea4b55bce0b93f10b8560bec6e2f9","date":1355652631,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager(); // ensure that it's initialized\n    refreshReaderManager();\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","sourceOld":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager(); // ensure that it's initialized\n    refreshReaderManager();\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","sourceOld":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ac613dcda1585b43f4c357e90f3b65bec470383","date":1380032447,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager(); // ensure that it's initialized\n    refreshReaderManager();\n    nextID = indexWriter.maxDoc();\n    taxoArrays = null; // must nullify so that it's re-computed next time it's needed\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    cacheMisses.set(0);\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","sourceOld":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager(); // ensure that it's initialized\n    refreshReaderManager();\n    nextID = indexWriter.maxDoc();\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feb4029567b43f074ed7b6eb8fb126d355075dfd","date":1544812585,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#replaceTaxonomy(Directory).mjava","sourceNew":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager(); // ensure that it's initialized\n    refreshReaderManager();\n    nextID = indexWriter.getDocStats().maxDoc;\n    taxoArrays = null; // must nullify so that it's re-computed next time it's needed\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    cacheMisses.set(0);\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","sourceOld":"  /**\n   * Replaces the current taxonomy with the given one. This method should\n   * generally be called in conjunction with\n   * {@link IndexWriter#addIndexes(Directory...)} to replace both the taxonomy\n   * as well as the search index content.\n   */\n  public synchronized void replaceTaxonomy(Directory taxoDir) throws IOException {\n    // replace the taxonomy by doing IW optimized operations\n    indexWriter.deleteAll();\n    indexWriter.addIndexes(taxoDir);\n    shouldRefreshReaderManager = true;\n    initReaderManager(); // ensure that it's initialized\n    refreshReaderManager();\n    nextID = indexWriter.maxDoc();\n    taxoArrays = null; // must nullify so that it's re-computed next time it's needed\n    \n    // need to clear the cache, so that addCategory won't accidentally return\n    // old categories that are in the cache.\n    cache.clear();\n    cacheIsComplete = false;\n    shouldFillCache = true;\n    cacheMisses.set(0);\n    \n    // update indexEpoch as a taxonomy replace is just like it has be recreated\n    ++indexEpoch;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["78e3613d9274c0d98ca67d976e415c82e9f9cf46","78e718e9c24ea4b55bce0b93f10b8560bec6e2f9"],"9ac613dcda1585b43f4c357e90f3b65bec470383":["78e718e9c24ea4b55bce0b93f10b8560bec6e2f9"],"78e718e9c24ea4b55bce0b93f10b8560bec6e2f9":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["9ac613dcda1585b43f4c357e90f3b65bec470383"],"78e3613d9274c0d98ca67d976e415c82e9f9cf46":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6e771d3bb64bb6db325ca1c015b256d08ad74424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["6e771d3bb64bb6db325ca1c015b256d08ad74424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["feb4029567b43f074ed7b6eb8fb126d355075dfd"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"9ac613dcda1585b43f4c357e90f3b65bec470383":["feb4029567b43f074ed7b6eb8fb126d355075dfd"],"78e718e9c24ea4b55bce0b93f10b8560bec6e2f9":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9ac613dcda1585b43f4c357e90f3b65bec470383"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"78e3613d9274c0d98ca67d976e415c82e9f9cf46":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","78e718e9c24ea4b55bce0b93f10b8560bec6e2f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e771d3bb64bb6db325ca1c015b256d08ad74424"],"6e771d3bb64bb6db325ca1c015b256d08ad74424":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}