{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","commits":[{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory,Codec).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(pendingSegnOutput);\n        rollbackCommit(dir);\n      } else {\n        pendingSegnOutput.close();\n        pendingSegnOutput = null;\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir, Codec codec) throws IOException {\n    if (pendingSegnOutput == null)\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    boolean success = false;\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      infosWriter.finishCommit(pendingSegnOutput);\n      pendingSegnOutput = null;\n      success = true;\n    } finally {\n      if (!success)\n        rollbackCommit(dir);\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory,Codec).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(pendingSegnOutput);\n        rollbackCommit(dir);\n      } else {\n        pendingSegnOutput.close();\n        pendingSegnOutput = null;\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir, Codec codec) throws IOException {\n    if (pendingSegnOutput == null)\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    boolean success = false;\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      infosWriter.finishCommit(pendingSegnOutput);\n      pendingSegnOutput = null;\n      success = true;\n    } finally {\n      if (!success)\n        rollbackCommit(dir);\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f24f21e70a092329fc6f920115592dc9529d379","date":1349391034,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(pendingSegnOutput);\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            final String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                                 \"\",\n                                                                                 generation);\n            IOUtils.deleteFilesIgnoringExceptions(dir, segmentFileName);\n          }\n          pendingSegnOutput = null;\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(pendingSegnOutput);\n        rollbackCommit(dir);\n      } else {\n        pendingSegnOutput.close();\n        pendingSegnOutput = null;\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"780772d46216077ee38b6495eaa4329b930b16fe","date":1349649545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(pendingSegnOutput);\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            final String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                                 \"\",\n                                                                                 generation);\n            IOUtils.deleteFilesIgnoringExceptions(dir, segmentFileName);\n          }\n          pendingSegnOutput = null;\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"100c140f7402689d2580dd352005c97641fb9ee2","date":1356671627,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n    }\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n    }\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n      if (t instanceof ThreadInterruptedException) {\n        throw (ThreadInterruptedException) t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n\n    try {\n      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n      try {\n        genOutput.writeInt(FORMAT_SEGMENTS_GEN_CURRENT);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n        dir.sync(Collections.singleton(IndexFileNames.SEGMENTS_GEN));\n      }\n    } catch (Throwable t) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n      try {\n        dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      } catch (Throwable t2) {\n        // Ignore; this file is only used in a retry\n        // fallback on init.\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f3b037cd083286b2af89f96e768f85dcd8072d6","date":1396337805,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      CodecUtil.writeFooter(pendingSegnOutput);\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      CodecUtil.writeFooter(pendingSegnOutput);\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      pendingSegnOutput.finishCommit();\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      CodecUtil.writeFooter(pendingSegnOutput);\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      CodecUtil.writeFooter(pendingSegnOutput);\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        try {\n          dir.deleteFile(fileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      final String src =  IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      final String dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,         \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingSegnOutput == null) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      CodecUtil.writeFooter(pendingSegnOutput);\n      success = true;\n    } finally {\n      if (!success) {\n        // Closes pendingSegnOutput & deletes partial segments_N:\n        rollbackCommit(dir);\n      } else {\n        success = false;\n        try {\n          pendingSegnOutput.close();\n          success = true;\n        } finally {\n          if (!success) {\n            // Closes pendingSegnOutput & deletes partial segments_N:\n            rollbackCommit(dir);\n          } else {\n            pendingSegnOutput = null;\n          }\n        }\n      }\n    }\n\n    // NOTE: if we crash here, we have left a segments_N\n    // file in the directory in a possibly corrupt state (if\n    // some bytes made it to stable storage and others\n    // didn't).  But, the segments_N file includes checksum\n    // at the end, which should catch this case.  So when a\n    // reader tries to read it, it will throw a\n    // CorruptIndexException, which should cause the retry\n    // logic in SegmentInfos to kick in and load the last\n    // good (previous) segments_N-1 file.\n\n    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n    success = false;\n    try {\n      dir.sync(Collections.singleton(fileName));\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n      }\n    }\n\n    lastGeneration = generation;\n    writeSegmentsGen(dir, generation);\n  }\n\n","bugFix":null,"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25e07bf0d9fa18cd8f0185e309d09a873c45017c","date":1411478085,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src =  IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","sourceOld":"  final void finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    try {\n      final String src =  IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      final String dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,         \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n  }\n\n","bugFix":["46e4a8bdfbafda795ef9c39a2bc2d47095770299","4356000e349e38c9fb48034695b7c309abd54557"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","sourceOld":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src =  IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","sourceOld":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src =  IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"214256b5eeeaba88b8293b37d30460b462b19562","date":1468250146,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.rename(src, dest);\n      dir.syncMetaData();\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","sourceOld":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","bugFix":null,"bugIntro":["d0c334a824d4ce7d739c100bf4ae56111a995e3a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.rename(src, dest);\n      dir.syncMetaData();\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","sourceOld":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.renameFile(src, dest);\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0c334a824d4ce7d739c100bf4ae56111a995e3a","date":1598293184,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#finishCommit(Directory).mjava","sourceNew":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean successRenameAndSync = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.rename(src, dest);\n      try {\n        dir.syncMetaData();\n        successRenameAndSync = true;\n      } finally {\n        if (successRenameAndSync == false) {\n          // at this point we already created the file but missed to sync directory let's also remove the\n          // renamed file\n          IOUtils.deleteFilesIgnoringExceptions(dir, dest);\n        }\n      }\n    } finally {\n      if (successRenameAndSync == false) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","sourceOld":"  /** Returns the committed segments_N filename. */\n  final String finishCommit(Directory dir) throws IOException {\n    if (pendingCommit == false) {\n      throw new IllegalStateException(\"prepareCommit was not called\");\n    }\n    boolean success = false;\n    final String dest;\n    try {\n      final String src = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS, \"\", generation);\n      dest = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", generation);\n      dir.rename(src, dest);\n      dir.syncMetaData();\n      success = true;\n    } finally {\n      if (!success) {\n        // deletes pending_segments_N:\n        rollbackCommit(dir);\n      }\n    }\n\n    pendingCommit = false;\n    lastGeneration = generation;\n    return dest;\n  }\n\n","bugFix":["214256b5eeeaba88b8293b37d30460b462b19562","7b91922b55d15444d554721b352861d028eb8278","4356000e349e38c9fb48034695b7c309abd54557"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["780772d46216077ee38b6495eaa4329b930b16fe","100c140f7402689d2580dd352005c97641fb9ee2"],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"214256b5eeeaba88b8293b37d30460b462b19562":["68496c2200e559fb7802f7575427b7a482659afb"],"100c140f7402689d2580dd352005c97641fb9ee2":["780772d46216077ee38b6495eaa4329b930b16fe"],"780772d46216077ee38b6495eaa4329b930b16fe":["5f24f21e70a092329fc6f920115592dc9529d379"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["1f3b037cd083286b2af89f96e768f85dcd8072d6"],"d0c334a824d4ce7d739c100bf4ae56111a995e3a":["214256b5eeeaba88b8293b37d30460b462b19562"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","214256b5eeeaba88b8293b37d30460b462b19562"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["100c140f7402689d2580dd352005c97641fb9ee2"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4356000e349e38c9fb48034695b7c309abd54557"],"4356000e349e38c9fb48034695b7c309abd54557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25e07bf0d9fa18cd8f0185e309d09a873c45017c":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"68496c2200e559fb7802f7575427b7a482659afb":["25e07bf0d9fa18cd8f0185e309d09a873c45017c","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"5f24f21e70a092329fc6f920115592dc9529d379":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0c334a824d4ce7d739c100bf4ae56111a995e3a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["5eb2511ababf862ea11e10761c70ee560cd84510","98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"214256b5eeeaba88b8293b37d30460b462b19562":["d0c334a824d4ce7d739c100bf4ae56111a995e3a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"100c140f7402689d2580dd352005c97641fb9ee2":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"780772d46216077ee38b6495eaa4329b930b16fe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","100c140f7402689d2580dd352005c97641fb9ee2"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"d0c334a824d4ce7d739c100bf4ae56111a995e3a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["5eb2511ababf862ea11e10761c70ee560cd84510","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["5f24f21e70a092329fc6f920115592dc9529d379"],"4356000e349e38c9fb48034695b7c309abd54557":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4356000e349e38c9fb48034695b7c309abd54557"],"25e07bf0d9fa18cd8f0185e309d09a873c45017c":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["214256b5eeeaba88b8293b37d30460b462b19562","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"5f24f21e70a092329fc6f920115592dc9529d379":["780772d46216077ee38b6495eaa4329b930b16fe"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}