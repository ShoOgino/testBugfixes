{"path":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","commits":[{"id":"bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89","date":1400688006,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.shutdown();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, AtomicReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.shutdown();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, AtomicReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.shutdown();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, AtomicReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, AtomicReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.shutdown();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, AtomicReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, AtomicReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e08fa910967c3b157a2b59ec75dfac40515af29","date":1435191580,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        // we use a rather bogus/complex coord, because today coord() can really return anything.\n        // note in the case of overlap == maxOverlap == 1: BooleanWeight always applies 1, (see LUCENE-4300).\n        return overlap / (float)(maxOverlap + 1);\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        return overlap / (float)maxOverlap;\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        // we use a rather bogus/complex coord, because today coord() can really return anything.\n        // note in the case of overlap == maxOverlap == 1: BooleanWeight always applies 1, (see LUCENE-4300).\n        return overlap / (float)(maxOverlap + 1);\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        // we use a rather bogus/complex coord, because today coord() can really return anything.\n        // note in the case of overlap == maxOverlap == 1: BooleanWeight always applies 1, (see LUCENE-4300).\n        return overlap / (float)(maxOverlap + 1);\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","sourceNew":null,"sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        // we use a rather bogus/complex coord, because today coord() can really return anything.\n        // note in the case of overlap == maxOverlap == 1: BooleanWeight always applies 1, (see LUCENE-4300).\n        return overlap / (float)(maxOverlap + 1);\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord#beforeClass().mjava","sourceNew":null,"sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    dir = newDirectory();\n    IndexWriter iw = new IndexWriter(dir, new IndexWriterConfig(null));\n    \n    // we only add two documents for testing:\n    // the first document has 3 terms A,B,C (for positive matching). we test scores against this.\n    // the second document has 3 negative terms 1,2,3 that exist in the segment (for non-null scorers)\n    // to test terms that don't exist (null scorers), we use X,Y,Z\n    \n    Document doc = new Document();\n    doc.add(new StringField(\"field\", \"A\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"B\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"C\", Field.Store.NO));\n    iw.addDocument(doc);\n    \n    doc = new Document();\n    doc.add(new StringField(\"field\", \"1\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"2\", Field.Store.NO));\n    doc.add(new StringField(\"field\", \"3\", Field.Store.NO));\n    iw.addDocument(doc);\n\n    iw.close();\n    reader = DirectoryReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    // we set a similarity that just returns 1, the idea is to test coord\n    searcher.setSimilarity(new Similarity() {\n      @Override\n      public float coord(int overlap, int maxOverlap) {\n        // we use a rather bogus/complex coord, because today coord() can really return anything.\n        // note in the case of overlap == maxOverlap == 1: BooleanWeight always applies 1, (see LUCENE-4300).\n        return overlap / (float)(maxOverlap + 1);\n      }\n\n      @Override\n      public long computeNorm(FieldInvertState state) {\n        throw new AssertionError();\n      }\n\n      @Override\n      public SimWeight computeWeight(CollectionStatistics collectionStats, TermStatistics... termStats) {\n        return new SimWeight() {\n          @Override\n          public float getValueForNormalization() {\n            return 1f;\n          }\n\n          @Override\n          public void normalize(float queryNorm, float topLevelBoost) {}\n        };\n      }\n\n      @Override\n      public SimScorer simScorer(SimWeight weight, LeafReaderContext context) throws IOException {\n        return new SimScorer() {\n          @Override\n          public float score(int doc, float freq) {\n            return 1;\n          }\n\n          @Override\n          public float computeSlopFactor(int distance) {\n            throw new AssertionError();\n          }\n\n          @Override\n          public float computePayloadFactor(int doc, int start, int end, BytesRef payload) {\n            throw new AssertionError();\n          }\n        };\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2e08fa910967c3b157a2b59ec75dfac40515af29":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["2e08fa910967c3b157a2b59ec75dfac40515af29"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89"],"c8a0e442f7b61f811680273b25da95994a724466":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["2dfdf766e55e943d942055d7de53c7ad6bc45283","c8a0e442f7b61f811680273b25da95994a724466"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c8a0e442f7b61f811680273b25da95994a724466"],"bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"2e08fa910967c3b157a2b59ec75dfac40515af29":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a656b32c3aa151037a8c52e9b134acc3cbf482bc","b7605579001505896d48b07160075a5c8b8e128e","bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["c8a0e442f7b61f811680273b25da95994a724466","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"c8a0e442f7b61f811680273b25da95994a724466":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7605579001505896d48b07160075a5c8b8e128e":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["2e08fa910967c3b157a2b59ec75dfac40515af29"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"bea7ece5e5fd173fc80d6cbdad8a4a03ee9a8d89":["d0ef034a4f10871667ae75181537775ddcf8ade4","a656b32c3aa151037a8c52e9b134acc3cbf482bc","b7605579001505896d48b07160075a5c8b8e128e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a656b32c3aa151037a8c52e9b134acc3cbf482bc","b7605579001505896d48b07160075a5c8b8e128e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}