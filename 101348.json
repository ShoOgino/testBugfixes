{"path":"lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery#testAutoPrefixTermsKickIn().mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery#testAutoPrefixTermsKickIn().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure auto prefix terms are used with PrefixQuery. */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomRealisticUnicodeString(random()));\n      }\n    }\n\n    int actualCount = 0;\n    for(String term : randomTerms) {\n      if (term.startsWith(\"aa\")) {\n        actualCount++;\n      }\n    }\n\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    // As long as this is never > actualCount, aa should always see at least one auto-prefix term:\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, actualCount);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    PrefixQuery q = new PrefixQuery(new Term(\"field\", \"aa\")) {\n      public PrefixQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int x = BooleanQuery.getMaxClauseCount();\n    try {\n      BooleanQuery.setMaxClauseCount(randomTerms.size());\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n      }\n\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(x);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery#testAutoPrefixTermsKickIn().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure auto prefix terms are used with PrefixQuery. */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomRealisticUnicodeString(random()));\n      }\n    }\n\n    int actualCount = 0;\n    for(String term : randomTerms) {\n      if (term.startsWith(\"aa\")) {\n        actualCount++;\n      }\n    }\n\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    // As long as this is never > actualCount, aa should always see at least one auto-prefix term:\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, actualCount);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    PrefixQuery q = new PrefixQuery(new Term(\"field\", \"aa\")) {\n      public PrefixQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int x = BooleanQuery.getMaxClauseCount();\n    try {\n      BooleanQuery.setMaxClauseCount(randomTerms.size());\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n      }\n\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(x);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17a677e88529303e630fb314d1506ea0cdb40f00","date":1432211402,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testPrefixQuery().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery#testAutoPrefixTermsKickIn().mjava","sourceNew":"  /** Make sure auto prefix terms are used with PrefixQuery. */\n  public void testPrefixQuery() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomRealisticUnicodeString(random()));\n      }\n    }\n\n    int actualCount = 0;\n    for(String term : randomTerms) {\n      if (term.startsWith(\"aa\")) {\n        actualCount++;\n      }\n    }\n\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    // As long as this is never > actualCount, aa should always see at least one auto-prefix term:\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, actualCount);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    PrefixQuery q = new PrefixQuery(new Term(\"field\", \"aa\")) {\n      public PrefixQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int x = BooleanQuery.getMaxClauseCount();\n    try {\n      // TODO test with boolean rewrite as well once we can create term\n      // queries on fake terms\n      /*BooleanQuery.setMaxClauseCount(randomTerms.size());\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n      }*/\n\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(x);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure auto prefix terms are used with PrefixQuery. */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomRealisticUnicodeString(random()));\n      }\n    }\n\n    int actualCount = 0;\n    for(String term : randomTerms) {\n      if (term.startsWith(\"aa\")) {\n        actualCount++;\n      }\n    }\n\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    // As long as this is never > actualCount, aa should always see at least one auto-prefix term:\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, actualCount);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    PrefixQuery q = new PrefixQuery(new Term(\"field\", \"aa\")) {\n      public PrefixQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int x = BooleanQuery.getMaxClauseCount();\n    try {\n      BooleanQuery.setMaxClauseCount(randomTerms.size());\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n      }\n\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(x);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"17a677e88529303e630fb314d1506ea0cdb40f00":["3e8715d826e588419327562287d5d6a8040d63d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17a677e88529303e630fb314d1506ea0cdb40f00"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","17a677e88529303e630fb314d1506ea0cdb40f00"],"17a677e88529303e630fb314d1506ea0cdb40f00":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}