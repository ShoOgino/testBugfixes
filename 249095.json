{"path":"lucene/core/src/test/org/apache/lucene/index/TestBufferedUpdates#testRamBytesUsed().mjava","commits":[{"id":"f10eec8bf984dab2325e55aa277645e80bf195f4","date":1586514647,"type":0,"author":"YuBinglei","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBufferedUpdates#testRamBytesUsed().mjava","pathOld":"/dev/null","sourceNew":"  public void testRamBytesUsed() {\n    BufferedUpdates bu = new BufferedUpdates(\"seg1\");\n    assertEquals(bu.ramBytesUsed(), 0L);\n    assertFalse(bu.any());\n    IntStream.range(0, random().nextInt(atLeast(200))).forEach(id -> {\n      int reminder = random().nextInt(3);\n      if (reminder == 0) {\n        bu.addDocID(id);\n      } else if (reminder == 1) {\n        bu.addQuery(new TermQuery(mayDuplicate(id)), id);\n      } else if (reminder == 2) {\n        bu.addTerm((mayDuplicate(id)), id);\n      }\n    });\n    assertTrue(\"we have added tons of docIds, terms and queries\", bu.any());\n\n    long totalUsed = bu.ramBytesUsed();\n    assertTrue(totalUsed > 0);\n\n    bu.clearDeletedDocIds();\n    assertTrue(\"only docIds are cleaned, buffer shouldn't be empty\", bu.any());\n    assertTrue(\"docIds are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n    totalUsed = bu.ramBytesUsed();\n\n    bu.clearDeleteTerms();\n    assertTrue(\"only terms and docIds are cleaned, the queries are still in memory\", bu.any());\n    assertTrue(\"terms are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n\n    bu.clear();\n    assertFalse(bu.any());\n    assertEquals(bu.ramBytesUsed(), 0L);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8eb8848aaae6ef71d3f65e721d9148b9906b5e8b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8eb8848aaae6ef71d3f65e721d9148b9906b5e8b","date":1586546890,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBufferedUpdates#testRamBytesUsed().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBufferedUpdates#testRamBytesUsed().mjava","sourceNew":"  public void testRamBytesUsed() {\n    BufferedUpdates bu = new BufferedUpdates(\"seg1\");\n    assertEquals(bu.ramBytesUsed(), 0L);\n    assertFalse(bu.any());\n    int docIds = atLeast(1);\n    for (int i = 0; i < docIds; i++) {\n      bu.addDocID(random().nextInt(100));\n    }\n\n    int queries = atLeast(1);\n    for (int i = 0; i < queries; i++) {\n      final int docIDUpto = random().nextBoolean() ? Integer.MAX_VALUE : random().nextInt();\n      final Term term = new Term(\"id\", Integer.toString(random().nextInt(100)));\n      bu.addQuery(new TermQuery(term), docIDUpto);\n    }\n\n    int terms = atLeast(1);\n    for (int i = 0; i < terms; i++) {\n      final int docIDUpto = random().nextBoolean() ? Integer.MAX_VALUE : random().nextInt();\n      final Term term = new Term(\"id\", Integer.toString(random().nextInt(100)));\n      bu.addTerm(term, docIDUpto);\n    }\n    assertTrue(\"we have added tons of docIds, terms and queries\", bu.any());\n\n    long totalUsed = bu.ramBytesUsed();\n    assertTrue(totalUsed > 0);\n\n    bu.clearDeletedDocIds();\n    assertTrue(\"only docIds are cleaned, buffer shouldn't be empty\", bu.any());\n    assertTrue(\"docIds are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n    totalUsed = bu.ramBytesUsed();\n\n    bu.clearDeleteTerms();\n    assertTrue(\"only terms and docIds are cleaned, the queries are still in memory\", bu.any());\n    assertTrue(\"terms are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n\n    bu.clear();\n    assertFalse(bu.any());\n    assertEquals(bu.ramBytesUsed(), 0L);\n  }\n\n","sourceOld":"  public void testRamBytesUsed() {\n    BufferedUpdates bu = new BufferedUpdates(\"seg1\");\n    assertEquals(bu.ramBytesUsed(), 0L);\n    assertFalse(bu.any());\n    IntStream.range(0, random().nextInt(atLeast(200))).forEach(id -> {\n      int reminder = random().nextInt(3);\n      if (reminder == 0) {\n        bu.addDocID(id);\n      } else if (reminder == 1) {\n        bu.addQuery(new TermQuery(mayDuplicate(id)), id);\n      } else if (reminder == 2) {\n        bu.addTerm((mayDuplicate(id)), id);\n      }\n    });\n    assertTrue(\"we have added tons of docIds, terms and queries\", bu.any());\n\n    long totalUsed = bu.ramBytesUsed();\n    assertTrue(totalUsed > 0);\n\n    bu.clearDeletedDocIds();\n    assertTrue(\"only docIds are cleaned, buffer shouldn't be empty\", bu.any());\n    assertTrue(\"docIds are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n    totalUsed = bu.ramBytesUsed();\n\n    bu.clearDeleteTerms();\n    assertTrue(\"only terms and docIds are cleaned, the queries are still in memory\", bu.any());\n    assertTrue(\"terms are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n\n    bu.clear();\n    assertFalse(bu.any());\n    assertEquals(bu.ramBytesUsed(), 0L);\n  }\n\n","bugFix":["f10eec8bf984dab2325e55aa277645e80bf195f4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7aff85e853fc8018761caa9a7803b1db411db8c","date":1586893039,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBufferedUpdates#testRamBytesUsed().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBufferedUpdates#testRamBytesUsed().mjava","sourceNew":"  public void testRamBytesUsed() {\n    BufferedUpdates bu = new BufferedUpdates(\"seg1\");\n    assertEquals(bu.ramBytesUsed(), 0L);\n    assertFalse(bu.any());\n    int queries = atLeast(1);\n    for (int i = 0; i < queries; i++) {\n      final int docIDUpto = random().nextBoolean() ? Integer.MAX_VALUE : random().nextInt();\n      final Term term = new Term(\"id\", Integer.toString(random().nextInt(100)));\n      bu.addQuery(new TermQuery(term), docIDUpto);\n    }\n\n    int terms = atLeast(1);\n    for (int i = 0; i < terms; i++) {\n      final int docIDUpto = random().nextBoolean() ? Integer.MAX_VALUE : random().nextInt();\n      final Term term = new Term(\"id\", Integer.toString(random().nextInt(100)));\n      bu.addTerm(term, docIDUpto);\n    }\n    assertTrue(\"we have added tons of docIds, terms and queries\", bu.any());\n\n    long totalUsed = bu.ramBytesUsed();\n    assertTrue(totalUsed > 0);\n\n    bu.clearDeleteTerms();\n    assertTrue(\"only terms and docIds are cleaned, the queries are still in memory\", bu.any());\n    assertTrue(\"terms are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n\n    bu.clear();\n    assertFalse(bu.any());\n    assertEquals(bu.ramBytesUsed(), 0L);\n  }\n\n","sourceOld":"  public void testRamBytesUsed() {\n    BufferedUpdates bu = new BufferedUpdates(\"seg1\");\n    assertEquals(bu.ramBytesUsed(), 0L);\n    assertFalse(bu.any());\n    int docIds = atLeast(1);\n    for (int i = 0; i < docIds; i++) {\n      bu.addDocID(random().nextInt(100));\n    }\n\n    int queries = atLeast(1);\n    for (int i = 0; i < queries; i++) {\n      final int docIDUpto = random().nextBoolean() ? Integer.MAX_VALUE : random().nextInt();\n      final Term term = new Term(\"id\", Integer.toString(random().nextInt(100)));\n      bu.addQuery(new TermQuery(term), docIDUpto);\n    }\n\n    int terms = atLeast(1);\n    for (int i = 0; i < terms; i++) {\n      final int docIDUpto = random().nextBoolean() ? Integer.MAX_VALUE : random().nextInt();\n      final Term term = new Term(\"id\", Integer.toString(random().nextInt(100)));\n      bu.addTerm(term, docIDUpto);\n    }\n    assertTrue(\"we have added tons of docIds, terms and queries\", bu.any());\n\n    long totalUsed = bu.ramBytesUsed();\n    assertTrue(totalUsed > 0);\n\n    bu.clearDeletedDocIds();\n    assertTrue(\"only docIds are cleaned, buffer shouldn't be empty\", bu.any());\n    assertTrue(\"docIds are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n    totalUsed = bu.ramBytesUsed();\n\n    bu.clearDeleteTerms();\n    assertTrue(\"only terms and docIds are cleaned, the queries are still in memory\", bu.any());\n    assertTrue(\"terms are cleaned, ram in used should decrease\", totalUsed > bu.ramBytesUsed());\n\n    bu.clear();\n    assertFalse(bu.any());\n    assertEquals(bu.ramBytesUsed(), 0L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8eb8848aaae6ef71d3f65e721d9148b9906b5e8b":["f10eec8bf984dab2325e55aa277645e80bf195f4"],"e7aff85e853fc8018761caa9a7803b1db411db8c":["8eb8848aaae6ef71d3f65e721d9148b9906b5e8b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f10eec8bf984dab2325e55aa277645e80bf195f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7aff85e853fc8018761caa9a7803b1db411db8c"]},"commit2Childs":{"8eb8848aaae6ef71d3f65e721d9148b9906b5e8b":["e7aff85e853fc8018761caa9a7803b1db411db8c"],"e7aff85e853fc8018761caa9a7803b1db411db8c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f10eec8bf984dab2325e55aa277645e80bf195f4"],"f10eec8bf984dab2325e55aa277645e80bf195f4":["8eb8848aaae6ef71d3f65e721d9148b9906b5e8b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}