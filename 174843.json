{"path":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecd43031c9af26f2955774bb908512b3a9c2301c","date":1316181946,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            mode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","date":1320922486,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tSpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            mode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            mode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"541f6605a29362fa8a42f33b69069e7da5178034","date":1337786849,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tSpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      term = new Term(field, tokenText);\n      int docFreq = 0;\n      if (reader != null) {\n        docFreq = reader.docFreq(term);\n      }\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n          ((options.alternativeTermCount == null || docFreq == 0) ? count\n              : options.alternativeTermCount), field != null ? reader : null, // workaround LUCENE-1295\n          field, options.suggestMode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)\n          && options.alternativeTermCount == null) {\n        // These are spelled the same, continue on\n        continue;\n      }\n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && docFreq > 0) {\n        boolean foundOriginal = false;\n        String[] suggestionsWithOrig = new String[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          suggestionsWithOrig[0] = tokenText;\n          suggestions = suggestionsWithOrig;\n        }\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        result.addFrequency(token, docFreq);\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tSpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            mode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["55b8276f00bacdbaefed6689ef19a4d3a309bf10"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tSpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      term = new Term(field, tokenText);\n      int docFreq = 0;\n      if (reader != null) {\n        docFreq = reader.docFreq(term);\n      }\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n          ((options.alternativeTermCount == null || docFreq == 0) ? count\n              : options.alternativeTermCount), field != null ? reader : null, // workaround LUCENE-1295\n          field, options.suggestMode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)\n          && options.alternativeTermCount == null) {\n        // These are spelled the same, continue on\n        continue;\n      }\n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && docFreq > 0) {\n        boolean foundOriginal = false;\n        String[] suggestionsWithOrig = new String[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          suggestionsWithOrig[0] = tokenText;\n          suggestions = suggestionsWithOrig;\n        }\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        result.addFrequency(token, docFreq);\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tSpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            mode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      term = new Term(field, tokenText);\n      int docFreq = 0;\n      if (reader != null) {\n        docFreq = reader.docFreq(term);\n      }\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n          ((options.alternativeTermCount == null || docFreq == 0) ? count\n              : options.alternativeTermCount), field != null ? reader : null, // workaround LUCENE-1295\n          field, options.suggestMode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)\n          && options.alternativeTermCount == null) {\n        // These are spelled the same, continue on\n        continue;\n      }\n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && docFreq > 0) {\n        boolean foundOriginal = false;\n        String[] suggestionsWithOrig = new String[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          suggestionsWithOrig[0] = tokenText;\n          suggestions = suggestionsWithOrig;\n        }\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        result.addFrequency(token, docFreq);\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n          for (int i = 0; i < countLimit; i++) {\n            term = new Term(field, suggestions[i]);\n            result.add(token, suggestions[i], reader.docFreq(term));\n          }\n        } else {\n          List<String> suggList = Collections.emptyList();\n          result.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n          List<String> suggList = Collections.emptyList();\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tSpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      term = new Term(field, tokenText);\n      int docFreq = 0;\n      if (reader != null) {\n        docFreq = reader.docFreq(term);\n      }\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n          ((options.alternativeTermCount == null || docFreq == 0) ? count\n              : options.alternativeTermCount), field != null ? reader : null, // workaround LUCENE-1295\n          field, options.suggestMode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)\n          && options.alternativeTermCount == null) {\n        // These are spelled the same, continue on\n        continue;\n      }\n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && docFreq > 0) {\n        boolean foundOriginal = false;\n        String[] suggestionsWithOrig = new String[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          suggestionsWithOrig[0] = tokenText;\n          suggestions = suggestionsWithOrig;\n        }\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        result.addFrequency(token, docFreq);\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55b8276f00bacdbaefed6689ef19a4d3a309bf10","date":1399312570,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      term = new Term(field, tokenText);\n      int docFreq = 0;\n      if (reader != null) {\n        docFreq = reader.docFreq(term);\n      }\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n          ((options.alternativeTermCount == 0 || docFreq == 0) ? count\n              : options.alternativeTermCount), field != null ? reader : null, // workaround LUCENE-1295\n          field, options.suggestMode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)\n          && options.alternativeTermCount == 0) {\n        // These are spelled the same, continue on\n        continue;\n      }\n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount > 0 && docFreq > 0) {\n        boolean foundOriginal = false;\n        String[] suggestionsWithOrig = new String[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          suggestionsWithOrig[0] = tokenText;\n          suggestions = suggestionsWithOrig;\n        }\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        result.addFrequency(token, docFreq);\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n          for (int i = 0; i < countLimit; i++) {\n            term = new Term(field, suggestions[i]);\n            result.add(token, suggestions[i], reader.docFreq(term));\n          }\n        } else {\n          List<String> suggList = Collections.emptyList();\n          result.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n          List<String> suggList = Collections.emptyList();\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      term = new Term(field, tokenText);\n      int docFreq = 0;\n      if (reader != null) {\n        docFreq = reader.docFreq(term);\n      }\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n          ((options.alternativeTermCount == null || docFreq == 0) ? count\n              : options.alternativeTermCount), field != null ? reader : null, // workaround LUCENE-1295\n          field, options.suggestMode, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)\n          && options.alternativeTermCount == null) {\n        // These are spelled the same, continue on\n        continue;\n      }\n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && docFreq > 0) {\n        boolean foundOriginal = false;\n        String[] suggestionsWithOrig = new String[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          suggestionsWithOrig[0] = tokenText;\n          suggestions = suggestionsWithOrig;\n        }\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        result.addFrequency(token, docFreq);\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n          for (int i = 0; i < countLimit; i++) {\n            term = new Term(field, suggestions[i]);\n            result.add(token, suggestions[i], reader.docFreq(term));\n          }\n        } else {\n          List<String> suggList = Collections.emptyList();\n          result.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else {\n          List<String> suggList = Collections.emptyList();\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":["541f6605a29362fa8a42f33b69069e7da5178034"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ecd43031c9af26f2955774bb908512b3a9c2301c":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","541f6605a29362fa8a42f33b69069e7da5178034"],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["ecd43031c9af26f2955774bb908512b3a9c2301c"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55b8276f00bacdbaefed6689ef19a4d3a309bf10":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["55b8276f00bacdbaefed6689ef19a4d3a309bf10"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["541f6605a29362fa8a42f33b69069e7da5178034"],"541f6605a29362fa8a42f33b69069e7da5178034":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"]},"commit2Childs":{"ecd43031c9af26f2955774bb908512b3a9c2301c":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["ecd43031c9af26f2955774bb908512b3a9c2301c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["3599646b4d4c346cf74d334813488b8b337b5bf5","541f6605a29362fa8a42f33b69069e7da5178034"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"55b8276f00bacdbaefed6689ef19a4d3a309bf10":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"541f6605a29362fa8a42f33b69069e7da5178034":["3599646b4d4c346cf74d334813488b8b337b5bf5","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["55b8276f00bacdbaefed6689ef19a4d3a309bf10"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3599646b4d4c346cf74d334813488b8b337b5bf5","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}