{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close();\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog?\n\n      // Closing the log currently deletes the log file.\n      // If this changes, we should record this as a \"commit\".\n      if (ulog != null) ulog.close();\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","0cf25ac9828f9d484e626a18635422d10f8c9549"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close();\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog?\n\n      // Closing the log currently deletes the log file.\n      // If this changes, we should record this as a \"commit\".\n      if (ulog != null) ulog.close();\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close();\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog?\n\n      // Closing the log currently deletes the log file.\n      // If this changes, we should record this as a \"commit\".\n      if (ulog != null) ulog.close();\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd4f332774f36bc85e29ac69a692f960dac011a9","date":1328162395,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog.\n\n      if (ulog != null) ulog.close(true);\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close();\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog?\n\n      // Closing the log currently deletes the log file.\n      // If this changes, we should record this as a \"commit\".\n      if (ulog != null) ulog.close();\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a9e81d464930e5664da049442e2630d4b9b00d5","date":1330726364,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // if we are later going to mark everything in the tlog as committed, then we\n      // need to block all updates from coming in so we can be sure that the close\n      // will contain all of the updates.\n\n      VersionInfo vinfo = ulog == null ? null : ulog.getVersionInfo();\n      if (vinfo != null) {\n        // TODO: move the RW update lock somewhere else?\n        vinfo.blockUpdates();\n      }\n      try {\n\n        boolean succeeded = false;\n        try {\n          if (writer != null) {\n            writer.close();\n          }\n          succeeded = true;\n        } finally {\n          if (ulog != null) ulog.close(succeeded);\n        }\n\n      } finally {\n        if (vinfo != null) {\n          vinfo.unblockUpdates();\n        }\n      }\n\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog.\n\n      if (ulog != null) ulog.close(true);\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","ab20a04a303d3d2a5078076f4633e0482d643cc0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65a624f4e68050059f1fc2fab69b0084fdc323ec","date":1330812096,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (this) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (this) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // if we are later going to mark everything in the tlog as committed, then we\n      // need to block all updates from coming in so we can be sure that the close\n      // will contain all of the updates.\n\n      VersionInfo vinfo = ulog == null ? null : ulog.getVersionInfo();\n      if (vinfo != null) {\n        // TODO: move the RW update lock somewhere else?\n        vinfo.blockUpdates();\n      }\n      try {\n\n        boolean succeeded = false;\n        try {\n          if (writer != null) {\n            writer.close();\n          }\n          succeeded = true;\n        } finally {\n          if (ulog != null) ulog.close(succeeded);\n        }\n\n      } finally {\n        if (vinfo != null) {\n          vinfo.unblockUpdates();\n        }\n      }\n\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (this) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (this) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    commitLock.lock();\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows.\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n      // if the writer hits an exception, it's OK (and perhaps desirable)\n      // to not close the ulog.\n\n      if (ulog != null) ulog.close(true);\n    } finally {\n      commitLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (this) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (this) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["65a624f4e68050059f1fc2fab69b0084fdc323ec"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (this) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (this) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (this) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (this) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1381b91b03f7409d8d548c7070dbc615931a0f50","date":1343667369,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b47e1512544568a22b82c96169d466fae8a4b79e","date":1354519309,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cf25ac9828f9d484e626a18635422d10f8c9549","date":1360344005,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    commitLock.lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      commitLock.unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.shutdown();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["ab20a04a303d3d2a5078076f4633e0482d643cc0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab20a04a303d3d2a5078076f4633e0482d643cc0","date":1398201811,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.shutdown();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29910137b7318259df785a3fbcf80a1d0365e3b4","date":1398214905,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        try {\n          writer.waitForMerges();\n        } finally {\n          writer.close();\n        }\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.close();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        try {\n          writer.waitForMerges();\n        } finally {\n          writer.close();\n        }\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) writer.shutdown();\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b262e4be9cc7c2090a610b2a5e3628815288798","date":1403120031,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        try {\n          if (indexWriterCloseWaitsForMerges) writer.waitForMerges();\n        } finally {\n          writer.close();\n        }\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        try {\n          writer.waitForMerges();\n        } finally {\n          writer.close();\n        }\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15fbe8579d34349a8c79cbc5c933530dd5b6742a","date":1418066328,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        try {\n          if (indexWriterCloseWaitsForMerges) writer.waitForMerges();\n        } finally {\n          writer.close();\n        }\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["29910137b7318259df785a3fbcf80a1d0365e3b4","7b262e4be9cc7c2090a610b2a5e3628815288798"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          final Map<String,String> commitData = new HashMap<>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["13734b36bfd631ed6a46b961df376f679e8a3f57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"536b47681314488eb94706248be6047a3f142841","date":1450372090,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13734b36bfd631ed6a46b961df376f679e8a3f57","date":1473743967,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer);\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreDescriptor().getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n\n    boolean clearRequestInfo = false;\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    if (SolrRequestInfo.getRequestInfo() == null) {\n      clearRequestInfo = true;\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp)); // important for debugging\n    }\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?\n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges()\n          && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      // be tactical with this lock! closing the updatelog can deadlock when it tries to commit\n      solrCoreState.getCommitLock().lock();\n      try {\n        try {\n          if (tryToCommit) {\n            log.info(\"Committing on IndexWriter close.\");\n            CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n            cmd.openSearcher = false;\n            cmd.waitSearcher = false;\n            cmd.softCommit = false;\n\n            // TODO: keep other commit callbacks from being called?\n            // this.commit(cmd); // too many test failures using this method... is it because of callbacks?\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.preCommit(cmd);\n            }\n\n            // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.postCommit(cmd);\n            }\n          }\n        } catch (Throwable th) {\n          log.error(\"Error in final commit\", th);\n          if (th instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) th;\n          }\n        }\n\n      } finally {\n        solrCoreState.getCommitLock().unlock();\n\n      }\n    } finally {\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n    // we went through the normal process to commit, so we don't have to artificially\n    // cap any ulog files.\n    try {\n      if (ulog != null) ulog.close(false);\n    } catch (Throwable th) {\n      log.error(\"Error closing log files\", th);\n      if (th instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) th;\n      }\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n    \n    boolean clearRequestInfo = false;\n    solrCoreState.getCommitLock().lock();\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      if (SolrRequestInfo.getRequestInfo() == null) {\n        clearRequestInfo = true;\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));  // important for debugging\n      }\n\n\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?     \n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      try {\n        if (tryToCommit) {\n          log.info(\"Committing on IndexWriter close.\");\n          CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n          cmd.openSearcher = false;\n          cmd.waitSearcher = false;\n          cmd.softCommit = false;\n\n          // TODO: keep other commit callbacks from being called?\n         //  this.commit(cmd);        // too many test failures using this method... is it because of callbacks?\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.preCommit(cmd);\n          }\n\n          // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n          SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n          writer.commit();\n\n          synchronized (solrCoreState.getUpdateLock()) {\n            ulog.postCommit(cmd);\n          }\n        }\n      } catch (Throwable th) {\n        log.error(\"Error in final commit\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      // we went through the normal process to commit, so we don't have to artificially\n      // cap any ulog files.\n      try {\n        if (ulog != null) ulog.close(false);\n      }  catch (Throwable th) {\n        log.error(\"Error closing log files\", th);\n        if (th instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) th;\n        }\n      }\n\n      if (writer != null) {\n        writer.close();\n      }\n\n    } finally {\n      solrCoreState.getCommitLock().unlock();\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["be320990bdc77e643388fa801e75017f19289c42","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","65a624f4e68050059f1fc2fab69b0084fdc323ec","1a9e81d464930e5664da049442e2630d4b9b00d5","0cf25ac9828f9d484e626a18635422d10f8c9549","ab20a04a303d3d2a5078076f4633e0482d643cc0","b47e1512544568a22b82c96169d466fae8a4b79e","29910137b7318259df785a3fbcf80a1d0365e3b4","536b47681314488eb94706248be6047a3f142841","1381b91b03f7409d8d548c7070dbc615931a0f50","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    log.trace(\"closeWriter({}): ulog={}\", writer, ulog);\n    \n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n\n    boolean clearRequestInfo = false;\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    if (SolrRequestInfo.getRequestInfo() == null) {\n      clearRequestInfo = true;\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp)); // important for debugging\n    }\n    try {\n\n      if (TestInjection.injectSkipIndexWriterCommitOnClose(writer)) {\n        // if this TestInjection triggers, we do some simple rollback()\n        // (which closes the underlying IndexWriter) and then return immediately\n        log.warn(\"Skipping commit for IndexWriter.close() due to TestInjection\");\n        if (writer != null) {\n          writer.rollback();\n        }\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n      \n      // do a commit before we quit?\n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges()\n          && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      // be tactical with this lock! closing the updatelog can deadlock when it tries to commit\n      solrCoreState.getCommitLock().lock();\n      try {\n        try {\n          log.info(\"Committing on IndexWriter.close() {}.\",\n                   (tryToCommit ? \"\" : \" ... SKIPPED (unnecessary)\"));\n          if (tryToCommit) {\n            CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n            cmd.openSearcher = false;\n            cmd.waitSearcher = false;\n            cmd.softCommit = false;\n\n            // TODO: keep other commit callbacks from being called?\n            // this.commit(cmd); // too many test failures using this method... is it because of callbacks?\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.preCommit(cmd);\n            }\n\n            // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.postCommit(cmd);\n            }\n          }\n        } catch (Throwable th) {\n          log.error(\"Error in final commit\", th);\n          if (th instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) th;\n          }\n        }\n\n      } finally {\n        solrCoreState.getCommitLock().unlock();\n\n      }\n    } finally {\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n    // we went through the normal process to commit, so we don't have to artificially\n    // cap any ulog files.\n    try {\n      if (ulog != null) ulog.close(false);\n    } catch (Throwable th) {\n      log.error(\"Error closing log files\", th);\n      if (th instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) th;\n      }\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n\n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n\n    boolean clearRequestInfo = false;\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    if (SolrRequestInfo.getRequestInfo() == null) {\n      clearRequestInfo = true;\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp)); // important for debugging\n    }\n    try {\n      if (!commitOnClose) {\n        if (writer != null) {\n          writer.rollback();\n        }\n\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n\n      // do a commit before we quit?\n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges()\n          && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      // be tactical with this lock! closing the updatelog can deadlock when it tries to commit\n      solrCoreState.getCommitLock().lock();\n      try {\n        try {\n          if (tryToCommit) {\n            log.info(\"Committing on IndexWriter close.\");\n            CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n            cmd.openSearcher = false;\n            cmd.waitSearcher = false;\n            cmd.softCommit = false;\n\n            // TODO: keep other commit callbacks from being called?\n            // this.commit(cmd); // too many test failures using this method... is it because of callbacks?\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.preCommit(cmd);\n            }\n\n            // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.postCommit(cmd);\n            }\n          }\n        } catch (Throwable th) {\n          log.error(\"Error in final commit\", th);\n          if (th instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) th;\n          }\n        }\n\n      } finally {\n        solrCoreState.getCommitLock().unlock();\n\n      }\n    } finally {\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n    // we went through the normal process to commit, so we don't have to artificially\n    // cap any ulog files.\n    try {\n      if (ulog != null) ulog.close(false);\n    } catch (Throwable th) {\n      log.error(\"Error closing log files\", th);\n      if (th instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) th;\n      }\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#closeWriter(IndexWriter).mjava","sourceNew":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    log.trace(\"closeWriter({}): ulog={}\", writer, ulog);\n    \n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n\n    boolean clearRequestInfo = false;\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    if (SolrRequestInfo.getRequestInfo() == null) {\n      clearRequestInfo = true;\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp)); // important for debugging\n    }\n    try {\n\n      if (TestInjection.injectSkipIndexWriterCommitOnClose(writer)) {\n        // if this TestInjection triggers, we do some simple rollback()\n        // (which closes the underlying IndexWriter) and then return immediately\n        log.warn(\"Skipping commit for IndexWriter.close() due to TestInjection\");\n        if (writer != null) {\n          writer.rollback();\n        }\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n      \n      // do a commit before we quit?\n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges()\n          && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      // be tactical with this lock! closing the updatelog can deadlock when it tries to commit\n      solrCoreState.getCommitLock().lock();\n      try {\n        try {\n          if (log.isInfoEnabled()) {\n            log.info(\"Committing on IndexWriter.close() {}.\",\n                (tryToCommit ? \"\" : \" ... SKIPPED (unnecessary)\"));\n          }\n          if (tryToCommit) {\n            CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n            cmd.openSearcher = false;\n            cmd.waitSearcher = false;\n            cmd.softCommit = false;\n\n            // TODO: keep other commit callbacks from being called?\n            // this.commit(cmd); // too many test failures using this method... is it because of callbacks?\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.preCommit(cmd);\n            }\n\n            // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.postCommit(cmd);\n            }\n          }\n        } catch (Throwable th) {\n          log.error(\"Error in final commit\", th);\n          if (th instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) th;\n          }\n        }\n\n      } finally {\n        solrCoreState.getCommitLock().unlock();\n\n      }\n    } finally {\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n    // we went through the normal process to commit, so we don't have to artificially\n    // cap any ulog files.\n    try {\n      if (ulog != null) ulog.close(false);\n    } catch (Throwable th) {\n      log.error(\"Error closing log files\", th);\n      if (th instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) th;\n      }\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n\n  }\n\n","sourceOld":"  // IndexWriterCloser interface method - called from solrCoreState.decref(this)\n  @Override\n  public void closeWriter(IndexWriter writer) throws IOException {\n    log.trace(\"closeWriter({}): ulog={}\", writer, ulog);\n    \n    assert TestInjection.injectNonGracefullClose(core.getCoreContainer());\n\n    boolean clearRequestInfo = false;\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    if (SolrRequestInfo.getRequestInfo() == null) {\n      clearRequestInfo = true;\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp)); // important for debugging\n    }\n    try {\n\n      if (TestInjection.injectSkipIndexWriterCommitOnClose(writer)) {\n        // if this TestInjection triggers, we do some simple rollback()\n        // (which closes the underlying IndexWriter) and then return immediately\n        log.warn(\"Skipping commit for IndexWriter.close() due to TestInjection\");\n        if (writer != null) {\n          writer.rollback();\n        }\n        // we shouldn't close the transaction logs either, but leaving them open\n        // means we can't delete them on windows (needed for tests)\n        if (ulog != null) ulog.close(false);\n\n        return;\n      }\n      \n      // do a commit before we quit?\n      boolean tryToCommit = writer != null && ulog != null && ulog.hasUncommittedChanges()\n          && ulog.getState() == UpdateLog.State.ACTIVE;\n\n      // be tactical with this lock! closing the updatelog can deadlock when it tries to commit\n      solrCoreState.getCommitLock().lock();\n      try {\n        try {\n          log.info(\"Committing on IndexWriter.close() {}.\",\n                   (tryToCommit ? \"\" : \" ... SKIPPED (unnecessary)\"));\n          if (tryToCommit) {\n            CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n            cmd.openSearcher = false;\n            cmd.waitSearcher = false;\n            cmd.softCommit = false;\n\n            // TODO: keep other commit callbacks from being called?\n            // this.commit(cmd); // too many test failures using this method... is it because of callbacks?\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.preCommit(cmd);\n            }\n\n            // todo: refactor this shared code (or figure out why a real CommitUpdateCommand can't be used)\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n\n            synchronized (solrCoreState.getUpdateLock()) {\n              ulog.postCommit(cmd);\n            }\n          }\n        } catch (Throwable th) {\n          log.error(\"Error in final commit\", th);\n          if (th instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) th;\n          }\n        }\n\n      } finally {\n        solrCoreState.getCommitLock().unlock();\n\n      }\n    } finally {\n      if (clearRequestInfo) SolrRequestInfo.clearRequestInfo();\n    }\n    // we went through the normal process to commit, so we don't have to artificially\n    // cap any ulog files.\n    try {\n      if (ulog != null) ulog.close(false);\n    } catch (Throwable th) {\n      log.error(\"Error closing log files\", th);\n      if (th instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) th;\n      }\n    }\n\n    if (writer != null) {\n      writer.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ab68488225b6a6c357dda72ed11dedca9914a192"],"65a624f4e68050059f1fc2fab69b0084fdc323ec":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"740d649f013f07efbeb73ca854f106c60166e7c0":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["bd4f332774f36bc85e29ac69a692f960dac011a9","65a624f4e68050059f1fc2fab69b0084fdc323ec"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"ab20a04a303d3d2a5078076f4633e0482d643cc0":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bd4f332774f36bc85e29ac69a692f960dac011a9":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"89424def13674ea17829b41c5883c54ecc31a132":["536b47681314488eb94706248be6047a3f142841","13734b36bfd631ed6a46b961df376f679e8a3f57"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["65a624f4e68050059f1fc2fab69b0084fdc323ec","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["536b47681314488eb94706248be6047a3f142841","89424def13674ea17829b41c5883c54ecc31a132"],"0cf25ac9828f9d484e626a18635422d10f8c9549":["b47e1512544568a22b82c96169d466fae8a4b79e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["65a624f4e68050059f1fc2fab69b0084fdc323ec","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"be320990bdc77e643388fa801e75017f19289c42":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["0cf25ac9828f9d484e626a18635422d10f8c9549"],"ab68488225b6a6c357dda72ed11dedca9914a192":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"7b262e4be9cc7c2090a610b2a5e3628815288798":["29910137b7318259df785a3fbcf80a1d0365e3b4"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"13734b36bfd631ed6a46b961df376f679e8a3f57":["536b47681314488eb94706248be6047a3f142841"],"536b47681314488eb94706248be6047a3f142841":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","29910137b7318259df785a3fbcf80a1d0365e3b4"],"1a9e81d464930e5664da049442e2630d4b9b00d5":["bd4f332774f36bc85e29ac69a692f960dac011a9"],"407687e67faf6e1f02a211ca078d8e3eed631027":["1381b91b03f7409d8d548c7070dbc615931a0f50","b47e1512544568a22b82c96169d466fae8a4b79e"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["be320990bdc77e643388fa801e75017f19289c42"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["536b47681314488eb94706248be6047a3f142841","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"29910137b7318259df785a3fbcf80a1d0365e3b4":["ab20a04a303d3d2a5078076f4633e0482d643cc0"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","1381b91b03f7409d8d548c7070dbc615931a0f50"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"b47e1512544568a22b82c96169d466fae8a4b79e":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["65a624f4e68050059f1fc2fab69b0084fdc323ec"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["7b262e4be9cc7c2090a610b2a5e3628815288798"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"65a624f4e68050059f1fc2fab69b0084fdc323ec":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"ab20a04a303d3d2a5078076f4633e0482d643cc0":["29910137b7318259df785a3fbcf80a1d0365e3b4"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["740d649f013f07efbeb73ca854f106c60166e7c0"],"bd4f332774f36bc85e29ac69a692f960dac011a9":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1a9e81d464930e5664da049442e2630d4b9b00d5"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"0cf25ac9828f9d484e626a18635422d10f8c9549":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ab20a04a303d3d2a5078076f4633e0482d643cc0","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"ab68488225b6a6c357dda72ed11dedca9914a192":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"be320990bdc77e643388fa801e75017f19289c42":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7b262e4be9cc7c2090a610b2a5e3628815288798":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"13734b36bfd631ed6a46b961df376f679e8a3f57":["89424def13674ea17829b41c5883c54ecc31a132"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"536b47681314488eb94706248be6047a3f142841":["89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","13734b36bfd631ed6a46b961df376f679e8a3f57","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"1a9e81d464930e5664da049442e2630d4b9b00d5":["65a624f4e68050059f1fc2fab69b0084fdc323ec"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"1381b91b03f7409d8d548c7070dbc615931a0f50":["407687e67faf6e1f02a211ca078d8e3eed631027","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","b47e1512544568a22b82c96169d466fae8a4b79e"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"29910137b7318259df785a3fbcf80a1d0365e3b4":["7b262e4be9cc7c2090a610b2a5e3628815288798","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["bd4f332774f36bc85e29ac69a692f960dac011a9","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"b47e1512544568a22b82c96169d466fae8a4b79e":["0cf25ac9828f9d484e626a18635422d10f8c9549","407687e67faf6e1f02a211ca078d8e3eed631027"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["536b47681314488eb94706248be6047a3f142841"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","407687e67faf6e1f02a211ca078d8e3eed631027","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}