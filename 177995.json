{"path":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","sourceOld":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb10b6bcde550b87d8f10e5f010bd8f3021023b6","date":1274974592,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","sourceOld":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c18273ea5b3974d2f30117f46f1ae416c28f727","date":1279708040,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":"  @Override\n  void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","sourceOld":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"833a7987bc1c94455fde83e3311f72bddedcfb93","date":1279951470,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":null,"sourceOld":"  @Override\n  void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e1cbd7e289dc1243c7a59e1a83d078163a147fe","date":1292268032,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n      state.hasVectors = hasVectors;\n      hasVectors = false;\n    }    \n  }\n\n","sourceOld":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":null,"sourceOld":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n      state.hasVectors = hasVectors;\n      hasVectors = false;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter#closeDocStore(SegmentWriteState).mjava","sourceNew":null,"sourceOld":"  @Override\n  synchronized void closeDocStore(final SegmentWriteState state) throws IOException {\n    if (tvx != null) {\n      // At least one doc in this run had term vectors\n      // enabled\n      fill(state.numDocsInStore - docWriter.getDocStoreOffset());\n      tvx.close();\n      tvf.close();\n      tvd.close();\n      tvx = null;\n      assert state.docStoreSegmentName != null;\n      String idxName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n      if (4+((long) state.numDocsInStore)*16 != state.directory.fileLength(idxName))\n        throw new RuntimeException(\"after flush: tvx size mismatch: \" + state.numDocsInStore + \" docs vs \" + state.directory.fileLength(idxName) + \" length in bytes of \" + idxName + \" file exists?=\" + state.directory.fileExists(idxName));\n\n      String fldName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_FIELDS_EXTENSION);\n      String docName = IndexFileNames.segmentFileName(state.docStoreSegmentName, \"\", IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);\n      state.flushedFiles.add(idxName);\n      state.flushedFiles.add(fldName);\n      state.flushedFiles.add(docName);\n\n      docWriter.removeOpenFile(idxName);\n      docWriter.removeOpenFile(fldName);\n      docWriter.removeOpenFile(docName);\n\n      lastDocID = 0;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6c18273ea5b3974d2f30117f46f1ae416c28f727":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"833a7987bc1c94455fde83e3311f72bddedcfb93":["6c18273ea5b3974d2f30117f46f1ae416c28f727"]},"commit2Childs":{"6c18273ea5b3974d2f30117f46f1ae416c28f727":["833a7987bc1c94455fde83e3311f72bddedcfb93"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":[],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["6c18273ea5b3974d2f30117f46f1ae416c28f727","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"833a7987bc1c94455fde83e3311f72bddedcfb93":[]},"heads":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","cd5edd1f2b162a5cfa08efd17851a07373a96817","833a7987bc1c94455fde83e3311f72bddedcfb93"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}