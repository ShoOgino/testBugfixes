{"path":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","commits":[{"id":"40dce2b6d4360eb09fa16fb6c40a18b25507ed73","date":1383035822,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"/dev/null","sourceNew":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n    final Slice shard1 = testcoll.getSlices().iterator().next();\n    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n    Replica replica = shard1.getReplicas().iterator().next();\n\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica, shard1.getName());\n    client.shutdown();\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["cd548b14f1051e707393e77329f80c5e89f69919"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b896234cdca0b42c82da86ef5ea4cff3304386b9","date":1383419158,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n    final Slice shard1 = testcoll.getSlices().iterator().next();\n    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n    boolean found = false;\n    Replica replica1 = null;\n    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n\n    if(replica1 == null) fail(\"no active relicas found\");\n\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n    final Slice shard1 = testcoll.getSlices().iterator().next();\n    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n    Replica replica = shard1.getReplicas().iterator().next();\n\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica, shard1.getName());\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":["cd548b14f1051e707393e77329f80c5e89f69919"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d23ef77430304e87e9feffc67378b4f4e536b9f4","date":1384326156,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active relicas found\");\n\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n    final Slice shard1 = testcoll.getSlices().iterator().next();\n    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n    boolean found = false;\n    Replica replica1 = null;\n    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n\n    if(replica1 == null) fail(\"no active relicas found\");\n\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":["cd548b14f1051e707393e77329f80c5e89f69919"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c","date":1384408319,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active replicas found\");\n    Thread.sleep(2500);//remove this later.not sure if the clusterstate is not propagated and that is why the tests are failing.SOLR-5437\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active relicas found\");\n\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n  }\n\n","bugFix":null,"bugIntro":["cd548b14f1051e707393e77329f80c5e89f69919"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5a2b742df77744d3f370c51ae4d86e71f6802e9","date":1385009865,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active replicas found\");\n    Thread.sleep(2500);//remove this later.not sure if the clusterstate is not propagated and that is why the tests are failing.SOLR-5437\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active replicas found\");\n    Thread.sleep(2500);//remove this later.not sure if the clusterstate is not propagated and that is why the tests are failing.SOLR-5437\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd548b14f1051e707393e77329f80c5e89f69919","date":1385226862,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n      // final Slice shard1 = testcoll.getSlices().iterator().next();\n      // if(!shard1.getState().equals(Slice.ACTIVE))\n      // fail(\"shard is not active\");\n      // for (Replica replica : shard1.getReplicas())\n      // if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active replicas found\");\n    Thread.sleep(2500);//remove this later.not sure if the clusterstate is not propagated and that is why the tests are failing.SOLR-5437\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n  }\n\n","bugFix":["a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c","40dce2b6d4360eb09fa16fb6c40a18b25507ed73","d23ef77430304e87e9feffc67378b4f4e536b9f4","b896234cdca0b42c82da86ef5ea4cff3304386b9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n      // final Slice shard1 = testcoll.getSlices().iterator().next();\n      // if(!shard1.getState().equals(Slice.ACTIVE))\n      // fail(\"shard is not active\");\n      // for (Replica replica : shard1.getReplicas())\n      // if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception{\n    String COLL_NAME = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    createColl(COLL_NAME, client);\n    DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader().getClusterState().getCollection(COLL_NAME);\n\n    Slice shard1 = null;\n    Replica replica1 = null;\n    for (Slice slice : testcoll.getSlices()) {\n      if(\"active\".equals( slice.getStr(\"state\"))){\n        shard1 = slice;\n        for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      }\n    }\n//    final Slice shard1 = testcoll.getSlices().iterator().next();\n//    if(!shard1.getState().equals(Slice.ACTIVE)) fail(\"shard is not active\");\n//    for (Replica replica : shard1.getReplicas()) if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n    if(replica1 == null) fail(\"no active replicas found\");\n    Thread.sleep(2500);//remove this later.not sure if the clusterstate is not propagated and that is why the tests are failing.SOLR-5437\n    removeAndWaitForReplicaGone(COLL_NAME, client, replica1, shard1.getName());\n    client.shutdown();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8497bb4f9de61b5520423bd9af88ea11a6e109e7","date":1393245090,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n      // final Slice shard1 = testcoll.getSlices().iterator().next();\n      // if(!shard1.getState().equals(Slice.ACTIVE))\n      // fail(\"shard is not active\");\n      // for (Replica replica : shard1.getReplicas())\n      // if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","date":1393532551,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n      // final Slice shard1 = testcoll.getSlices().iterator().next();\n      // if(!shard1.getState().equals(Slice.ACTIVE))\n      // fail(\"shard is not active\");\n      // for (Replica replica : shard1.getReplicas())\n      // if(\"active\".equals(replica.getStr(\"state\"))) replica1 =replica;\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735","date":1403859600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrServer replica1Server = new HttpSolrServer(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Server);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Server.shutdown();\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdbe605f0d40f92b9fa92baa735e60b6e445c182","date":1410914995,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrServer replica1Server = new HttpSolrServer(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Server);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Server.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName(), dataDir);\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrServer replica1Server = new HttpSolrServer(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Server);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Server.shutdown();\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd657606b6786db7b4cf5f88ce642f11168d5437","date":1411160355,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrServer replica1Server = new HttpSolrServer(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Server);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Server.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      for (Slice slice : testcoll.getSlices()) {\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas())\n            if (\"active\".equals(replica.getStr(\"state\"))) replica1 = replica;\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrServer replica1Server = new HttpSolrServer(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Server);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Server.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName(), dataDir);\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1,\n          shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Client.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrServer().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrServer replica1Server = new HttpSolrServer(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Server);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Server.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Client.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Client.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"));\n      String dataDir = null;\n      try {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      } finally {\n        replica1Client.shutdown();\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e17fc5a261478b4a4b6978d5c96fb65ae590faf4","date":1424194284,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Should have had a good message here\", se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (ZkStateReader.ACTIVE.equals(replica.getStr(ZkStateReader.STATE_PROP))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (ZkStateReader.ACTIVE.equals(replica.getStr(ZkStateReader.STATE_PROP))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (\"active\".equals(slice.getStr(\"state\"))) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (\"active\".equals(replica.getStr(\"state\"))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (ZkStateReader.ACTIVE.equals(replica.getStr(ZkStateReader.STATE_PROP))) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b","date":1432801743,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n      \n      waitForRecoveriesToFinish(collectionName, false);\n      \n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n      \n      Slice shard1 = null;\n      Replica replica1 = null;\n      \n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = getHttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = getHttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = new HttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"609b19bb8de96c4e5e338d1d4a0349957522b601","date":1474892114,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(cluster.getSolrClient());\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = getHttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(cluster.getSolrClient());\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = getHttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(cluster.getSolrClient());\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void deleteLiveReplicaTest() throws Exception {\n    String collectionName = \"delLiveColl\";\n    try (CloudSolrClient client = createCloudClient(null)) {\n      createCollection(collectionName, client);\n\n      waitForRecoveriesToFinish(collectionName, false);\n\n      DocCollection testcoll = getCommonCloudSolrClient().getZkStateReader()\n          .getClusterState().getCollection(collectionName);\n\n      Slice shard1 = null;\n      Replica replica1 = null;\n\n      // Get an active replica\n      for (Slice slice : testcoll.getSlices()) {\n        if(replica1 != null)\n          break;\n        if (slice.getState() == Slice.State.ACTIVE) {\n          shard1 = slice;\n          for (Replica replica : shard1.getReplicas()) {\n            if (replica.getState() == Replica.State.ACTIVE) {\n              replica1 = replica;\n              break;\n            }\n          }\n        }\n      }\n\n      if (replica1 == null) fail(\"no active replicas found\");\n\n      String dataDir = null;\n      try (HttpSolrClient replica1Client = getHttpSolrClient(replica1.getStr(\"base_url\"))) {\n        CoreAdminResponse status = CoreAdminRequest.getStatus(replica1.getStr(\"core\"), replica1Client);\n        NamedList<Object> coreStatus = status.getCoreStatus(replica1.getStr(\"core\"));\n        dataDir = (String) coreStatus.get(\"dataDir\");\n      }\n      try {\n        // Should not be able to delete a replica that is up if onlyIfDown=true.\n        tryToRemoveOnlyIfDown(collectionName, client, replica1, shard1.getName());\n        fail(\"Should have thrown an exception here because the replica is NOT down\");\n      } catch (SolrException se) {\n        assertEquals(\"Should see 400 here \", se.code(), 400);\n        assertTrue(\"Expected DeleteReplica to fail because node state is 'active' but returned message was: \" + se.getMessage(), se.getMessage().contains(\"with onlyIfDown='true', but state is 'active'\"));\n        // This bit is a little weak in that if we're screwing up and actually deleting the replica, we might get back\n        // here _before_ the datadir is deleted. But I'd rather not introduce a delay here.\n        assertTrue(\"dataDir for \" + replica1.getName() + \" should NOT have been deleted by deleteReplica API with onlyIfDown='true'\",\n            new File(dataDir).exists());\n      }\n\n      removeAndWaitForReplicaGone(collectionName, client, replica1, shard1.getName());\n      assertFalse(\"dataDir for \" + replica1.getName() + \" should have been deleted by deleteReplica API\", new File(dataDir).exists());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28ba172425e443e0f08a49de6d73586c418d7251","date":1523970991,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(cluster.getSolrClient());\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(cluster.getSolrClient());\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(cluster.getSolrClient());\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","bugFix":["609b19bb8de96c4e5e338d1d4a0349957522b601"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b20c6095d6927417de0b4b8161d5b79675ccb906","date":1554136053,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  // commented out on: 01-Apr-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b366e7dd3172289251a86be96031af4002cd19c","date":1560790783,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  // commented out on: 01-Apr-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<DocCollectionWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 01-Apr-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d38e0eaeb5a3c858d8d4892a6961883aabf161","date":1563030169,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteLiveReplicaTest().mjava","sourceNew":"  @Test\n  // commented out on: 01-Apr-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    \n    // don't choose the leader to shutdown, it just complicates things unneccessarily\n    Replica replica = getRandomReplica(shard, (r) ->\n                                       ( r.getState() == Replica.State.ACTIVE &&\n                                         ! r.equals(shard.getLeader())));\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n\n    final long preDeleteWatcherCount = countUnloadCoreOnDeletedWatchers\n      (accessor.getStateWatchers(collectionName));\n    \n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    \n    // the core should no longer have a watch collection state since it was removed\n    // the core should no longer have a watch collection state since it was removed\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for core's watcher to be removed\", () -> {\n        final long postDeleteWatcherCount = countUnloadCoreOnDeletedWatchers\n          (accessor.getStateWatchers(collectionName));\n        log.info(\"preDeleteWatcherCount={} vs postDeleteWatcherCount={}\",\n                 preDeleteWatcherCount, postDeleteWatcherCount);\n        return (preDeleteWatcherCount - 1L == postDeleteWatcherCount);\n      });\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 01-Apr-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void deleteLiveReplicaTest() throws Exception {\n\n    final String collectionName = \"delLiveColl\";\n\n    Create req = CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2);\n    req.process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection state = getCollectionState(collectionName);\n    Slice shard = getRandomShard(state);\n    Replica replica = getRandomReplica(shard, (r) -> r.getState() == Replica.State.ACTIVE);\n\n    CoreStatus coreStatus = getCoreStatus(replica);\n    Path dataDir = Paths.get(coreStatus.getDataDirectory());\n\n    Exception e = expectThrows(Exception.class, () -> {\n      CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n          .setOnlyIfDown(true)\n          .process(cluster.getSolrClient());\n    });\n    assertTrue(\"Unexpected error message: \" + e.getMessage(), e.getMessage().contains(\"state is 'active'\"));\n    assertTrue(\"Data directory for \" + replica.getName() + \" should not have been deleted\", Files.exists(dataDir));\n\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<DocCollectionWatcher> watchers = accessor.getStateWatchers(collectionName);\n    CollectionAdminRequest.deleteReplica(collectionName, shard.getName(), replica.getName())\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected replica \" + replica.getName() + \" to have been removed\", collectionName, (n, c) -> {\n      Slice testShard = c.getSlice(shard.getName());\n      return testShard.getReplica(replica.getName()) == null;\n    });\n    // the core no longer watch collection state since it was removed\n    assertEquals(watchers.size() - 1, accessor.getStateWatchers(collectionName).size());\n\n    assertFalse(\"Data directory for \" + replica.getName() + \" should have been removed\", Files.exists(dataDir));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d5a2b742df77744d3f370c51ae4d86e71f6802e9":["a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c"],"b20c6095d6927417de0b4b8161d5b79675ccb906":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["28ba172425e443e0f08a49de6d73586c418d7251"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["e17fc5a261478b4a4b6978d5c96fb65ae590faf4"],"abb23fcc2461782ab204e61213240feb77d355aa":["bafca15d8e408346a67f4282ad1143b88023893b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b"],"7b366e7dd3172289251a86be96031af4002cd19c":["b20c6095d6927417de0b4b8161d5b79675ccb906"],"bafca15d8e408346a67f4282ad1143b88023893b":["dd657606b6786db7b4cf5f88ce642f11168d5437"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":["cd548b14f1051e707393e77329f80c5e89f69919","8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"0c924d4069ef5a5bc479a493befe0121aada6896":["e17fc5a261478b4a4b6978d5c96fb65ae590faf4","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"b896234cdca0b42c82da86ef5ea4cff3304386b9":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","609b19bb8de96c4e5e338d1d4a0349957522b601"],"609b19bb8de96c4e5e338d1d4a0349957522b601":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["abb23fcc2461782ab204e61213240feb77d355aa"],"a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c":["d23ef77430304e87e9feffc67378b4f4e536b9f4"],"cd548b14f1051e707393e77329f80c5e89f69919":["d5a2b742df77744d3f370c51ae4d86e71f6802e9"],"dd657606b6786db7b4cf5f88ce642f11168d5437":["fdbe605f0d40f92b9fa92baa735e60b6e445c182"],"fdbe605f0d40f92b9fa92baa735e60b6e445c182":["69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735"],"e17fc5a261478b4a4b6978d5c96fb65ae590faf4":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"d0d38e0eaeb5a3c858d8d4892a6961883aabf161":["7b366e7dd3172289251a86be96031af4002cd19c"],"d23ef77430304e87e9feffc67378b4f4e536b9f4":["b896234cdca0b42c82da86ef5ea4cff3304386b9"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c","cd548b14f1051e707393e77329f80c5e89f69919"],"28ba172425e443e0f08a49de6d73586c418d7251":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["cd548b14f1051e707393e77329f80c5e89f69919"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0d38e0eaeb5a3c858d8d4892a6961883aabf161"]},"commit2Childs":{"d5a2b742df77744d3f370c51ae4d86e71f6802e9":["cd548b14f1051e707393e77329f80c5e89f69919"],"b20c6095d6927417de0b4b8161d5b79675ccb906":["7b366e7dd3172289251a86be96031af4002cd19c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0c924d4069ef5a5bc479a493befe0121aada6896","a219f1dcad1700e84807666bdbd2b573e8de7021"],"abb23fcc2461782ab204e61213240feb77d355aa":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bafca15d8e408346a67f4282ad1143b88023893b":["abb23fcc2461782ab204e61213240feb77d355aa"],"7b366e7dd3172289251a86be96031af4002cd19c":["d0d38e0eaeb5a3c858d8d4892a6961883aabf161"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":[],"8d35c84fdef07284c122012ca4000d3b7285a66e":["b20c6095d6927417de0b4b8161d5b79675ccb906"],"69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735":["fdbe605f0d40f92b9fa92baa735e60b6e445c182"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"a219f1dcad1700e84807666bdbd2b573e8de7021":["2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b"],"b896234cdca0b42c82da86ef5ea4cff3304386b9":["d23ef77430304e87e9feffc67378b4f4e536b9f4"],"2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","28ba172425e443e0f08a49de6d73586c418d7251"],"609b19bb8de96c4e5e338d1d4a0349957522b601":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["e17fc5a261478b4a4b6978d5c96fb65ae590faf4"],"a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c":["d5a2b742df77744d3f370c51ae4d86e71f6802e9","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd548b14f1051e707393e77329f80c5e89f69919":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","74f45af4339b0daf7a95c820ab88c1aea74fbce0","8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"dd657606b6786db7b4cf5f88ce642f11168d5437":["bafca15d8e408346a67f4282ad1143b88023893b"],"fdbe605f0d40f92b9fa92baa735e60b6e445c182":["dd657606b6786db7b4cf5f88ce642f11168d5437"],"e17fc5a261478b4a4b6978d5c96fb65ae590faf4":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d0d38e0eaeb5a3c858d8d4892a6961883aabf161":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d23ef77430304e87e9feffc67378b4f4e536b9f4":["a6a0f1f584dd5d0d16584dd51a3817e7145f4d7c"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","609b19bb8de96c4e5e338d1d4a0349957522b601","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"28ba172425e443e0f08a49de6d73586c418d7251":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["b896234cdca0b42c82da86ef5ea4cff3304386b9"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","0c924d4069ef5a5bc479a493befe0121aada6896","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}