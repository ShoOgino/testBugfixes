{"path":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","sourceNew":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random.nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n    }\n    \n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","sourceOld":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random.nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n    }\n    \n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","sourceNew":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n    }\n    \n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","sourceOld":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random.nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n    }\n    \n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6","date":1338921900,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","sourceNew":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","sourceOld":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n    }\n    \n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0dfae671422e7453a9199aa320f91427cd80d60","date":1427895926,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","sourceNew":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r, IndexReader previous) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","sourceOld":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","sourceNew":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r, IndexReader previous) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","sourceOld":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b516a692d03225c8f0e81a13ceed2dc32bb457d","date":1453411951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#doAfterWriter(ExecutorService).mjava","sourceNew":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r, IndexReader previous) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","sourceOld":"  @Override\n  protected void doAfterWriter(final ExecutorService es) throws Exception {\n    final SearcherFactory factory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader r, IndexReader previous) throws IOException {\n        IndexSearcher s = new IndexSearcher(r, es);\n        TestSearcherManager.this.warmCalled = true;\n        s.search(new TermQuery(new Term(\"body\", \"united\")), 10);\n        return s;\n      }\n    };\n    if (random().nextBoolean()) {\n      // TODO: can we randomize the applyAllDeletes?  But\n      // somehow for final searcher we must apply\n      // deletes...\n      mgr = new SearcherManager(writer, true, factory);\n      isNRT = true;\n    } else {\n      // SearcherManager needs to see empty commit:\n      writer.commit();\n      mgr = new SearcherManager(dir, factory);\n      isNRT = false;\n      assertMergedSegmentsWarmed = false;\n    }\n\n    lifetimeMGR = new SearcherLifetimeManager();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e0dfae671422e7453a9199aa320f91427cd80d60":["006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["e0dfae671422e7453a9199aa320f91427cd80d60"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"0c924d4069ef5a5bc479a493befe0121aada6896":["006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6","e0dfae671422e7453a9199aa320f91427cd80d60"]},"commit2Childs":{"e0dfae671422e7453a9199aa320f91427cd80d60":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","0c924d4069ef5a5bc479a493befe0121aada6896"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6"],"006983b76dd6b28fd7aa0c8e9d44484d5ebaaca6":["e0dfae671422e7453a9199aa320f91427cd80d60","0c924d4069ef5a5bc479a493befe0121aada6896"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0c924d4069ef5a5bc479a493befe0121aada6896":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0c924d4069ef5a5bc479a493befe0121aada6896"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}