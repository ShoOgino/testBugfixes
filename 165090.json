{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter#slowSynFilter(String,List[OneSyn],boolean).mjava","commits":[{"id":"24a98f5fdd23e04f85819dbc63b47a12f7c44311","date":1482439157,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter#slowSynFilter(String,List[OneSyn],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Stupid, slow brute-force, yet hopefully bug-free, synonym filter. */\n  private Automaton slowSynFilter(String doc, List<OneSyn> syns, boolean flatten) {\n    String[] tokens = doc.split(\" +\");\n    if (VERBOSE) {\n      System.out.println(\"  doc has \" + tokens.length + \" tokens\");\n    }\n    int i=0;\n    Automaton.Builder a = new Automaton.Builder();\n    int lastState = a.createState();\n    while (i<tokens.length) {\n      // Consider all possible syn matches starting at this point:\n      assert tokens[i].length() == 1;\n      if (VERBOSE) {\n        System.out.println(\"    i=\" + i);\n      }\n\n      List<OneSyn> matches = new ArrayList<>();\n      for(OneSyn syn : syns) {\n        if (i + syn.in.length <= tokens.length) {\n          boolean match = true;\n          for(int j=0;j<syn.in.length;j++) {\n            if (tokens[i+j].charAt(0) != syn.in[j]) {\n              match = false;\n              break;\n            }\n          }\n\n          if (match) {\n            if (matches.isEmpty() == false) {\n              if (syn.in.length < matches.get(0).in.length) {\n                // Greedy matching: we already found longer syns matching here\n                continue;\n              } else if (syn.in.length > matches.get(0).in.length) {\n                // Greedy matching: all previous matches were shorter, so we drop them\n                matches.clear();\n              } else {\n                // Keep the current matches: we allow multiple synonyms matching the same input string\n              }\n            }\n\n            matches.add(syn);\n          }\n        }\n      }\n\n      int nextState = a.createState();\n\n      if (matches.isEmpty() == false) {\n        // We have match(es) starting at this token\n        if (VERBOSE) {\n          System.out.println(\"  matches @ i=\" + i + \": \" + matches);\n        }\n        // We keepOrig if any of the matches said to:\n        boolean keepOrig = false;\n        for(OneSyn syn : matches) {\n          keepOrig |= syn.keepOrig;\n        }\n\n        List<Integer> flatStates;\n        if (flatten) {\n          flatStates = new ArrayList<>();\n        } else {\n          flatStates = null;\n        }\n\n        if (keepOrig) {\n          // Add path for the original tokens\n          addSidePath(a, lastState, nextState, matches.get(0).in, flatStates);\n        }\n\n        for(OneSyn syn : matches) {\n          addSidePath(a, lastState, nextState, syn.out, flatStates);\n        }\n\n        i += matches.get(0).in.length;\n      } else {\n        a.addTransition(lastState, nextState, tokens[i].charAt(0));\n        i++;\n      }\n\n      lastState = nextState;\n    }\n\n    a.setAccept(lastState, true);\n\n    return topoSort(a.finish());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter#slowSynFilter(String,List[OneSyn],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Stupid, slow brute-force, yet hopefully bug-free, synonym filter. */\n  private Automaton slowSynFilter(String doc, List<OneSyn> syns, boolean flatten) {\n    String[] tokens = doc.split(\" +\");\n    if (VERBOSE) {\n      System.out.println(\"  doc has \" + tokens.length + \" tokens\");\n    }\n    int i=0;\n    Automaton.Builder a = new Automaton.Builder();\n    int lastState = a.createState();\n    while (i<tokens.length) {\n      // Consider all possible syn matches starting at this point:\n      assert tokens[i].length() == 1;\n      if (VERBOSE) {\n        System.out.println(\"    i=\" + i);\n      }\n\n      List<OneSyn> matches = new ArrayList<>();\n      for(OneSyn syn : syns) {\n        if (i + syn.in.length <= tokens.length) {\n          boolean match = true;\n          for(int j=0;j<syn.in.length;j++) {\n            if (tokens[i+j].charAt(0) != syn.in[j]) {\n              match = false;\n              break;\n            }\n          }\n\n          if (match) {\n            if (matches.isEmpty() == false) {\n              if (syn.in.length < matches.get(0).in.length) {\n                // Greedy matching: we already found longer syns matching here\n                continue;\n              } else if (syn.in.length > matches.get(0).in.length) {\n                // Greedy matching: all previous matches were shorter, so we drop them\n                matches.clear();\n              } else {\n                // Keep the current matches: we allow multiple synonyms matching the same input string\n              }\n            }\n\n            matches.add(syn);\n          }\n        }\n      }\n\n      int nextState = a.createState();\n\n      if (matches.isEmpty() == false) {\n        // We have match(es) starting at this token\n        if (VERBOSE) {\n          System.out.println(\"  matches @ i=\" + i + \": \" + matches);\n        }\n        // We keepOrig if any of the matches said to:\n        boolean keepOrig = false;\n        for(OneSyn syn : matches) {\n          keepOrig |= syn.keepOrig;\n        }\n\n        List<Integer> flatStates;\n        if (flatten) {\n          flatStates = new ArrayList<>();\n        } else {\n          flatStates = null;\n        }\n\n        if (keepOrig) {\n          // Add path for the original tokens\n          addSidePath(a, lastState, nextState, matches.get(0).in, flatStates);\n        }\n\n        for(OneSyn syn : matches) {\n          addSidePath(a, lastState, nextState, syn.out, flatStates);\n        }\n\n        i += matches.get(0).in.length;\n      } else {\n        a.addTransition(lastState, nextState, tokens[i].charAt(0));\n        i++;\n      }\n\n      lastState = nextState;\n    }\n\n    a.setAccept(lastState, true);\n\n    return topoSort(a.finish());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24a98f5fdd23e04f85819dbc63b47a12f7c44311"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","24a98f5fdd23e04f85819dbc63b47a12f7c44311"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a98f5fdd23e04f85819dbc63b47a12f7c44311","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}