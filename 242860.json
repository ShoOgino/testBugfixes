{"path":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      IndexOutput out = directory().createOutput(si.getNormFileName(this.number));\n      try {\n        out.writeBytes(bytes, maxDoc());\n      } finally {\n        out.close();\n      }\n      this.dirty = false;\n    }\n\n","sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      IndexOutput out = directory().createOutput(si.getNormFileName(this.number));\n      try {\n        out.writeBytes(bytes, maxDoc());\n      } finally {\n        out.close();\n      }\n      this.dirty = false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1085ea837da8f1e96697e17cf73e1d08e7329261","date":1281469548,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      IndexOutput out = directory().createOutput(si.getNormFileName(this.number));\n      try {\n        out.writeBytes(bytes, maxDoc());\n      } finally {\n        out.close();\n      }\n      this.dirty = false;\n    }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      IndexOutput out = directory().createOutput(si.getNormFileName(this.number));\n      try {\n        out.writeBytes(bytes, maxDoc());\n      } finally {\n        out.close();\n      }\n      this.dirty = false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7843edbf325fe98ea91515ee3ff56ab40a9594d","date":1305742986,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(SegmentMerger.NORMS_HEADER, 0, SegmentMerger.NORMS_HEADER.length);\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b5e0eebe355b14693e24007d721da78a79d8170","date":1305898401,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":null,"sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(SegmentMerger.NORMS_HEADER, 0, SegmentMerger.NORMS_HEADER.length);\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":null,"sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","date":1306150983,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentReader.Norm#reWrite(SegmentInfo).mjava","sourceNew":null,"sourceOld":"    // Flush all pending changes to the next generation\n    // separate norms file.\n    public void reWrite(SegmentInfo si) throws IOException {\n      assert refCount > 0 && (origNorm == null || origNorm.refCount > 0): \"refCount=\" + refCount + \" origNorm=\" + origNorm;\n\n      // NOTE: norms are re-written in regular directory, not cfs\n      si.advanceNormGen(this.number);\n      final String normFileName = si.getNormFileName(this.number);\n      IndexOutput out = directory().createOutput(normFileName);\n      boolean success = false;\n      try {\n        try {\n          out.writeBytes(bytes, maxDoc());\n        } finally {\n          out.close();\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          try {\n            directory().deleteFile(normFileName);\n          } catch (Throwable t) {\n            // suppress this so we keep throwing the\n            // original exception\n          }\n        }\n      }\n      this.dirty = false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b5e0eebe355b14693e24007d721da78a79d8170":["c7843edbf325fe98ea91515ee3ff56ab40a9594d"],"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a":["1085ea837da8f1e96697e17cf73e1d08e7329261","8b5e0eebe355b14693e24007d721da78a79d8170"],"1085ea837da8f1e96697e17cf73e1d08e7329261":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a3776dccca01c11e7046323cfad46a3b4a471233":["1085ea837da8f1e96697e17cf73e1d08e7329261","8b5e0eebe355b14693e24007d721da78a79d8170"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","1085ea837da8f1e96697e17cf73e1d08e7329261"],"c7843edbf325fe98ea91515ee3ff56ab40a9594d":["1085ea837da8f1e96697e17cf73e1d08e7329261"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b5e0eebe355b14693e24007d721da78a79d8170"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"8b5e0eebe355b14693e24007d721da78a79d8170":["5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a":[],"1085ea837da8f1e96697e17cf73e1d08e7329261":["5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","a3776dccca01c11e7046323cfad46a3b4a471233","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c7843edbf325fe98ea91515ee3ff56ab40a9594d"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"c7843edbf325fe98ea91515ee3ff56ab40a9594d":["8b5e0eebe355b14693e24007d721da78a79d8170"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["1085ea837da8f1e96697e17cf73e1d08e7329261","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","a3776dccca01c11e7046323cfad46a3b4a471233","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}