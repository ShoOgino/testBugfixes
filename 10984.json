{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ConcatenateGraphFilter#replaceSep(Automaton,Character).mjava","commits":[{"id":"5533de9a942219a587ac7abed8c65796531dc16d","date":1573756010,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ConcatenateGraphFilter#replaceSep(Automaton,Character).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ConcatenateGraphFilter#replaceSep(Automaton,boolean,int).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, Character tokenSeparator) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (tokenSeparator != null) {\n            // Remap to tokenSeparator:\n            result.addTransition(state, t.dest, tokenSeparator);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5533de9a942219a587ac7abed8c65796531dc16d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5533de9a942219a587ac7abed8c65796531dc16d"]},"commit2Childs":{"5533de9a942219a587ac7abed8c65796531dc16d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5533de9a942219a587ac7abed8c65796531dc16d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}