{"path":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(CloudSolrClient,List[String],List[String],List[String],String).mjava","commits":[{"id":"d984627825732e682759c22df7a3b171a80f3812","date":1461857653,"type":0,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(CloudSolrClient,List[String],List[String],List[String],String).mjava","pathOld":"/dev/null","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param cloudSolrClient Solr CloudSolrClient\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final CloudSolrClient cloudSolrClient, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      String DEFAULT_SORT_FIELD = \"_version_\";\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n//    if (limit != null) {\n//      queryBuilder.append(\" LIMIT \").append(limit);\n//    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(cloudSolrClient.getZkHost(), collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99c8e9b44b0cdc8162d6e058914bac3148e80da9","date":1461873164,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(CloudSolrClient,List[String],List[String],List[String],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(CloudSolrClient,List[String],List[String],List[String],String).mjava","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param cloudSolrClient Solr CloudSolrClient\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final CloudSolrClient cloudSolrClient, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(cloudSolrClient.getZkHost(), collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","sourceOld":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param cloudSolrClient Solr CloudSolrClient\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final CloudSolrClient cloudSolrClient, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      String DEFAULT_SORT_FIELD = \"_version_\";\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n//    if (limit != null) {\n//      queryBuilder.append(\" LIMIT \").append(limit);\n//    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(cloudSolrClient.getZkHost(), collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a69e2a486e794ef99347d76fd562d069f922d1ce","date":1461874102,"type":5,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(String,List[String],List[String],List[String],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(CloudSolrClient,List[String],List[String],List[String],String).mjava","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param zk Solr ZooKeeper connection string\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final String zk, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(zk, collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","sourceOld":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param cloudSolrClient Solr CloudSolrClient\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final CloudSolrClient cloudSolrClient, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(cloudSolrClient.getZkHost(), collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"99c8e9b44b0cdc8162d6e058914bac3148e80da9":["d984627825732e682759c22df7a3b171a80f3812"],"a69e2a486e794ef99347d76fd562d069f922d1ce":["99c8e9b44b0cdc8162d6e058914bac3148e80da9"],"d984627825732e682759c22df7a3b171a80f3812":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"99c8e9b44b0cdc8162d6e058914bac3148e80da9":["a69e2a486e794ef99347d76fd562d069f922d1ce"],"d984627825732e682759c22df7a3b171a80f3812":["99c8e9b44b0cdc8162d6e058914bac3148e80da9"],"a69e2a486e794ef99347d76fd562d069f922d1ce":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d984627825732e682759c22df7a3b171a80f3812","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a69e2a486e794ef99347d76fd562d069f922d1ce","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}