{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        assert !hasExternalSegments();\n        \n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        assert !hasExternalSegments();\n        \n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb10b6bcde550b87d8f10e5f010bd8f3021023b6","date":1274974592,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        assert !hasExternalSegments();\n        \n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"257da767277782760db0814096b999899995b2b1","date":1289498882,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e1cbd7e289dc1243c7a59e1a83d078163a147fe","date":1292268032,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    docWriter.pauseAllThreads();\n\n    try {\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          docWriter.resumeAllThreads();\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86c34ea6a885f625f2e464756450d45b72653ef3","date":1295256222,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        bufferedDeletes.clear();\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletes.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n\n        bufferedDeletes.clear();\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"786a4d25ca958a1f315a9d6a74f0441fdafcd522","date":1305734256,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"850aca8525380ccb7df9626d7caa89678005dd31","date":1307569142,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream != null ) {\n          message(\"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream != null ) {\n          message(\"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream != null ) {\n          message(\"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream != null ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      message(\"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        message(\"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream != null ) {\n          message(\"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            message(\"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58c6bbc222f074c844e736e6fb23647e3db9cfe3","date":1322743940,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    infoStream.message(\"IW\", \"rollback\");\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      infoStream.message(\"IW\", \"rollback: done finish merges\");\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          infoStream.message(\"IW\", \"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream != null ) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream != null ) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream != null ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream != null)\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    infoStream.message(\"IW\", \"rollback\");\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      infoStream.message(\"IW\", \"rollback: done finish merges\");\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          infoStream.message(\"IW\", \"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    infoStream.message(\"IW\", \"rollback\");\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      infoStream.message(\"IW\", \"rollback: done finish merges\");\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          infoStream.message(\"IW\", \"hit exception during rollback\");\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      // Don't bother saving any changes in our segmentInfos\n      readerPool.clear(null);\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollbackInternal().mjava","sourceNew":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","sourceOld":"  private void rollbackInternal() throws IOException {\n\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n\n    try {\n      synchronized(this) {\n        finishMerges(false);\n        stopMerges = true;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      bufferedDeletesStream.clear();\n\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          deleter.decRef(pendingCommit);\n          pendingCommit = null;\n          notifyAll();\n        }\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        docWriter.abort();\n\n        assert testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n      }\n\n      lastCommitChangeCount = changeCount;\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"rollbackInternal\");\n    } finally {\n      synchronized(this) {\n        if (!success) {\n          closing = false;\n          notifyAll();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception during rollback\");\n          }\n        }\n      }\n    }\n\n    closeInternal(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["06584e6e98d592b34e1329b384182f368d2025e8"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["257da767277782760db0814096b999899995b2b1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["58c6bbc222f074c844e736e6fb23647e3db9cfe3","c5df35ab57c223ea11aec64b53bf611904f3dced"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6","7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"c19f985e36a65cc969e8e564fe337a0d41512075":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"257da767277782760db0814096b999899995b2b1":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","c19f985e36a65cc969e8e564fe337a0d41512075"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ce667c6d3400b22523701c549c0d35e26da8b46":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["86c34ea6a885f625f2e464756450d45b72653ef3","c19f985e36a65cc969e8e564fe337a0d41512075"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"850aca8525380ccb7df9626d7caa89678005dd31":["786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a3776dccca01c11e7046323cfad46a3b4a471233","850aca8525380ccb7df9626d7caa89678005dd31"],"06584e6e98d592b34e1329b384182f368d2025e8":["850aca8525380ccb7df9626d7caa89678005dd31"],"85a883878c0af761245ab048babc63d099f835f3":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6","257da767277782760db0814096b999899995b2b1"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["85a883878c0af761245ab048babc63d099f835f3","7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"786a4d25ca958a1f315a9d6a74f0441fdafcd522":["c19f985e36a65cc969e8e564fe337a0d41512075"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["29ef99d61cda9641b6250bf9567329a6e65f901d","786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c19f985e36a65cc969e8e564fe337a0d41512075","786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["c3a8a449466c1ff7ce2274fe73dab487256964b4","850aca8525380ccb7df9626d7caa89678005dd31"],"86c34ea6a885f625f2e464756450d45b72653ef3":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","9ce667c6d3400b22523701c549c0d35e26da8b46"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["86c34ea6a885f625f2e464756450d45b72653ef3"],"c19f985e36a65cc969e8e564fe337a0d41512075":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","786a4d25ca958a1f315a9d6a74f0441fdafcd522","a3776dccca01c11e7046323cfad46a3b4a471233"],"257da767277782760db0814096b999899995b2b1":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff","85a883878c0af761245ab048babc63d099f835f3"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c19f985e36a65cc969e8e564fe337a0d41512075","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"850aca8525380ccb7df9626d7caa89678005dd31":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","06584e6e98d592b34e1329b384182f368d2025e8","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"06584e6e98d592b34e1329b384182f368d2025e8":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"85a883878c0af761245ab048babc63d099f835f3":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","257da767277782760db0814096b999899995b2b1","85a883878c0af761245ab048babc63d099f835f3"],"786a4d25ca958a1f315a9d6a74f0441fdafcd522":["850aca8525380ccb7df9626d7caa89678005dd31","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"86c34ea6a885f625f2e464756450d45b72653ef3":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","bde51b089eb7f86171eb3406e38a274743f9b7ac","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}