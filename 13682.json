{"path":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testFailure().mjava","commits":[{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testFailure().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFailure() throws Exception {\n    final String sourceCollection = \"failReindexing\";\n    final String targetCollection = \"failReindexingTarget\";\n    final String aliasTarget = \"failAlias\";\n    createCollection(sourceCollection, \"conf1\", 2, 2);\n    createCollection(targetCollection, \"conf1\", 1, 1);\n    CollectionAdminRequest.createAlias(aliasTarget, targetCollection).process(solrClient);\n    indexDocs(sourceCollection, NUM_DOCS,\n        i -> new SolrInputDocument(\n            \"id\", String.valueOf(i),\n            \"string_s\", String.valueOf(i)));\n\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    CollectionAdminResponse rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"already exists\"));\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(aliasTarget);\n    rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"already exists\"));\n\n    CollectionAdminRequest.deleteAlias(aliasTarget).process(solrClient);\n    CollectionAdminRequest.deleteCollection(targetCollection).process(solrClient);\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n\n    TestInjection.reindexFailure = \"true:100\";\n    rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"waiting for daemon\"));\n\n    // verify that the target and checkpoint collections don't exist\n    cloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      assertFalse(coll.getName() + \" still exists\", coll.getName().startsWith(ReindexCollectionCmd.TARGET_COL_PREFIX));\n      assertFalse(coll.getName() + \" still exists\", coll.getName().startsWith(ReindexCollectionCmd.CHK_COL_PREFIX));\n    });\n    // verify that the source collection is read-write and has no reindexing flags\n    CloudTestUtils.waitForState(cloudManager, \"collection state is incorrect\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            !collectionState.isReadOnly() &&\n            collectionState.getStr(ReindexCollectionCmd.REINDEXING_STATE) == null &&\n            getState(sourceCollection) == null));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testFailure().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testFailure().mjava","sourceNew":"  @Test\n  public void testFailure() throws Exception {\n    final String sourceCollection = \"failReindexing\";\n    final String targetCollection = \"failReindexingTarget\";\n    final String aliasTarget = \"failAlias\";\n    createCollection(sourceCollection, \"conf1\", 2, 2);\n    createCollection(targetCollection, \"conf1\", 1, 1);\n    CollectionAdminRequest.createAlias(aliasTarget, targetCollection).process(solrClient);\n    indexDocs(sourceCollection, NUM_DOCS,\n        i -> new SolrInputDocument(\n            \"id\", String.valueOf(i),\n            \"string_s\", String.valueOf(i)));\n\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    CollectionAdminResponse rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"already exists\"));\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(aliasTarget);\n    rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"already exists\"));\n\n    CollectionAdminRequest.deleteAlias(aliasTarget).process(solrClient);\n    CollectionAdminRequest.deleteCollection(targetCollection).process(solrClient);\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n\n    TestInjection.reindexFailure = \"true:100\";\n    rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"waiting for daemon\"));\n\n    // verify that the target and checkpoint collections don't exist\n    cloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      assertFalse(coll.getName() + \" still exists\", coll.getName().startsWith(ReindexCollectionCmd.TARGET_COL_PREFIX));\n      assertFalse(coll.getName() + \" still exists\", coll.getName().startsWith(ReindexCollectionCmd.CHK_COL_PREFIX));\n    });\n    // verify that the source collection is read-write and has no reindexing flags\n    CloudUtil.waitForState(cloudManager, \"collection state is incorrect\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            !collectionState.isReadOnly() &&\n            collectionState.getStr(ReindexCollectionCmd.REINDEXING_STATE) == null &&\n            getState(sourceCollection) == null));\n  }\n\n","sourceOld":"  @Test\n  public void testFailure() throws Exception {\n    final String sourceCollection = \"failReindexing\";\n    final String targetCollection = \"failReindexingTarget\";\n    final String aliasTarget = \"failAlias\";\n    createCollection(sourceCollection, \"conf1\", 2, 2);\n    createCollection(targetCollection, \"conf1\", 1, 1);\n    CollectionAdminRequest.createAlias(aliasTarget, targetCollection).process(solrClient);\n    indexDocs(sourceCollection, NUM_DOCS,\n        i -> new SolrInputDocument(\n            \"id\", String.valueOf(i),\n            \"string_s\", String.valueOf(i)));\n\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    CollectionAdminResponse rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"already exists\"));\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(aliasTarget);\n    rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"already exists\"));\n\n    CollectionAdminRequest.deleteAlias(aliasTarget).process(solrClient);\n    CollectionAdminRequest.deleteCollection(targetCollection).process(solrClient);\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n\n    TestInjection.reindexFailure = \"true:100\";\n    rsp = req.process(solrClient);\n    assertNotNull(rsp.getResponse().get(\"error\"));\n    assertTrue(rsp.toString(), rsp.getResponse().get(\"error\").toString().contains(\"waiting for daemon\"));\n\n    // verify that the target and checkpoint collections don't exist\n    cloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      assertFalse(coll.getName() + \" still exists\", coll.getName().startsWith(ReindexCollectionCmd.TARGET_COL_PREFIX));\n      assertFalse(coll.getName() + \" still exists\", coll.getName().startsWith(ReindexCollectionCmd.CHK_COL_PREFIX));\n    });\n    // verify that the source collection is read-write and has no reindexing flags\n    CloudTestUtils.waitForState(cloudManager, \"collection state is incorrect\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            !collectionState.isReadOnly() &&\n            collectionState.getStr(ReindexCollectionCmd.REINDEXING_STATE) == null &&\n            getState(sourceCollection) == null));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"]},"commit2Childs":{"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}