{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient#processErrorsAndResponse(Response,ResponseParser,InputStream,String,boolean).mjava","commits":[{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient#processErrorsAndResponse(Response,ResponseParser,InputStream,String,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      // handle some http level checks before trying to parse the response\n      int httpStatus = response.getStatus();\n\n      String contentType;\n      contentType = response.getHeaders().get(\"content-type\");\n      if (contentType == null) contentType = \"\";\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || \"\".equals(contentType)) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if (reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n            metadata = (NamedList<String>) err.get(\"metadata\");\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          try {\n            reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n          } catch (UnsupportedEncodingException e) {\n          }\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          // quitely\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["664c02a9f8ee4f39f4731f071c69e1932178f381"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba4636b043a2611cc1c43bad730a78b6d5bc4a5f","date":1589320207,"type":5,"author":"Samuel García Martínez","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient#processErrorsAndResponse(Response,ResponseParser,InputStream,String,String,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient#processErrorsAndResponse(Response,ResponseParser,InputStream,String,boolean).mjava","sourceNew":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String mimeType,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      // handle some http level checks before trying to parse the response\n      int httpStatus = response.getStatus();\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || mimeType == null) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          String exceptionEncoding = encoding != null? encoding : FALLBACK_CHARSET.name();\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, exceptionEncoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionEncoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if (reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n            metadata = (NamedList<String>) err.get(\"metadata\");\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          // quitely\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      // handle some http level checks before trying to parse the response\n      int httpStatus = response.getStatus();\n\n      String contentType;\n      contentType = response.getHeaders().get(\"content-type\");\n      if (contentType == null) contentType = \"\";\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || \"\".equals(contentType)) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if (reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n            metadata = (NamedList<String>) err.get(\"metadata\");\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          try {\n            reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n          } catch (UnsupportedEncodingException e) {\n          }\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          // quitely\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba4636b043a2611cc1c43bad730a78b6d5bc4a5f"],"ba4636b043a2611cc1c43bad730a78b6d5bc4a5f":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["ba4636b043a2611cc1c43bad730a78b6d5bc4a5f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"ba4636b043a2611cc1c43bad730a78b6d5bc4a5f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}