{"path":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","commits":[{"id":"69a6d2d525aeab53c867ed26934185e5bb627d0e","date":1296516902,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    IndexSearcher searcher = new IndexSearcher(reader);\n    assert searcher.getTopReaderContext().isAtomic;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n    try {\n      for (QueryAndLimit ent : queriesIter) {\n        Query query = ent.query;\n        int limit = ent.limit;\n        Weight weight = query.weight(searcher);\n        Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n        if (scorer != null) {\n          while(true)  {\n            int doc = scorer.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    } finally {\n      searcher.close();\n    }\n\n    return delCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    IndexSearcher searcher = new IndexSearcher(reader);\n    assert searcher.getTopReaderContext().isAtomic;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n    try {\n      for (QueryAndLimit ent : queriesIter) {\n        Query query = ent.query;\n        int limit = ent.limit;\n        Weight weight = query.weight(searcher);\n        Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n        if (scorer != null) {\n          while(true)  {\n            int doc = scorer.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    } finally {\n      searcher.close();\n    }\n\n    return delCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    IndexSearcher searcher = new IndexSearcher(reader);\n    assert searcher.getTopReaderContext().isAtomic;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n    try {\n      for (QueryAndLimit ent : queriesIter) {\n        Query query = ent.query;\n        int limit = ent.limit;\n        Weight weight = query.weight(searcher);\n        Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n        if (scorer != null) {\n          while(true)  {\n            int doc = scorer.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    } finally {\n      searcher.close();\n    }\n\n    return delCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7fee42303a18cc146043c96f66491311b345d9","date":1308246904,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","sourceNew":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext);\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    IndexSearcher searcher = new IndexSearcher(reader);\n    assert searcher.getTopReaderContext().isAtomic;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n    try {\n      for (QueryAndLimit ent : queriesIter) {\n        Query query = ent.query;\n        int limit = ent.limit;\n        Weight weight = query.weight(searcher);\n        Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n        if (scorer != null) {\n          while(true)  {\n            int doc = scorer.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    } finally {\n      searcher.close();\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","sourceNew":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext);\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    IndexSearcher searcher = new IndexSearcher(reader);\n    assert searcher.getTopReaderContext().isAtomic;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n    try {\n      for (QueryAndLimit ent : queriesIter) {\n        Query query = ent.query;\n        int limit = ent.limit;\n        Weight weight = query.weight(searcher);\n        Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n        if (scorer != null) {\n          while(true)  {\n            int doc = scorer.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    } finally {\n      searcher.close();\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d37950af3438a49417b738d4395d64969be903cc","date":1318716035,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext);\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext);\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, readerContext.reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // as we use getLiveDocs() to filter out already deleted documents,\n            // we only delete live documents, so the counting is right:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext);\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // TODO: we could/should change\n            // reader.deleteDocument to return boolean\n            // true if it did in fact delete, because here\n            // we could be deleting an already-deleted doc\n            // which makes this an upper bound:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, readerContext.reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = (AtomicReaderContext) reader.getTopReaderContext();\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, readerContext.reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit)\n              break;\n\n            reader.deleteDocument(doc);\n            // as we use getLiveDocs() to filter out already deleted documents,\n            // we only delete live documents, so the counting is right:\n            delCount++;\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["69a6d2d525aeab53c867ed26934185e5bb627d0e","6f7fee42303a18cc146043c96f66491311b345d9"],"6f7fee42303a18cc146043c96f66491311b345d9":["69a6d2d525aeab53c867ed26934185e5bb627d0e"],"6620df8541b174097b1133a4fc370adb2e570524":["d37950af3438a49417b738d4395d64969be903cc"],"d37950af3438a49417b738d4395d64969be903cc":["6f7fee42303a18cc146043c96f66491311b345d9"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","69a6d2d525aeab53c867ed26934185e5bb627d0e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"69a6d2d525aeab53c867ed26934185e5bb627d0e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["6620df8541b174097b1133a4fc370adb2e570524"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","69a6d2d525aeab53c867ed26934185e5bb627d0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ce667c6d3400b22523701c549c0d35e26da8b46"]},"commit2Childs":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"6f7fee42303a18cc146043c96f66491311b345d9":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d37950af3438a49417b738d4395d64969be903cc"],"6620df8541b174097b1133a4fc370adb2e570524":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"d37950af3438a49417b738d4395d64969be903cc":["6620df8541b174097b1133a4fc370adb2e570524"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","69a6d2d525aeab53c867ed26934185e5bb627d0e","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"69a6d2d525aeab53c867ed26934185e5bb627d0e":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","6f7fee42303a18cc146043c96f66491311b345d9","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}