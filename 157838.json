{"path":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2eaa5d4d2618a012373ae4574ebb6563933aa9f6","date":1331337973,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a9119f665d52b16e936bb48c5b836609aadbc5","date":1351605383,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90a98516f7d5652f9ba2dbd999fdd97be2a3843","date":1351606421,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"757496f10c991c553a874f78fb06c3f0dc110dff","date":1351616733,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"136d4e97e5588b3f560e4d157962baa796f6c259","date":1510236334,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += (1.0 / (1.0 + matchLength)); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += (1.0 / (1.0 + matchLength)); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"297201ceb6f93f54f44df6d02cdc988591428b75","date":1510304523,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += (1.0 / (1.0 + matchLength)); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += (1.0 / (1.0 + matchLength)); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9b82182bcb9110d24f7de32032113dbf31606c2","date":1510306998,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += (1.0 / (1.0 + matchLength)); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += (1.0 / (1.0 + matchLength)); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b11b9d5eaf9707760ca5151530830a825197023","date":1525941319,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":null,"sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  private float phraseFreq() throws IOException {\n    if (!initPhrasePositions()) {\n      return 0.0f;\n    }\n    float freq = 0.0f;\n    numMatches = 0;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.top().position; \n    while (advancePP(pp)) {\n      if (hasRpts && !advanceRpts(pp)) {\n        break; // pps exhausted\n      }\n      if (pp.position > next) { // done minimizing current match-length \n        if (matchLength <= slop) {\n          freq += (1.0 / (1.0 + matchLength)); // score match\n          numMatches++;\n          if (!needsScores) {\n            return freq;\n          }\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.top().position;\n        matchLength = end - pp.position;\n      } else {\n        int matchLength2 = end - pp.position;\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += (1.0 / (1.0 + matchLength)); // score match\n      numMatches++;\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3b11b9d5eaf9707760ca5151530830a825197023":["b9b82182bcb9110d24f7de32032113dbf31606c2"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["757496f10c991c553a874f78fb06c3f0dc110dff"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"757496f10c991c553a874f78fb06c3f0dc110dff":["2eaa5d4d2618a012373ae4574ebb6563933aa9f6","d90a98516f7d5652f9ba2dbd999fdd97be2a3843"],"05a9119f665d52b16e936bb48c5b836609aadbc5":["2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"d90a98516f7d5652f9ba2dbd999fdd97be2a3843":["05a9119f665d52b16e936bb48c5b836609aadbc5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b9b82182bcb9110d24f7de32032113dbf31606c2":["297201ceb6f93f54f44df6d02cdc988591428b75"],"297201ceb6f93f54f44df6d02cdc988591428b75":["136d4e97e5588b3f560e4d157962baa796f6c259"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b11b9d5eaf9707760ca5151530830a825197023"],"136d4e97e5588b3f560e4d157962baa796f6c259":["781239fc84d36be12b84e4d3e2618f5f07a182e3"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["38e3b736c7ca086d61b7dbb841c905ee115490da","757496f10c991c553a874f78fb06c3f0dc110dff","05a9119f665d52b16e936bb48c5b836609aadbc5"],"3b11b9d5eaf9707760ca5151530830a825197023":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["136d4e97e5588b3f560e4d157962baa796f6c259"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"757496f10c991c553a874f78fb06c3f0dc110dff":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"05a9119f665d52b16e936bb48c5b836609aadbc5":["d90a98516f7d5652f9ba2dbd999fdd97be2a3843"],"d90a98516f7d5652f9ba2dbd999fdd97be2a3843":["757496f10c991c553a874f78fb06c3f0dc110dff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b9b82182bcb9110d24f7de32032113dbf31606c2":["3b11b9d5eaf9707760ca5151530830a825197023"],"297201ceb6f93f54f44df6d02cdc988591428b75":["b9b82182bcb9110d24f7de32032113dbf31606c2"],"136d4e97e5588b3f560e4d157962baa796f6c259":["297201ceb6f93f54f44df6d02cdc988591428b75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}