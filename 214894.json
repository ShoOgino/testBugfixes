{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","commits":[{"id":"1a9e81d464930e5664da049442e2630d4b9b00d5","date":1330726364,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"/dev/null","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0e05f2a24d572cfb09482deb87b03100ce3af1a7","3620d9ae0597bc9732d139dc0a9dcab381e998e7","e99829242bceda4cf974ec0eb5d82d713615b3da","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"/dev/null","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99829242bceda4cf974ec0eb5d82d713615b3da","date":1337646971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":["3620d9ae0597bc9732d139dc0a9dcab381e998e7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e05f2a24d572cfb09482deb87b03100ce3af1a7","date":1363888591,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f0691f6a1ae412a0f644aea762d99c6166bd937","date":1408901687,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                        \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                        translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                        new DecimalFormat(\"###\").format(cpos / (double) csize * 100));\n                \n              }\n            }\n            \n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6807dcbe2017e1d0ba26f905ac61c25f34dce0ea","date":1408952273,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                        \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                        translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                        Math.round(cpos / (double) csize * 100.));\n                \n              }\n            }\n            \n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                        \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                        translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                        new DecimalFormat(\"###\").format(cpos / (double) csize * 100));\n                \n              }\n            }\n            \n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6e1dc1bb4254226c8d7151b596cc1be40671751","date":1421876355,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                        \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                        translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                        Math.round(cpos / (double) csize * 100.));\n                \n              }\n            }\n            \n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                        \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                        translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                        Math.round(cpos / (double) csize * 100.));\n                \n              }\n            }\n            \n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                        \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                        translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                        Math.round(cpos / (double) csize * 100.));\n                \n              }\n            }\n            \n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            operationAndFlags = (Integer)entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          }  catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"052e752d13b775cc343d0b8588d38be0113b24ba","date":1454626441,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85639ac489df34a1af4df5f84b90b46c12d03152","date":1454627270,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1704c078ec59838c9d95d5bf5738b393b537494","date":1454693901,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd9f6c0ea8e68b9769f3620189f200c9232be6a4","date":1455197557,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b800611029360525d55dc4797bcdfc2a689b7fe","date":1455310686,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.round(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":["954158803de015fe496de937a9c13c9bf3faa62f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"954158803de015fe496de937a9c13c9bf3faa62f","date":1456018521,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":["1b800611029360525d55dc4797bcdfc2a689b7fe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3620d9ae0597bc9732d139dc0a9dcab381e998e7","date":1483825160,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508","1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"268f09ed3a9a9b77003b15a5ae30386dc4e3721f","date":1483992000,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n\n            operationAndFlags = (Integer) entry.get(0);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" + cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6","date":1487775028,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n          \n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n          \n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (SolrException ex) {\n            if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n              throw ex;\n            }\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n          \n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n\n          // if the last operation we replayed had FLAG_GAP set, we want to use that again so we don't lose it\n          // as the flag on the last operation.\n          translog.writeCommit(cmd, operationFlags | (operationAndFlags & ~OPERATION_MASK));\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay {}  active={} starting pos={} inSortedOrder={}\", translog, activeLog, recoveryInfo.positionOfStart, inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                if (log.isInfoEnabled()) {\n                  loglog.info(\n                      \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                      translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                      Math.floor(cpos / (double) csize * 100.));\n                }\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete {}\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery {}\", cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log {}\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit {}\", cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay \" + translog + \" active=\" + activeLog + \" starting pos=\" + recoveryInfo.positionOfStart + \" inSortedOrder=\" + inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                loglog.info(\n                    \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                    translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                    Math.floor(cpos / (double) csize * 100.));\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" + cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" + cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" + cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#doReplay(TransactionLog).mjava","sourceNew":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay {}  active={} starting pos={} inSortedOrder={}\", translog, activeLog, recoveryInfo.positionOfStart, inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                if (log.isInfoEnabled()) {\n                  loglog.info(\n                      \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                      translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                      Math.floor(cpos / (double) csize * 100.));\n                }\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            @SuppressWarnings({\"rawtypes\"})\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete {}\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery {}\", cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log {}\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit {}\", cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","sourceOld":"    public void doReplay(TransactionLog translog) {\n      try {\n        loglog.warn(\"Starting log replay {}  active={} starting pos={} inSortedOrder={}\", translog, activeLog, recoveryInfo.positionOfStart, inSortedOrder);\n        long lastStatusTime = System.nanoTime();\n        if (inSortedOrder) {\n          tlogReader = translog.getSortedReader(recoveryInfo.positionOfStart);\n        } else {\n          tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n        }\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n        UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n        OrderedExecutor executor = inSortedOrder ? null : req.getCore().getCoreContainer().getReplayUpdatesExecutor();\n        AtomicInteger pendingTasks = new AtomicInteger(0);\n        AtomicReference<SolrException> exceptionOnExecuteUpdate = new AtomicReference<>();\n\n        long commitVersion = 0;\n        int operationAndFlags = 0;\n        long nextCount = 0;\n\n        for (; ; ) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            if (nextCount++ % 1000 == 0) {\n              long now = System.nanoTime();\n              if (now - lastStatusTime > STATUS_TIME) {\n                lastStatusTime = now;\n                long cpos = tlogReader.currentPos();\n                long csize = tlogReader.currentSize();\n                if (log.isInfoEnabled()) {\n                  loglog.info(\n                      \"log replay status {} active={} starting pos={} current pos={} current size={} % read={}\",\n                      translog, activeLog, recoveryInfo.positionOfStart, cpos, csize,\n                      Math.floor(cpos / (double) csize * 100.));\n                }\n\n              }\n            }\n\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // about to block all the updates including the tasks in the executor\n                // therefore we must wait for them to be finished\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // from this point, remain updates will be executed in a single thread\n                executor = null;\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (Exception e) {\n            SolrException.log(log, e);\n          }\n\n          if (o == null) break;\n          // fail fast\n          if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List) o;\n            operationAndFlags = (Integer) entry.get(UpdateLog.FLAGS_IDX);\n            int oper = operationAndFlags & OPERATION_MASK;\n            long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE: // fall through to ADD\n              case UpdateLog.ADD: {\n                recoveryInfo.adds++;\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"{} {}\", oper == ADD ? \"add\" : \"update\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete {}\", cmd);\n                execute(cmd, executor, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                recoveryInfo.deleteByQuery++;\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery {}\", cmd);\n                waitForAllUpdatesGetExecuted(pendingTasks);\n                // DBQ will be executed in the same thread\n                execute(cmd, null, pendingTasks, proc, exceptionOnExecuteUpdate);\n                break;\n              }\n              case UpdateLog.COMMIT: {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log {}\", rsp.getException());\n              throw rsp.getException();\n            }\n            if (state == State.REPLAYING) {\n              replayOpsMeter.mark();\n            } else if (state == State.APPLYING_BUFFERED) {\n              applyingBufferedOpsMeter.mark();\n            } else {\n              // XXX should not happen?\n            }\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Exception ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n          assert TestInjection.injectUpdateLogReplayRandomPause();\n        }\n\n        waitForAllUpdatesGetExecuted(pendingTasks);\n        if (exceptionOnExecuteUpdate.get() != null) throw exceptionOnExecuteUpdate.get();\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit {}\", cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n\n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n\n      } finally {\n        if (tlogReader != null) tlogReader.close();\n        translog.decref();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6807dcbe2017e1d0ba26f905ac61c25f34dce0ea":["5f0691f6a1ae412a0f644aea762d99c6166bd937"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","415bbbe7da8065dd3c477bdc3c703c6425622998"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["1455c941cc4ce652efc776fc23471b0e499246f6"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1a9e81d464930e5664da049442e2630d4b9b00d5"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["3620d9ae0597bc9732d139dc0a9dcab381e998e7"],"1455c941cc4ce652efc776fc23471b0e499246f6":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["defa11d88d50ec356d5e7428f1ebc89623e840ac","1455c941cc4ce652efc776fc23471b0e499246f6"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["1a9e81d464930e5664da049442e2630d4b9b00d5","e99829242bceda4cf974ec0eb5d82d713615b3da"],"3620d9ae0597bc9732d139dc0a9dcab381e998e7":["954158803de015fe496de937a9c13c9bf3faa62f"],"2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"b1704c078ec59838c9d95d5bf5738b393b537494":["86290366cefc1b9d4eced13b430858c4a4c0421d","85639ac489df34a1af4df5f84b90b46c12d03152"],"5f0691f6a1ae412a0f644aea762d99c6166bd937":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"be320990bdc77e643388fa801e75017f19289c42":["2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["0e05f2a24d572cfb09482deb87b03100ce3af1a7"],"e99829242bceda4cf974ec0eb5d82d713615b3da":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"ab68488225b6a6c357dda72ed11dedca9914a192":["2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"1b800611029360525d55dc4797bcdfc2a689b7fe":["bd9f6c0ea8e68b9769f3620189f200c9232be6a4"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"c6e1dc1bb4254226c8d7151b596cc1be40671751":["6807dcbe2017e1d0ba26f905ac61c25f34dce0ea"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"954158803de015fe496de937a9c13c9bf3faa62f":["1b800611029360525d55dc4797bcdfc2a689b7fe"],"1a9e81d464930e5664da049442e2630d4b9b00d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["86290366cefc1b9d4eced13b430858c4a4c0421d","85639ac489df34a1af4df5f84b90b46c12d03152"],"0e05f2a24d572cfb09482deb87b03100ce3af1a7":["a6378064655e76cd7b908b1cab4ce425b384b508"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["954158803de015fe496de937a9c13c9bf3faa62f","268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"052e752d13b775cc343d0b8588d38be0113b24ba":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"85639ac489df34a1af4df5f84b90b46c12d03152":["86290366cefc1b9d4eced13b430858c4a4c0421d","052e752d13b775cc343d0b8588d38be0113b24ba"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"a6378064655e76cd7b908b1cab4ce425b384b508":["e99829242bceda4cf974ec0eb5d82d713615b3da"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6"],"bd9f6c0ea8e68b9769f3620189f200c9232be6a4":["85639ac489df34a1af4df5f84b90b46c12d03152"],"f592209545c71895260367152601e9200399776d":["defa11d88d50ec356d5e7428f1ebc89623e840ac","1455c941cc4ce652efc776fc23471b0e499246f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"]},"commit2Childs":{"6807dcbe2017e1d0ba26f905ac61c25f34dce0ea":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"740d649f013f07efbeb73ca854f106c60166e7c0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["415bbbe7da8065dd3c477bdc3c703c6425622998","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"1455c941cc4ce652efc776fc23471b0e499246f6":["740d649f013f07efbeb73ca854f106c60166e7c0","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1a9e81d464930e5664da049442e2630d4b9b00d5"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"3620d9ae0597bc9732d139dc0a9dcab381e998e7":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"b1704c078ec59838c9d95d5bf5738b393b537494":[],"5f0691f6a1ae412a0f644aea762d99c6166bd937":["6807dcbe2017e1d0ba26f905ac61c25f34dce0ea"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"e99829242bceda4cf974ec0eb5d82d713615b3da":["3599646b4d4c346cf74d334813488b8b337b5bf5","a6378064655e76cd7b908b1cab4ce425b384b508"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["5f0691f6a1ae412a0f644aea762d99c6166bd937"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"1b800611029360525d55dc4797bcdfc2a689b7fe":["954158803de015fe496de937a9c13c9bf3faa62f"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6"],"c6e1dc1bb4254226c8d7151b596cc1be40671751":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["1455c941cc4ce652efc776fc23471b0e499246f6","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","defa11d88d50ec356d5e7428f1ebc89623e840ac"],"954158803de015fe496de937a9c13c9bf3faa62f":["3620d9ae0597bc9732d139dc0a9dcab381e998e7","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"1a9e81d464930e5664da049442e2630d4b9b00d5":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3599646b4d4c346cf74d334813488b8b337b5bf5","e99829242bceda4cf974ec0eb5d82d713615b3da"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"0e05f2a24d572cfb09482deb87b03100ce3af1a7":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["598b5d23aa7c9732bf473c21a9cd309c44599394"],"052e752d13b775cc343d0b8588d38be0113b24ba":["85639ac489df34a1af4df5f84b90b46c12d03152"],"85639ac489df34a1af4df5f84b90b46c12d03152":["b1704c078ec59838c9d95d5bf5738b393b537494","1e6acbaae7af722f17204ceccf0f7db5753eccf3","bd9f6c0ea8e68b9769f3620189f200c9232be6a4"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["b1704c078ec59838c9d95d5bf5738b393b537494","1e6acbaae7af722f17204ceccf0f7db5753eccf3","052e752d13b775cc343d0b8588d38be0113b24ba","85639ac489df34a1af4df5f84b90b46c12d03152"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"a6378064655e76cd7b908b1cab4ce425b384b508":["0e05f2a24d572cfb09482deb87b03100ce3af1a7"],"bd9f6c0ea8e68b9769f3620189f200c9232be6a4":["1b800611029360525d55dc4797bcdfc2a689b7fe"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e9017cf144952056066919f1ebc7897ff9bd71b1","b70042a8a492f7054d480ccdd2be9796510d4327","3599646b4d4c346cf74d334813488b8b337b5bf5","b1704c078ec59838c9d95d5bf5738b393b537494","1e6acbaae7af722f17204ceccf0f7db5753eccf3","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}