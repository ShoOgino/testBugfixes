{"path":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","commits":[{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0762b640e0d0d12b6edb96db68986e13145c3484","date":1307575932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f83af14a2a8131b14d7aee6274c740334e0363d3","date":1307579822,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc","date":1308411958,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1ded5d4f5b5e3e5f32bff69cd6fe5e64322a886","date":1308439813,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f2bf10c11daad40c1e46fabd0d414c19a3e605b","date":1310410393,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"459280d4c73660ea582f38afce7968563068fe49","date":1311128716,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5c52ce02dcffaf732180b33fef1231978edae9a","date":1311183857,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ec890fad2ea96317f4429e0aa0085bb25673641","date":1326669938,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), outputs.get(output));\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f83af14a2a8131b14d7aee6274c740334e0363d3":["0762b640e0d0d12b6edb96db68986e13145c3484"],"0762b640e0d0d12b6edb96db68986e13145c3484":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"459280d4c73660ea582f38afce7968563068fe49":["4f2bf10c11daad40c1e46fabd0d414c19a3e605b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"1ec890fad2ea96317f4429e0aa0085bb25673641":["3cc749c053615f5871f3b95715fe292f34e70a53"],"b5c52ce02dcffaf732180b33fef1231978edae9a":["459280d4c73660ea582f38afce7968563068fe49"],"d1ded5d4f5b5e3e5f32bff69cd6fe5e64322a886":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["1ec890fad2ea96317f4429e0aa0085bb25673641","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc"],"7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc":["f83af14a2a8131b14d7aee6274c740334e0363d3"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","f83af14a2a8131b14d7aee6274c740334e0363d3"],"06584e6e98d592b34e1329b384182f368d2025e8":["7b91922b55d15444d554721b352861d028eb8278"],"3cc749c053615f5871f3b95715fe292f34e70a53":["06584e6e98d592b34e1329b384182f368d2025e8"],"2553b00f699380c64959ccb27991289aae87be2e":["d1ded5d4f5b5e3e5f32bff69cd6fe5e64322a886","fd9cc9d77712aba3662f24632df7539ab75e3667"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc","fd9cc9d77712aba3662f24632df7539ab75e3667"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["b5c52ce02dcffaf732180b33fef1231978edae9a"],"7b91922b55d15444d554721b352861d028eb8278":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["1ec890fad2ea96317f4429e0aa0085bb25673641"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["1ec890fad2ea96317f4429e0aa0085bb25673641","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["2e10cb22a8bdb44339e282925a29182bb2f3174d","f83af14a2a8131b14d7aee6274c740334e0363d3"],"4f2bf10c11daad40c1e46fabd0d414c19a3e605b":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"f83af14a2a8131b14d7aee6274c740334e0363d3":["7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"0762b640e0d0d12b6edb96db68986e13145c3484":["f83af14a2a8131b14d7aee6274c740334e0363d3"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["0762b640e0d0d12b6edb96db68986e13145c3484","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"459280d4c73660ea582f38afce7968563068fe49":["b5c52ce02dcffaf732180b33fef1231978edae9a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1ec890fad2ea96317f4429e0aa0085bb25673641":["5b6fdfce35d0adb18836cf8711abe487a934df33","b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122"],"b5c52ce02dcffaf732180b33fef1231978edae9a":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"d1ded5d4f5b5e3e5f32bff69cd6fe5e64322a886":["2553b00f699380c64959ccb27991289aae87be2e"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","4f2bf10c11daad40c1e46fabd0d414c19a3e605b"],"7a2ad3e19433f4c343b5e95ecc8a85cc33dffccc":["d1ded5d4f5b5e3e5f32bff69cd6fe5e64322a886","fd9cc9d77712aba3662f24632df7539ab75e3667","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["d1ded5d4f5b5e3e5f32bff69cd6fe5e64322a886"],"06584e6e98d592b34e1329b384182f368d2025e8":["3cc749c053615f5871f3b95715fe292f34e70a53"],"3cc749c053615f5871f3b95715fe292f34e70a53":["1ec890fad2ea96317f4429e0aa0085bb25673641"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"60ba444201d2570214b6fcf1d15600dc1a01f548":["7b91922b55d15444d554721b352861d028eb8278"],"7b91922b55d15444d554721b352861d028eb8278":["06584e6e98d592b34e1329b384182f368d2025e8"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","5b6fdfce35d0adb18836cf8711abe487a934df33","817882884229bace7dc5d1b75f6b0e4aa1e47122"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"4f2bf10c11daad40c1e46fabd0d414c19a3e605b":["459280d4c73660ea582f38afce7968563068fe49"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5b6fdfce35d0adb18836cf8711abe487a934df33","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","817882884229bace7dc5d1b75f6b0e4aa1e47122","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}