{"path":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(packedValue, 1));\n                             if (GeoUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["82235a501cff963da53cb98d86009e33e15cf47f","82235a501cff963da53cb98d86009e33e15cf47f","b89d71e0157fcc66ac45395765150cc85ee28aec","b89d71e0157fcc66ac45395765150cc85ee28aec","f976862431a9be6f9f76f958b5a9a04aa2342747","f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33bb6bd7295e66f93f182556f5353b97243e62ba","date":1449525768,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(packedValue, 1));\n                             if (GeoUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["b89d71e0157fcc66ac45395765150cc85ee28aec","b89d71e0157fcc66ac45395765150cc85ee28aec","04995b00da1e08edb88b14c5a9789d741de5c51d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(BKDUtil.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(BKDUtil.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["33bb6bd7295e66f93f182556f5353b97243e62ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"33bb6bd7295e66f93f182556f5353b97243e62ba":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["33bb6bd7295e66f93f182556f5353b97243e62ba"],"770342641f7b505eaa8dccdc666158bff2419109":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"33bb6bd7295e66f93f182556f5353b97243e62ba":["770342641f7b505eaa8dccdc666158bff2419109"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}