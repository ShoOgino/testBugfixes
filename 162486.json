{"path":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"/dev/null","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":null,"sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"/dev/null","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32ca1a5456982c342df2a79ffa46397f3565bf5d","date":1285077954,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":["4ea4e0df42b1e8d32da66955b10083ed12ba7cc4","f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e9bbb27241bcf9645bb2f724c137537aa69918a","date":1287780008,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02f9424edb9eccc558626693e4a4cd43f8ce2622","date":1288987640,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      if (factory.shouldReverse(termStr)) {\n        int len = termStr.length();\n        char[] chars = new char[len+1];\n        chars[0] = factory.getMarkerChar();      \n        termStr.getChars(0, len, chars, 1);\n        ReversedWildcardFilter.reverse(chars, 1, len);\n        termStr = new String(chars);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        Term term = new Term(field, termStr);\n        // fsa representing the query\n        Automaton a = WildcardQuery.toAutomaton(term);\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {\n          // override toString so its completely transparent\n          @Override\n          public String toString(String field) {\n            StringBuilder buffer = new StringBuilder();\n            if (!getField().equals(field)) {\n              buffer.append(getField());\n              buffer.append(\":\");\n            }\n            buffer.append(term.text());\n            buffer.append(ToStringUtils.boost(getBoost()));\n            return buffer.toString();\n          }\n        };\n      }\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null) {\n      Term term = new Term(field, termStr);\n      // fsa representing the query\n      Automaton automaton = WildcardQuery.toAutomaton(term);\n      // TODO: we should likely use the automaton to calculate shouldReverse, too.\n      if (factory.shouldReverse(termStr)) {\n        automaton = BasicOperations.concatenate(automaton, BasicAutomata.makeChar(factory.getMarkerChar()));\n        SpecialOperations.reverse(automaton);\n      } else { \n        // reverse wildcardfilter is active: remove false positives\n        // fsa representing false positives (markerChar*)\n        Automaton falsePositives = BasicOperations.concatenate(\n            BasicAutomata.makeChar(factory.getMarkerChar()), \n            BasicAutomata.makeAnyString());\n        // subtract these away\n        automaton = BasicOperations.minus(automaton, falsePositives);\n      }\n      return new AutomatonQuery(term, automaton) {\n        // override toString so its completely transparent\n        @Override\n        public String toString(String field) {\n          StringBuilder buffer = new StringBuilder();\n          if (!getField().equals(field)) {\n            buffer.append(getField());\n            buffer.append(\":\");\n          }\n          buffer.append(term.text());\n          buffer.append(ToStringUtils.boost(getBoost()));\n          return buffer.toString();\n        }\n      };\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["02f9424edb9eccc558626693e4a4cd43f8ce2622","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"85a883878c0af761245ab048babc63d099f835f3":["b12d3e81e0f95a4527b5703953c503f71120ffcc","02f9424edb9eccc558626693e4a4cd43f8ce2622"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["32ca1a5456982c342df2a79ffa46397f3565bf5d","4e9bbb27241bcf9645bb2f724c137537aa69918a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","02f9424edb9eccc558626693e4a4cd43f8ce2622"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["02f9424edb9eccc558626693e4a4cd43f8ce2622"],"4e9bbb27241bcf9645bb2f724c137537aa69918a":["32ca1a5456982c342df2a79ffa46397f3565bf5d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"32ca1a5456982c342df2a79ffa46397f3565bf5d":["1da8d55113b689b06716246649de6f62430f15c0"],"02f9424edb9eccc558626693e4a4cd43f8ce2622":["4e9bbb27241bcf9645bb2f724c137537aa69918a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["02f9424edb9eccc558626693e4a4cd43f8ce2622"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"85a883878c0af761245ab048babc63d099f835f3":[],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["85a883878c0af761245ab048babc63d099f835f3"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"1da8d55113b689b06716246649de6f62430f15c0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","32ca1a5456982c342df2a79ffa46397f3565bf5d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"4e9bbb27241bcf9645bb2f724c137537aa69918a":["b12d3e81e0f95a4527b5703953c503f71120ffcc","02f9424edb9eccc558626693e4a4cd43f8ce2622"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"32ca1a5456982c342df2a79ffa46397f3565bf5d":["b12d3e81e0f95a4527b5703953c503f71120ffcc","4e9bbb27241bcf9645bb2f724c137537aa69918a"],"02f9424edb9eccc558626693e4a4cd43f8ce2622":["c26f00b574427b55127e869b935845554afde1fa","85a883878c0af761245ab048babc63d099f835f3","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["85a883878c0af761245ab048babc63d099f835f3","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}