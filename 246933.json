{"path":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","commits":[{"id":"30572b5bb51001316f9a67e632d09750dc627a53","date":1511445746,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    cloudClient.request(create);\n\n    JettySolrRunner runner = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner.getNodeName()));\n\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) > 0);\n\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'port':\" + runner.getLocalPort() +\n        \", 'replica':0}\" +\n        \"    ]\" +\n        \"}\";\n\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cloudClient.request(req);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    JettySolrRunner runner2 = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner2.getNodeName()));\n    assertTrue(\"no replica should be present in  \"+runner.getNodeName(),getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) == 0);\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner2.getNodeName()) > 0);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff5e25fb60ccc8574bcbd65396786ae9163f0149","date":1519706112,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    cloudClient.request(create);\n\n    JettySolrRunner runner = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner.getNodeName()));\n\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) > 0);\n\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'port':\" + runner.getLocalPort() +\n        \", 'replica':0}\" +\n        \"    ]\" +\n        \"}\";\n\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cloudClient.request(req);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    JettySolrRunner runner2 = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner2.getNodeName()));\n    assertTrue(\"no replica should be present in  \"+runner.getNodeName(),getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) == 0);\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner2.getNodeName()) > 0);\n\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    cloudClient.request(create);\n\n    JettySolrRunner runner = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner.getNodeName()));\n\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) > 0);\n\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'port':\" + runner.getLocalPort() +\n        \", 'replica':0}\" +\n        \"    ]\" +\n        \"}\";\n\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cloudClient.request(req);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    JettySolrRunner runner2 = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner2.getNodeName()));\n    assertTrue(\"no replica should be present in  \"+runner.getNodeName(),getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) == 0);\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner2.getNodeName()) > 0);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0659d1f3381eb2a3f31dec2bcb97d75097e8537","date":1519949186,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12050\")\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    cloudClient.request(create);\n\n    JettySolrRunner runner = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner.getNodeName()));\n\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) > 0);\n\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'port':\" + runner.getLocalPort() +\n        \", 'replica':0}\" +\n        \"    ]\" +\n        \"}\";\n\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cloudClient.request(req);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    JettySolrRunner runner2 = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(runner2.getNodeName()));\n    assertTrue(\"no replica should be present in  \"+runner.getNodeName(),getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner.getNodeName()) == 0);\n\n    assertTrue(getReplicaCount(cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollection(coll), runner2.getNodeName()) > 0);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f0e33082a86447f4f2b59a1a5f69a310500276a","date":1519970482,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12050\")\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","bugFix":["30572b5bb51001316f9a67e632d09750dc627a53"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"067ba8c807b0f23eae8bf41bc27046a87b548134","date":1587570399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    int REPLICATION = 2;\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n    \n    assertNoReplicas(\"jettyX should no longer be utilized: \", coll, jettyX); \n    \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    }\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    if (log.isInfoEnabled()) {\n      log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n          jettyX.getNodeName(), jettyX.getLocalPort());\n    }\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n      log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName()); // logOk\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n             jettyX.getNodeName(), jettyX.getLocalPort());\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n\n    log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n    log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName());\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    }\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    if (log.isInfoEnabled()) {\n      log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n          jettyX.getNodeName(), jettyX.getLocalPort());\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n      log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName()); // logOk\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    }\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    if (log.isInfoEnabled()) {\n      log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n          jettyX.getNodeName(), jettyX.getLocalPort());\n    }\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n      log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName()); // logOk\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    }\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    if (log.isInfoEnabled()) {\n      log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n          jettyX.getNodeName(), jettyX.getLocalPort());\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n      log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName()); // logOk\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2)\n        .setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    }\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    if (log.isInfoEnabled()) {\n      log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n          jettyX.getNodeName(), jettyX.getLocalPort());\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n      log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName()); // logOk\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestUtilizeNode#test().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5);\n    String coll = \"utilizenodecoll\";\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    \n    log.info(\"Creating Collection...\");\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2);\n    cloudClient.request(create);\n\n    log.info(\"Spinning up additional jettyX...\");\n    JettySolrRunner jettyX = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n\n    assertNoReplicas(\"jettyX should not yet be utilized: \", coll, jettyX);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Sending UTILIZE command for jettyX ({})\", jettyX.getNodeName());\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyX.getNodeName()));\n\n    // TODO: aparently we can't assert this? ...\n    //\n    // assertSomeReplicas(\"jettyX should now be utilized: \", coll, jettyX);\n    //\n    // ... it appears from the docs that unless there are policy violations,\n    // this can be ignored unless jettyX has less \"load\" then other jetty instances?\n    //\n    // if the above is true, that means that this test is incredibly weak...\n    // unless we know jettyX has at least one replica, then all the subsequent testing of the\n    // port blacklist & additional UTILIZE command for jettyY are a waste of time.\n    //\n    // should we skip spinning up a *new* jettyX, and instead just pick an existing jetty?\n\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to being blacklisted: {}\", getReplicaList(coll, jettyX));\n    }\n    \n    String setClusterPolicyCommand = \"{\" +\n      \" 'set-cluster-policy': [\" +\n      \"    {'port':\" + jettyX.getLocalPort() +\n      \"     , 'replica':0}\" +\n      \"  ]\" +\n      \"}\";\n    if (log.isInfoEnabled()) {\n      log.info(\"Setting new policy to blacklist jettyX ({}) port={}\",\n          jettyX.getNodeName(), jettyX.getLocalPort());\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    NamedList<Object> response = cloudClient.request(req);\n    assertEquals(req + \" => \" + response,\n                 \"success\", response.get(\"result\").toString());\n\n    log.info(\"Spinning up additional jettyY...\");\n    JettySolrRunner jettyY = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    \n    assertNoReplicas(\"jettyY should not yet be utilized: \", coll, jettyY);\n    if (log.isInfoEnabled()) {\n      log.info(\"jettyX replicas prior to utilizing jettyY: {}\", getReplicaList(coll, jettyX));\n      log.info(\"Sending UTILIZE command for jettyY ({})\", jettyY.getNodeName()); // logOk\n    }\n    cloudClient.request(new CollectionAdminRequest.UtilizeNode(jettyY.getNodeName()));\n\n    assertSomeReplicas(\"jettyY should now be utilized: \", coll, jettyY);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"ff5e25fb60ccc8574bcbd65396786ae9163f0149":["30572b5bb51001316f9a67e632d09750dc627a53"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["9f0e33082a86447f4f2b59a1a5f69a310500276a"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["89948af0461fead48f44ba8fb7866f107ce83f22"],"9f0e33082a86447f4f2b59a1a5f69a310500276a":["e0659d1f3381eb2a3f31dec2bcb97d75097e8537"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"e0659d1f3381eb2a3f31dec2bcb97d75097e8537":["ff5e25fb60ccc8574bcbd65396786ae9163f0149"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30572b5bb51001316f9a67e632d09750dc627a53":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"89948af0461fead48f44ba8fb7866f107ce83f22":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ff5e25fb60ccc8574bcbd65396786ae9163f0149":["e0659d1f3381eb2a3f31dec2bcb97d75097e8537"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["89948af0461fead48f44ba8fb7866f107ce83f22"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"9f0e33082a86447f4f2b59a1a5f69a310500276a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["e98520789adb1d5ad05afb4956eca0944a929688"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"e98520789adb1d5ad05afb4956eca0944a929688":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e0659d1f3381eb2a3f31dec2bcb97d75097e8537":["9f0e33082a86447f4f2b59a1a5f69a310500276a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30572b5bb51001316f9a67e632d09750dc627a53"],"30572b5bb51001316f9a67e632d09750dc627a53":["ff5e25fb60ccc8574bcbd65396786ae9163f0149"],"89948af0461fead48f44ba8fb7866f107ce83f22":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}