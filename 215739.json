{"path":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d41890f2bad879e6a04c6dd7d2cf276f973994","date":1338488367,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<Object>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":["1fa60a501961bce2ff07ee1cde7c78699025547e","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97d4692d0c601ff773f0a2231967312428a904e4","date":1366026608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<Object>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10d98d3c84fcfdd2089a56054f4cf7186a57265d","date":1400053445,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.getLeafCollector(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","date":1448513807,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true); // TODO: disable exact counts?\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true); // TODO: disable exact counts?\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores);\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true); // TODO: disable exact counts?\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true); // TODO: disable exact counts?\n      }\n\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             topDocs.getMaxScore(),\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, topDocs.getMaxScore());\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"404d1ab7f6f396235047017c88d545fec15dafb7":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"901e951cec2e6af4e503209a6721c8834db23279":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae73da626f97850c922c42736f808d0378e165f0","93dd449115a9247533e44bab47e8429e5dccbc6d"],"85d41890f2bad879e6a04c6dd7d2cf276f973994":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","404d1ab7f6f396235047017c88d545fec15dafb7"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"10d98d3c84fcfdd2089a56054f4cf7186a57265d":["ae73da626f97850c922c42736f808d0378e165f0"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1aad05eeff7818b0833c02ac6b743aa72054963b","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae73da626f97850c922c42736f808d0378e165f0","10d98d3c84fcfdd2089a56054f4cf7186a57265d"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["97d4692d0c601ff773f0a2231967312428a904e4","ae73da626f97850c922c42736f808d0378e165f0"],"97d4692d0c601ff773f0a2231967312428a904e4":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae73da626f97850c922c42736f808d0378e165f0":["97d4692d0c601ff773f0a2231967312428a904e4"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04c370507e5521b2eb998530736f1c19b851ed5a"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["901e951cec2e6af4e503209a6721c8834db23279"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"04c370507e5521b2eb998530736f1c19b851ed5a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["404d1ab7f6f396235047017c88d545fec15dafb7","1aad05eeff7818b0833c02ac6b743aa72054963b"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"85d41890f2bad879e6a04c6dd7d2cf276f973994":["97d4692d0c601ff773f0a2231967312428a904e4"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"10d98d3c84fcfdd2089a56054f4cf7186a57265d":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"93dd449115a9247533e44bab47e8429e5dccbc6d":["b1eb427f2c6beed80d1724555fc1db003ccf3030","56572ec06f1407c066d6b7399413178b33176cd8"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"97d4692d0c601ff773f0a2231967312428a904e4":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"ae73da626f97850c922c42736f808d0378e165f0":["56572ec06f1407c066d6b7399413178b33176cd8","10d98d3c84fcfdd2089a56054f4cf7186a57265d","93dd449115a9247533e44bab47e8429e5dccbc6d","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["04c370507e5521b2eb998530736f1c19b851ed5a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}