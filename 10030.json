{"path":"solr/core/src/test/org/apache/solr/util/hll/BigEndianAscendingWordSerializerTest#smokeTestProbabilisticParams().mjava","commits":[{"id":"6faa211c4af605e3cf078a76d200c1dc348973f5","date":1437043657,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/BigEndianAscendingWordSerializerTest#smokeTestProbabilisticParams().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Smoke test for typical parameters used in practice.\n     */\n    @Test\n    public void smokeTestProbabilisticParams() {\n        // XXX: revisit this\n        final int shortWordLength = 5;\n        {// Should work on an empty sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     0/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            assert(Arrays.equals(serializer.getBytes(), new byte[0]));\n        }\n        {// Should work on a non-byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     3/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            serializer.writeWord(9);\n            serializer.writeWord(31);\n            serializer.writeWord(1);\n\n            // The values:\n            // -----------\n            // 9     |31    |1     |padding\n\n            // Corresponding bits:\n            // ------------------\n            // 0100 1|111 11|00 001|0\n\n            // And the hex/decimal (remember Java bytes are signed):\n            // -----------------------------------------------------\n            // 0100 1111 -> 0x4F -> 79\n            // 1100 0010 -> 0xC2 -> -62\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 79, -62 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should work on a byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     8/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            for(int i=1; i<9; i++) {\n                serializer.writeWord(i);\n            }\n\n            // Values: 1-8\n            // Corresponding bits:\n            // ------------------\n            // 00001\n            // 00010\n            // 00011\n            // 00100\n            // 00101\n            // 00110\n            // 00111\n            // 01000\n\n            // And the hex:\n            // ------------\n            // 0000 1000 => 0x08 => 8\n            // 1000 0110 => 0x86 => -122\n            // 0100 0010 => 0x62 => 66\n            // 1001 1000 => 0x98 => -104\n            // 1110 1000 => 0xE8 => -24\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 8, -122, 66, -104, -24 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should pad the array correctly.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     1/*wordCount*/,\n                                                     1/*bytePadding*/);\n\n            serializer.writeWord(1);\n            // 1 byte leading padding | value 1 | trailing padding\n            // 0000 0000 | 0000 1|000\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 8 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/BigEndianAscendingWordSerializerTest#smokeTestProbabilisticParams().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Smoke test for typical parameters used in practice.\n     */\n    @Test\n    public void smokeTestProbabilisticParams() {\n        // XXX: revisit this\n        final int shortWordLength = 5;\n        {// Should work on an empty sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     0/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            assert(Arrays.equals(serializer.getBytes(), new byte[0]));\n        }\n        {// Should work on a non-byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     3/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            serializer.writeWord(9);\n            serializer.writeWord(31);\n            serializer.writeWord(1);\n\n            // The values:\n            // -----------\n            // 9     |31    |1     |padding\n\n            // Corresponding bits:\n            // ------------------\n            // 0100 1|111 11|00 001|0\n\n            // And the hex/decimal (remember Java bytes are signed):\n            // -----------------------------------------------------\n            // 0100 1111 -> 0x4F -> 79\n            // 1100 0010 -> 0xC2 -> -62\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 79, -62 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should work on a byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     8/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            for(int i=1; i<9; i++) {\n                serializer.writeWord(i);\n            }\n\n            // Values: 1-8\n            // Corresponding bits:\n            // ------------------\n            // 00001\n            // 00010\n            // 00011\n            // 00100\n            // 00101\n            // 00110\n            // 00111\n            // 01000\n\n            // And the hex:\n            // ------------\n            // 0000 1000 => 0x08 => 8\n            // 1000 0110 => 0x86 => -122\n            // 0100 0010 => 0x62 => 66\n            // 1001 1000 => 0x98 => -104\n            // 1110 1000 => 0xE8 => -24\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 8, -122, 66, -104, -24 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should pad the array correctly.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     1/*wordCount*/,\n                                                     1/*bytePadding*/);\n\n            serializer.writeWord(1);\n            // 1 byte leading padding | value 1 | trailing padding\n            // 0000 0000 | 0000 1|000\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 8 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6faa211c4af605e3cf078a76d200c1dc348973f5"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6faa211c4af605e3cf078a76d200c1dc348973f5"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}