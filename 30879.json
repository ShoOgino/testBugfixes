{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","commits":[{"id":"24a98f5fdd23e04f85819dbc63b47a12f7c44311","date":1482439157,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","pathOld":"/dev/null","sourceNew":"  /** Scans the next input token(s) to see if a synonym matches.  Returns true\n   *  if a match was found. */\n  private boolean parse() throws IOException {\n    // System.out.println(Thread.currentThread().getName() + \": S: parse: \" + System.identityHashCode(this));\n\n    // Holds the longest match we've seen so far:\n    BytesRef matchOutput = null;\n    int matchInputLength = 0;\n\n    BytesRef pendingOutput = fst.outputs.getNoOutput();\n    fst.getFirstArc(scratchArc);\n\n    assert scratchArc.output == fst.outputs.getNoOutput();\n\n    // How many tokens in the current match\n    int matchLength = 0;\n    boolean doFinalCapture = false;\n\n    int lookaheadUpto = lookaheadNextRead;\n    matchStartOffset = -1;\n\n    byToken:\n    while (true) {\n      //System.out.println(\"  cycle lookaheadUpto=\" + lookaheadUpto + \" maxPos=\" + lookahead.getMaxPos());\n      \n      // Pull next token's chars:\n      final char[] buffer;\n      final int bufferLen;\n      final int inputEndOffset;\n\n      if (lookaheadUpto <= lookahead.getMaxPos()) {\n        // Still in our lookahead buffer\n        BufferedInputToken token = lookahead.get(lookaheadUpto);\n        lookaheadUpto++;\n        buffer = token.term.chars();\n        bufferLen = token.term.length();\n        inputEndOffset = token.endOffset;\n        //System.out.println(\"    use buffer now max=\" + lookahead.getMaxPos());\n        if (matchStartOffset == -1) {\n          matchStartOffset = token.startOffset;\n        }\n      } else {\n\n        // We used up our lookahead buffer of input tokens\n        // -- pull next real input token:\n\n        assert finished || liveToken == false;\n\n        if (finished) {\n          //System.out.println(\"    break: finished\");\n          break;\n        } else if (input.incrementToken()) {\n          //System.out.println(\"    input.incrToken\");\n          liveToken = true;\n          buffer = termAtt.buffer();\n          bufferLen = termAtt.length();\n          if (matchStartOffset == -1) {\n            matchStartOffset = offsetAtt.startOffset();\n          }\n          inputEndOffset = offsetAtt.endOffset();\n\n          lookaheadUpto++;\n        } else {\n          // No more input tokens\n          finished = true;\n          //System.out.println(\"    break: now set finished\");\n          break;\n        }\n      }\n\n      matchLength++;\n      //System.out.println(\"    cycle term=\" + new String(buffer, 0, bufferLen));\n\n      // Run each char in this token through the FST:\n      int bufUpto = 0;\n      while (bufUpto < bufferLen) {\n        final int codePoint = Character.codePointAt(buffer, bufUpto, bufferLen);\n        if (fst.findTargetArc(ignoreCase ? Character.toLowerCase(codePoint) : codePoint, scratchArc, scratchArc, fstReader) == null) {\n          break byToken;\n        }\n\n        // Accum the output\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        bufUpto += Character.charCount(codePoint);\n      }\n\n      assert bufUpto == bufferLen;\n\n      // OK, entire token matched; now see if this is a final\n      // state in the FST (a match):\n      if (scratchArc.isFinal()) {\n        matchOutput = fst.outputs.add(pendingOutput, scratchArc.nextFinalOutput);\n        matchInputLength = matchLength;\n        matchEndOffset = inputEndOffset;\n        //System.out.println(\"    ** match\");\n      }\n\n      // See if the FST can continue matching (ie, needs to\n      // see the next input token):\n      if (fst.findTargetArc(SynonymMap.WORD_SEPARATOR, scratchArc, scratchArc, fstReader) == null) {\n        // No further rules can match here; we're done\n        // searching for matching rules starting at the\n        // current input position.\n        break;\n      } else {\n        // More matching is possible -- accum the output (if\n        // any) of the WORD_SEP arc:\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        doFinalCapture = true;\n        if (liveToken) {\n          capture();\n        }\n      }\n    }\n\n    if (doFinalCapture && liveToken && finished == false) {\n      // Must capture the final token if we captured any prior tokens:\n      capture();\n    }\n\n    if (matchOutput != null) {\n\n      if (liveToken) {\n        // Single input token synonym; we must buffer it now:\n        capture();\n      }\n\n      // There is a match!\n      bufferOutputTokens(matchOutput, matchInputLength);\n      lookaheadNextRead += matchInputLength;\n      //System.out.println(\"  precmatch; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      lookahead.freeBefore(lookaheadNextRead);\n      //System.out.println(\"  match; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      return true;\n    } else {\n      //System.out.println(\"  no match; lookaheadNextRead=\" + lookaheadNextRead);\n      return false;\n    }\n\n    //System.out.println(\"  parse done inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","pathOld":"/dev/null","sourceNew":"  /** Scans the next input token(s) to see if a synonym matches.  Returns true\n   *  if a match was found. */\n  private boolean parse() throws IOException {\n    // System.out.println(Thread.currentThread().getName() + \": S: parse: \" + System.identityHashCode(this));\n\n    // Holds the longest match we've seen so far:\n    BytesRef matchOutput = null;\n    int matchInputLength = 0;\n\n    BytesRef pendingOutput = fst.outputs.getNoOutput();\n    fst.getFirstArc(scratchArc);\n\n    assert scratchArc.output == fst.outputs.getNoOutput();\n\n    // How many tokens in the current match\n    int matchLength = 0;\n    boolean doFinalCapture = false;\n\n    int lookaheadUpto = lookaheadNextRead;\n    matchStartOffset = -1;\n\n    byToken:\n    while (true) {\n      //System.out.println(\"  cycle lookaheadUpto=\" + lookaheadUpto + \" maxPos=\" + lookahead.getMaxPos());\n      \n      // Pull next token's chars:\n      final char[] buffer;\n      final int bufferLen;\n      final int inputEndOffset;\n\n      if (lookaheadUpto <= lookahead.getMaxPos()) {\n        // Still in our lookahead buffer\n        BufferedInputToken token = lookahead.get(lookaheadUpto);\n        lookaheadUpto++;\n        buffer = token.term.chars();\n        bufferLen = token.term.length();\n        inputEndOffset = token.endOffset;\n        //System.out.println(\"    use buffer now max=\" + lookahead.getMaxPos());\n        if (matchStartOffset == -1) {\n          matchStartOffset = token.startOffset;\n        }\n      } else {\n\n        // We used up our lookahead buffer of input tokens\n        // -- pull next real input token:\n\n        assert finished || liveToken == false;\n\n        if (finished) {\n          //System.out.println(\"    break: finished\");\n          break;\n        } else if (input.incrementToken()) {\n          //System.out.println(\"    input.incrToken\");\n          liveToken = true;\n          buffer = termAtt.buffer();\n          bufferLen = termAtt.length();\n          if (matchStartOffset == -1) {\n            matchStartOffset = offsetAtt.startOffset();\n          }\n          inputEndOffset = offsetAtt.endOffset();\n\n          lookaheadUpto++;\n        } else {\n          // No more input tokens\n          finished = true;\n          //System.out.println(\"    break: now set finished\");\n          break;\n        }\n      }\n\n      matchLength++;\n      //System.out.println(\"    cycle term=\" + new String(buffer, 0, bufferLen));\n\n      // Run each char in this token through the FST:\n      int bufUpto = 0;\n      while (bufUpto < bufferLen) {\n        final int codePoint = Character.codePointAt(buffer, bufUpto, bufferLen);\n        if (fst.findTargetArc(ignoreCase ? Character.toLowerCase(codePoint) : codePoint, scratchArc, scratchArc, fstReader) == null) {\n          break byToken;\n        }\n\n        // Accum the output\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        bufUpto += Character.charCount(codePoint);\n      }\n\n      assert bufUpto == bufferLen;\n\n      // OK, entire token matched; now see if this is a final\n      // state in the FST (a match):\n      if (scratchArc.isFinal()) {\n        matchOutput = fst.outputs.add(pendingOutput, scratchArc.nextFinalOutput);\n        matchInputLength = matchLength;\n        matchEndOffset = inputEndOffset;\n        //System.out.println(\"    ** match\");\n      }\n\n      // See if the FST can continue matching (ie, needs to\n      // see the next input token):\n      if (fst.findTargetArc(SynonymMap.WORD_SEPARATOR, scratchArc, scratchArc, fstReader) == null) {\n        // No further rules can match here; we're done\n        // searching for matching rules starting at the\n        // current input position.\n        break;\n      } else {\n        // More matching is possible -- accum the output (if\n        // any) of the WORD_SEP arc:\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        doFinalCapture = true;\n        if (liveToken) {\n          capture();\n        }\n      }\n    }\n\n    if (doFinalCapture && liveToken && finished == false) {\n      // Must capture the final token if we captured any prior tokens:\n      capture();\n    }\n\n    if (matchOutput != null) {\n\n      if (liveToken) {\n        // Single input token synonym; we must buffer it now:\n        capture();\n      }\n\n      // There is a match!\n      bufferOutputTokens(matchOutput, matchInputLength);\n      lookaheadNextRead += matchInputLength;\n      //System.out.println(\"  precmatch; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      lookahead.freeBefore(lookaheadNextRead);\n      //System.out.println(\"  match; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      return true;\n    } else {\n      //System.out.println(\"  no match; lookaheadNextRead=\" + lookaheadNextRead);\n      return false;\n    }\n\n    //System.out.println(\"  parse done inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","sourceNew":"  /** Scans the next input token(s) to see if a synonym matches.  Returns true\n   *  if a match was found. */\n  private boolean parse() throws IOException {\n    // System.out.println(Thread.currentThread().getName() + \": S: parse: \" + System.identityHashCode(this));\n\n    // Holds the longest match we've seen so far:\n    BytesRef matchOutput = null;\n    int matchInputLength = 0;\n\n    BytesRef pendingOutput = fst.outputs.getNoOutput();\n    fst.getFirstArc(scratchArc);\n\n    assert scratchArc.output() == fst.outputs.getNoOutput();\n\n    // How many tokens in the current match\n    int matchLength = 0;\n    boolean doFinalCapture = false;\n\n    int lookaheadUpto = lookaheadNextRead;\n    matchStartOffset = -1;\n\n    byToken:\n    while (true) {\n      //System.out.println(\"  cycle lookaheadUpto=\" + lookaheadUpto + \" maxPos=\" + lookahead.getMaxPos());\n      \n      // Pull next token's chars:\n      final char[] buffer;\n      final int bufferLen;\n      final int inputEndOffset;\n\n      if (lookaheadUpto <= lookahead.getMaxPos()) {\n        // Still in our lookahead buffer\n        BufferedInputToken token = lookahead.get(lookaheadUpto);\n        lookaheadUpto++;\n        buffer = token.term.chars();\n        bufferLen = token.term.length();\n        inputEndOffset = token.endOffset;\n        //System.out.println(\"    use buffer now max=\" + lookahead.getMaxPos());\n        if (matchStartOffset == -1) {\n          matchStartOffset = token.startOffset;\n        }\n      } else {\n\n        // We used up our lookahead buffer of input tokens\n        // -- pull next real input token:\n\n        assert finished || liveToken == false;\n\n        if (finished) {\n          //System.out.println(\"    break: finished\");\n          break;\n        } else if (input.incrementToken()) {\n          //System.out.println(\"    input.incrToken\");\n          liveToken = true;\n          buffer = termAtt.buffer();\n          bufferLen = termAtt.length();\n          if (matchStartOffset == -1) {\n            matchStartOffset = offsetAtt.startOffset();\n          }\n          inputEndOffset = offsetAtt.endOffset();\n\n          lookaheadUpto++;\n        } else {\n          // No more input tokens\n          finished = true;\n          //System.out.println(\"    break: now set finished\");\n          break;\n        }\n      }\n\n      matchLength++;\n      //System.out.println(\"    cycle term=\" + new String(buffer, 0, bufferLen));\n\n      // Run each char in this token through the FST:\n      int bufUpto = 0;\n      while (bufUpto < bufferLen) {\n        final int codePoint = Character.codePointAt(buffer, bufUpto, bufferLen);\n        if (fst.findTargetArc(ignoreCase ? Character.toLowerCase(codePoint) : codePoint, scratchArc, scratchArc, fstReader) == null) {\n          break byToken;\n        }\n\n        // Accum the output\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output());\n        bufUpto += Character.charCount(codePoint);\n      }\n\n      assert bufUpto == bufferLen;\n\n      // OK, entire token matched; now see if this is a final\n      // state in the FST (a match):\n      if (scratchArc.isFinal()) {\n        matchOutput = fst.outputs.add(pendingOutput, scratchArc.nextFinalOutput());\n        matchInputLength = matchLength;\n        matchEndOffset = inputEndOffset;\n        //System.out.println(\"    ** match\");\n      }\n\n      // See if the FST can continue matching (ie, needs to\n      // see the next input token):\n      if (fst.findTargetArc(SynonymMap.WORD_SEPARATOR, scratchArc, scratchArc, fstReader) == null) {\n        // No further rules can match here; we're done\n        // searching for matching rules starting at the\n        // current input position.\n        break;\n      } else {\n        // More matching is possible -- accum the output (if\n        // any) of the WORD_SEP arc:\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output());\n        doFinalCapture = true;\n        if (liveToken) {\n          capture();\n        }\n      }\n    }\n\n    if (doFinalCapture && liveToken && finished == false) {\n      // Must capture the final token if we captured any prior tokens:\n      capture();\n    }\n\n    if (matchOutput != null) {\n\n      if (liveToken) {\n        // Single input token synonym; we must buffer it now:\n        capture();\n      }\n\n      // There is a match!\n      bufferOutputTokens(matchOutput, matchInputLength);\n      lookaheadNextRead += matchInputLength;\n      //System.out.println(\"  precmatch; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      lookahead.freeBefore(lookaheadNextRead);\n      //System.out.println(\"  match; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      return true;\n    } else {\n      //System.out.println(\"  no match; lookaheadNextRead=\" + lookaheadNextRead);\n      return false;\n    }\n\n    //System.out.println(\"  parse done inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n  }\n\n","sourceOld":"  /** Scans the next input token(s) to see if a synonym matches.  Returns true\n   *  if a match was found. */\n  private boolean parse() throws IOException {\n    // System.out.println(Thread.currentThread().getName() + \": S: parse: \" + System.identityHashCode(this));\n\n    // Holds the longest match we've seen so far:\n    BytesRef matchOutput = null;\n    int matchInputLength = 0;\n\n    BytesRef pendingOutput = fst.outputs.getNoOutput();\n    fst.getFirstArc(scratchArc);\n\n    assert scratchArc.output == fst.outputs.getNoOutput();\n\n    // How many tokens in the current match\n    int matchLength = 0;\n    boolean doFinalCapture = false;\n\n    int lookaheadUpto = lookaheadNextRead;\n    matchStartOffset = -1;\n\n    byToken:\n    while (true) {\n      //System.out.println(\"  cycle lookaheadUpto=\" + lookaheadUpto + \" maxPos=\" + lookahead.getMaxPos());\n      \n      // Pull next token's chars:\n      final char[] buffer;\n      final int bufferLen;\n      final int inputEndOffset;\n\n      if (lookaheadUpto <= lookahead.getMaxPos()) {\n        // Still in our lookahead buffer\n        BufferedInputToken token = lookahead.get(lookaheadUpto);\n        lookaheadUpto++;\n        buffer = token.term.chars();\n        bufferLen = token.term.length();\n        inputEndOffset = token.endOffset;\n        //System.out.println(\"    use buffer now max=\" + lookahead.getMaxPos());\n        if (matchStartOffset == -1) {\n          matchStartOffset = token.startOffset;\n        }\n      } else {\n\n        // We used up our lookahead buffer of input tokens\n        // -- pull next real input token:\n\n        assert finished || liveToken == false;\n\n        if (finished) {\n          //System.out.println(\"    break: finished\");\n          break;\n        } else if (input.incrementToken()) {\n          //System.out.println(\"    input.incrToken\");\n          liveToken = true;\n          buffer = termAtt.buffer();\n          bufferLen = termAtt.length();\n          if (matchStartOffset == -1) {\n            matchStartOffset = offsetAtt.startOffset();\n          }\n          inputEndOffset = offsetAtt.endOffset();\n\n          lookaheadUpto++;\n        } else {\n          // No more input tokens\n          finished = true;\n          //System.out.println(\"    break: now set finished\");\n          break;\n        }\n      }\n\n      matchLength++;\n      //System.out.println(\"    cycle term=\" + new String(buffer, 0, bufferLen));\n\n      // Run each char in this token through the FST:\n      int bufUpto = 0;\n      while (bufUpto < bufferLen) {\n        final int codePoint = Character.codePointAt(buffer, bufUpto, bufferLen);\n        if (fst.findTargetArc(ignoreCase ? Character.toLowerCase(codePoint) : codePoint, scratchArc, scratchArc, fstReader) == null) {\n          break byToken;\n        }\n\n        // Accum the output\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        bufUpto += Character.charCount(codePoint);\n      }\n\n      assert bufUpto == bufferLen;\n\n      // OK, entire token matched; now see if this is a final\n      // state in the FST (a match):\n      if (scratchArc.isFinal()) {\n        matchOutput = fst.outputs.add(pendingOutput, scratchArc.nextFinalOutput);\n        matchInputLength = matchLength;\n        matchEndOffset = inputEndOffset;\n        //System.out.println(\"    ** match\");\n      }\n\n      // See if the FST can continue matching (ie, needs to\n      // see the next input token):\n      if (fst.findTargetArc(SynonymMap.WORD_SEPARATOR, scratchArc, scratchArc, fstReader) == null) {\n        // No further rules can match here; we're done\n        // searching for matching rules starting at the\n        // current input position.\n        break;\n      } else {\n        // More matching is possible -- accum the output (if\n        // any) of the WORD_SEP arc:\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        doFinalCapture = true;\n        if (liveToken) {\n          capture();\n        }\n      }\n    }\n\n    if (doFinalCapture && liveToken && finished == false) {\n      // Must capture the final token if we captured any prior tokens:\n      capture();\n    }\n\n    if (matchOutput != null) {\n\n      if (liveToken) {\n        // Single input token synonym; we must buffer it now:\n        capture();\n      }\n\n      // There is a match!\n      bufferOutputTokens(matchOutput, matchInputLength);\n      lookaheadNextRead += matchInputLength;\n      //System.out.println(\"  precmatch; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      lookahead.freeBefore(lookaheadNextRead);\n      //System.out.println(\"  match; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      return true;\n    } else {\n      //System.out.println(\"  no match; lookaheadNextRead=\" + lookaheadNextRead);\n      return false;\n    }\n\n    //System.out.println(\"  parse done inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#parse().mjava","sourceNew":"  /** Scans the next input token(s) to see if a synonym matches.  Returns true\n   *  if a match was found. */\n  private boolean parse() throws IOException {\n    // System.out.println(Thread.currentThread().getName() + \": S: parse: \" + System.identityHashCode(this));\n\n    // Holds the longest match we've seen so far:\n    BytesRef matchOutput = null;\n    int matchInputLength = 0;\n\n    BytesRef pendingOutput = fst.outputs.getNoOutput();\n    fst.getFirstArc(scratchArc);\n\n    assert scratchArc.output() == fst.outputs.getNoOutput();\n\n    // How many tokens in the current match\n    int matchLength = 0;\n    boolean doFinalCapture = false;\n\n    int lookaheadUpto = lookaheadNextRead;\n    matchStartOffset = -1;\n\n    byToken:\n    while (true) {\n      //System.out.println(\"  cycle lookaheadUpto=\" + lookaheadUpto + \" maxPos=\" + lookahead.getMaxPos());\n      \n      // Pull next token's chars:\n      final char[] buffer;\n      final int bufferLen;\n      final int inputEndOffset;\n\n      if (lookaheadUpto <= lookahead.getMaxPos()) {\n        // Still in our lookahead buffer\n        BufferedInputToken token = lookahead.get(lookaheadUpto);\n        lookaheadUpto++;\n        buffer = token.term.chars();\n        bufferLen = token.term.length();\n        inputEndOffset = token.endOffset;\n        //System.out.println(\"    use buffer now max=\" + lookahead.getMaxPos());\n        if (matchStartOffset == -1) {\n          matchStartOffset = token.startOffset;\n        }\n      } else {\n\n        // We used up our lookahead buffer of input tokens\n        // -- pull next real input token:\n\n        assert finished || liveToken == false;\n\n        if (finished) {\n          //System.out.println(\"    break: finished\");\n          break;\n        } else if (input.incrementToken()) {\n          //System.out.println(\"    input.incrToken\");\n          liveToken = true;\n          buffer = termAtt.buffer();\n          bufferLen = termAtt.length();\n          if (matchStartOffset == -1) {\n            matchStartOffset = offsetAtt.startOffset();\n          }\n          inputEndOffset = offsetAtt.endOffset();\n\n          lookaheadUpto++;\n        } else {\n          // No more input tokens\n          finished = true;\n          //System.out.println(\"    break: now set finished\");\n          break;\n        }\n      }\n\n      matchLength++;\n      //System.out.println(\"    cycle term=\" + new String(buffer, 0, bufferLen));\n\n      // Run each char in this token through the FST:\n      int bufUpto = 0;\n      while (bufUpto < bufferLen) {\n        final int codePoint = Character.codePointAt(buffer, bufUpto, bufferLen);\n        if (fst.findTargetArc(ignoreCase ? Character.toLowerCase(codePoint) : codePoint, scratchArc, scratchArc, fstReader) == null) {\n          break byToken;\n        }\n\n        // Accum the output\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output());\n        bufUpto += Character.charCount(codePoint);\n      }\n\n      assert bufUpto == bufferLen;\n\n      // OK, entire token matched; now see if this is a final\n      // state in the FST (a match):\n      if (scratchArc.isFinal()) {\n        matchOutput = fst.outputs.add(pendingOutput, scratchArc.nextFinalOutput());\n        matchInputLength = matchLength;\n        matchEndOffset = inputEndOffset;\n        //System.out.println(\"    ** match\");\n      }\n\n      // See if the FST can continue matching (ie, needs to\n      // see the next input token):\n      if (fst.findTargetArc(SynonymMap.WORD_SEPARATOR, scratchArc, scratchArc, fstReader) == null) {\n        // No further rules can match here; we're done\n        // searching for matching rules starting at the\n        // current input position.\n        break;\n      } else {\n        // More matching is possible -- accum the output (if\n        // any) of the WORD_SEP arc:\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output());\n        doFinalCapture = true;\n        if (liveToken) {\n          capture();\n        }\n      }\n    }\n\n    if (doFinalCapture && liveToken && finished == false) {\n      // Must capture the final token if we captured any prior tokens:\n      capture();\n    }\n\n    if (matchOutput != null) {\n\n      if (liveToken) {\n        // Single input token synonym; we must buffer it now:\n        capture();\n      }\n\n      // There is a match!\n      bufferOutputTokens(matchOutput, matchInputLength);\n      lookaheadNextRead += matchInputLength;\n      //System.out.println(\"  precmatch; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      lookahead.freeBefore(lookaheadNextRead);\n      //System.out.println(\"  match; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      return true;\n    } else {\n      //System.out.println(\"  no match; lookaheadNextRead=\" + lookaheadNextRead);\n      return false;\n    }\n\n    //System.out.println(\"  parse done inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n  }\n\n","sourceOld":"  /** Scans the next input token(s) to see if a synonym matches.  Returns true\n   *  if a match was found. */\n  private boolean parse() throws IOException {\n    // System.out.println(Thread.currentThread().getName() + \": S: parse: \" + System.identityHashCode(this));\n\n    // Holds the longest match we've seen so far:\n    BytesRef matchOutput = null;\n    int matchInputLength = 0;\n\n    BytesRef pendingOutput = fst.outputs.getNoOutput();\n    fst.getFirstArc(scratchArc);\n\n    assert scratchArc.output == fst.outputs.getNoOutput();\n\n    // How many tokens in the current match\n    int matchLength = 0;\n    boolean doFinalCapture = false;\n\n    int lookaheadUpto = lookaheadNextRead;\n    matchStartOffset = -1;\n\n    byToken:\n    while (true) {\n      //System.out.println(\"  cycle lookaheadUpto=\" + lookaheadUpto + \" maxPos=\" + lookahead.getMaxPos());\n      \n      // Pull next token's chars:\n      final char[] buffer;\n      final int bufferLen;\n      final int inputEndOffset;\n\n      if (lookaheadUpto <= lookahead.getMaxPos()) {\n        // Still in our lookahead buffer\n        BufferedInputToken token = lookahead.get(lookaheadUpto);\n        lookaheadUpto++;\n        buffer = token.term.chars();\n        bufferLen = token.term.length();\n        inputEndOffset = token.endOffset;\n        //System.out.println(\"    use buffer now max=\" + lookahead.getMaxPos());\n        if (matchStartOffset == -1) {\n          matchStartOffset = token.startOffset;\n        }\n      } else {\n\n        // We used up our lookahead buffer of input tokens\n        // -- pull next real input token:\n\n        assert finished || liveToken == false;\n\n        if (finished) {\n          //System.out.println(\"    break: finished\");\n          break;\n        } else if (input.incrementToken()) {\n          //System.out.println(\"    input.incrToken\");\n          liveToken = true;\n          buffer = termAtt.buffer();\n          bufferLen = termAtt.length();\n          if (matchStartOffset == -1) {\n            matchStartOffset = offsetAtt.startOffset();\n          }\n          inputEndOffset = offsetAtt.endOffset();\n\n          lookaheadUpto++;\n        } else {\n          // No more input tokens\n          finished = true;\n          //System.out.println(\"    break: now set finished\");\n          break;\n        }\n      }\n\n      matchLength++;\n      //System.out.println(\"    cycle term=\" + new String(buffer, 0, bufferLen));\n\n      // Run each char in this token through the FST:\n      int bufUpto = 0;\n      while (bufUpto < bufferLen) {\n        final int codePoint = Character.codePointAt(buffer, bufUpto, bufferLen);\n        if (fst.findTargetArc(ignoreCase ? Character.toLowerCase(codePoint) : codePoint, scratchArc, scratchArc, fstReader) == null) {\n          break byToken;\n        }\n\n        // Accum the output\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        bufUpto += Character.charCount(codePoint);\n      }\n\n      assert bufUpto == bufferLen;\n\n      // OK, entire token matched; now see if this is a final\n      // state in the FST (a match):\n      if (scratchArc.isFinal()) {\n        matchOutput = fst.outputs.add(pendingOutput, scratchArc.nextFinalOutput);\n        matchInputLength = matchLength;\n        matchEndOffset = inputEndOffset;\n        //System.out.println(\"    ** match\");\n      }\n\n      // See if the FST can continue matching (ie, needs to\n      // see the next input token):\n      if (fst.findTargetArc(SynonymMap.WORD_SEPARATOR, scratchArc, scratchArc, fstReader) == null) {\n        // No further rules can match here; we're done\n        // searching for matching rules starting at the\n        // current input position.\n        break;\n      } else {\n        // More matching is possible -- accum the output (if\n        // any) of the WORD_SEP arc:\n        pendingOutput = fst.outputs.add(pendingOutput, scratchArc.output);\n        doFinalCapture = true;\n        if (liveToken) {\n          capture();\n        }\n      }\n    }\n\n    if (doFinalCapture && liveToken && finished == false) {\n      // Must capture the final token if we captured any prior tokens:\n      capture();\n    }\n\n    if (matchOutput != null) {\n\n      if (liveToken) {\n        // Single input token synonym; we must buffer it now:\n        capture();\n      }\n\n      // There is a match!\n      bufferOutputTokens(matchOutput, matchInputLength);\n      lookaheadNextRead += matchInputLength;\n      //System.out.println(\"  precmatch; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      lookahead.freeBefore(lookaheadNextRead);\n      //System.out.println(\"  match; set lookaheadNextRead=\" + lookaheadNextRead + \" now max=\" + lookahead.getMaxPos());\n      return true;\n    } else {\n      //System.out.println(\"  no match; lookaheadNextRead=\" + lookaheadNextRead);\n      return false;\n    }\n\n    //System.out.println(\"  parse done inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["24a98f5fdd23e04f85819dbc63b47a12f7c44311"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8061ddd97f3352007d927dae445884a6f3d857b":["24a98f5fdd23e04f85819dbc63b47a12f7c44311","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","24a98f5fdd23e04f85819dbc63b47a12f7c44311"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a98f5fdd23e04f85819dbc63b47a12f7c44311","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}