{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","commits":[{"id":"500867f0f15393f6b2c38c3366e414fccba04ed6","date":1411520390,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                                                 \", please run checkindex for more details\", in));\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) + \n                                                                   \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      IOUtils.reThrow(priorException);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["eb39083d248dc00a9ce4656e519cea3fbf159c91"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","sourceNew":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                                                 \", please run checkindex for more details\", in));\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) + \n                                                                   \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      throw IOUtils.rethrowAlways(priorException);\n    }\n  }\n\n","sourceOld":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                                                 \", please run checkindex for more details\", in));\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) + \n                                                                   \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      IOUtils.reThrow(priorException);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","sourceNew":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                                                 \", please run checkindex for more details\", in));\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) + \n                                                                   \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      throw IOUtils.rethrowAlways(priorException);\n    }\n  }\n\n","sourceOld":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                                                 \", please run checkindex for more details\", in));\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) + \n                                                                   \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      IOUtils.reThrow(priorException);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb39083d248dc00a9ce4656e519cea3fbf159c91","date":1588849460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkFooter(ChecksumIndexInput,Throwable).mjava","sourceNew":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        // If we have evidence of corruption then we return the corruption as the\n        // main exception and the prior exception gets suppressed. Otherwise we\n        // return the prior exception with a suppressed exception that notifies\n        // the user that checksums matched.\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          throw new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                          \"; please run checkindex for more details\", in);\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          long checksum = checkFooter(in);\n          priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) +\n                                                                 \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n        }\n      } catch (CorruptIndexException corruptException) {\n        corruptException.addSuppressed(priorException);\n        throw corruptException;\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      throw IOUtils.rethrowAlways(priorException);\n    }\n  }\n\n","sourceOld":"  /** \n   * Validates the codec footer previously written by {@link #writeFooter}, optionally\n   * passing an unexpected exception that has already occurred.\n   * <p>\n   * When a {@code priorException} is provided, this method will add a suppressed exception \n   * indicating whether the checksum for the stream passes, fails, or cannot be computed, and \n   * rethrow it. Otherwise it behaves the same as {@link #checkFooter(ChecksumIndexInput)}.\n   * <p>\n   * Example usage:\n   * <pre class=\"prettyprint\">\n   * try (ChecksumIndexInput input = ...) {\n   *   Throwable priorE = null;\n   *   try {\n   *     // ... read a bunch of stuff ... \n   *   } catch (Throwable exception) {\n   *     priorE = exception;\n   *   } finally {\n   *     CodecUtil.checkFooter(input, priorE);\n   *   }\n   * }\n   * </pre>\n   */\n  public static void checkFooter(ChecksumIndexInput in, Throwable priorException) throws IOException {\n    if (priorException == null) {\n      checkFooter(in);\n    } else {\n      try {\n        long remaining = in.length() - in.getFilePointer();\n        if (remaining < footerLength()) {\n          // corruption caused us to read into the checksum footer already: we can't proceed\n          priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: remaining=\" + remaining +\n                                                                 \", please run checkindex for more details\", in));\n        } else {\n          // otherwise, skip any unread bytes.\n          in.skipBytes(remaining - footerLength());\n          \n          // now check the footer\n          try {\n            long checksum = checkFooter(in);\n            priorException.addSuppressed(new CorruptIndexException(\"checksum passed (\" + Long.toHexString(checksum) + \n                                                                   \"). possibly transient resource issue, or a Lucene or JVM bug\", in));\n          } catch (CorruptIndexException t) {\n            priorException.addSuppressed(t);\n          }\n        }\n      } catch (Throwable t) {\n        // catch-all for things that shouldn't go wrong (e.g. OOM during readInt) but could...\n        priorException.addSuppressed(new CorruptIndexException(\"checksum status indeterminate: unexpected exception\", in, t));\n      }\n      throw IOUtils.rethrowAlways(priorException);\n    }\n  }\n\n","bugFix":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["500867f0f15393f6b2c38c3366e414fccba04ed6","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"eb39083d248dc00a9ce4656e519cea3fbf159c91":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"500867f0f15393f6b2c38c3366e414fccba04ed6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eb39083d248dc00a9ce4656e519cea3fbf159c91"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["e9017cf144952056066919f1ebc7897ff9bd71b1","eb39083d248dc00a9ce4656e519cea3fbf159c91"],"eb39083d248dc00a9ce4656e519cea3fbf159c91":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"500867f0f15393f6b2c38c3366e414fccba04ed6":["e9017cf144952056066919f1ebc7897ff9bd71b1","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}