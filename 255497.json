{"path":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","commits":[{"id":"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e","date":1419346542,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof BitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof BitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (parents instanceof BitDocIdSet == false) {\n          throw new IllegalStateException(\"parentFilter must return BitSet; got \" + parents);\n        }\n        parentBits = (BitSet) parents.bits();\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof BitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789","date":1439672757,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (parents instanceof BitDocIdSet == false) {\n          throw new IllegalStateException(\"parentFilter must return BitSet; got \" + parents);\n        }\n        parentBits = (BitSet) parents.bits();\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (parents instanceof BitDocIdSet == false) {\n          throw new IllegalStateException(\"parentFilter must return BitSet; got \" + parents);\n        }\n        parentBits = (BitSet) parents.bits();\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d52e48927ca4ef3655a261f2230b968b6fdf3608","date":1444652107,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(context.reader());\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final DocIdSetIterator parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents, context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (parents instanceof BitDocIdSet == false) {\n          throw new IllegalStateException(\"parentFilter must return BitSet; got \" + parents);\n        }\n        parentBits = (BitSet) parents.bits();\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["d2dce5e63b0228e94e989139c2503dd4018d8b45"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2dce5e63b0228e94e989139c2503dd4018d8b45","date":1444678473,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final DocIdSetIterator parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents, context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(context.reader());\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final DocIdSetIterator parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents, context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final Scorer parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents.iterator(), context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final DocIdSetIterator parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents, context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e03940e6e9044943de4b7ac08f8581da37a9534","date":1462870173,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final Scorer parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents.iterator(), context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final Scorer parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents.iterator(), context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final Scorer parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents.iterator(), context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final Scorer parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents.iterator(), context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n\n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n\n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n\n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      BitSet parentBits;\n      LeafFieldComparator[] parentLeafComparators;\n      LeafFieldComparator[] childLeafComparators;\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n        if (parentBits != null) {\n          throw new IllegalStateException(\"This comparator can only be used on a single segment\");\n        }\n        IndexSearcher searcher = new IndexSearcher(ReaderUtil.getTopLevelContext(context));\n        searcher.setQueryCache(null);\n        final Weight weight = searcher.createNormalizedWeight(parentsFilter, false);\n        final Scorer parents = weight.scorer(context);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        parentBits = BitSet.of(parents.iterator(), context.reader().maxDoc());\n        parentLeafComparators = new LeafFieldComparator[parentComparators.length];\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentLeafComparators[i] = parentComparators[i].getLeafComparator(context);\n        }\n        childLeafComparators = new LeafFieldComparator[childComparators.length];\n        for (int i = 0; i < childComparators.length; i++) {\n          childLeafComparators[i] = childComparators[i].getLeafComparator(context);\n        }\n\n        return new LeafFieldComparator() {\n\n          @Override\n          public int compareBottom(int doc) throws IOException {\n            return compare(bottomChild, bottomParent, doc, parent(doc));\n          }\n\n          @Override\n          public int compareTop(int doc) throws IOException {\n            // we dont have enough information (the docid is needed)\n            throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n          }\n\n          @Override\n          public void copy(int slot, int doc) throws IOException {\n            childSlots[slot] = doc;\n            parentSlots[slot] = parent(doc);\n          }\n\n          @Override\n          public void setBottom(int slot) {\n            bottomParent = parentSlots[slot];\n            bottomChild = childSlots[slot];\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            for (LeafFieldComparator comp : parentLeafComparators) {\n              comp.setScorer(scorer);\n            }\n            for (LeafFieldComparator comp : childLeafComparators) {\n              comp.setScorer(scorer);\n            }\n          }\n\n        };\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n\n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childLeafComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentLeafComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n\n      int compare(int docID1, int docID2, LeafFieldComparator comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"901e951cec2e6af4e503209a6721c8834db23279":["82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e"],"0ad30c6a479e764150a3316e57263319775f1df2":["7dd748bb245633a8195281556bb0e68a6ea97d18","3d33e731a93d4b57e662ff094f64f94a745422d4"],"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dd748bb245633a8195281556bb0e68a6ea97d18","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["7dd748bb245633a8195281556bb0e68a6ea97d18","0ad30c6a479e764150a3316e57263319775f1df2"],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789":["901e951cec2e6af4e503209a6721c8834db23279"],"5e03940e6e9044943de4b7ac08f8581da37a9534":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["d2dce5e63b0228e94e989139c2503dd4018d8b45"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["7dd748bb245633a8195281556bb0e68a6ea97d18","5e03940e6e9044943de4b7ac08f8581da37a9534"],"d2dce5e63b0228e94e989139c2503dd4018d8b45":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"commit2Childs":{"901e951cec2e6af4e503209a6721c8834db23279":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e":["901e951cec2e6af4e503209a6721c8834db23279"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["d2dce5e63b0228e94e989139c2503dd4018d8b45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e"],"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"5e03940e6e9044943de4b7ac08f8581da37a9534":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","5e03940e6e9044943de4b7ac08f8581da37a9534","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"d2dce5e63b0228e94e989139c2503dd4018d8b45":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}