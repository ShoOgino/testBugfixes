{"path":"contrib/snowball/src/java/net/sf/snowball/SnowballProgram#find_among(Among[],int).mjava","commits":[{"id":"043c298cb215f13ba7b9b81d20760704e8f93d66","date":1107566743,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/snowball/src/java/net/sf/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"sandbox/contributions/snowball/src/java/net/sf/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b62da6a75575f59a016a076b4753dc6e20c74b44","date":1219528967,"type":5,"author":"Karl-Johan Wettin","isMerge":false,"pathNew":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"contrib/snowball/src/java/net/sf/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b62da6a75575f59a016a076b4753dc6e20c74b44":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"043c298cb215f13ba7b9b81d20760704e8f93d66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b62da6a75575f59a016a076b4753dc6e20c74b44"]},"commit2Childs":{"b62da6a75575f59a016a076b4753dc6e20c74b44":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"043c298cb215f13ba7b9b81d20760704e8f93d66":["b62da6a75575f59a016a076b4753dc6e20c74b44"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}