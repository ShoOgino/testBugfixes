{"path":"lucene/core/src/java/org/apache/lucene/index/CoalescedDeletes#mergedIterator(List[Iterator[Term]]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CoalescedDeletes#mergedIterator(List[Iterator[Term]]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CoalescedDeletes#mergedIterator(List[Iterator[Term]]).mjava","sourceNew":"  /** provides a merged view across multiple iterators */\n  static Iterator<Term> mergedIterator(final List<Iterator<Term>> iterators) {\n    return new Iterator<Term>() {\n      Term current;\n      TermMergeQueue queue = new TermMergeQueue(iterators.size());\n      SubIterator[] top = new SubIterator[iterators.size()];\n      int numTop;\n      \n      {\n        int index = 0;\n        for (Iterator<Term> iterator : iterators) {\n          if (iterator.hasNext()) {\n            SubIterator sub = new SubIterator();\n            sub.current = iterator.next();\n            sub.iterator = iterator;\n            sub.index = index++;\n            queue.add(sub);\n          }\n        }\n      }\n      \n      public boolean hasNext() {\n        if (queue.size() > 0) {\n          return true;\n        }\n        \n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            return true;\n          }\n        }\n        return false;\n      }\n      \n      public Term next() {\n        // restore queue\n        pushTop();\n        \n        // gather equal top fields\n        if (queue.size() > 0) {\n          pullTop();\n        } else {\n          current = null;\n        }\n        return current;\n      }\n      \n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private void pullTop() {\n        // extract all subs from the queue that have the same top term\n        assert numTop == 0;\n        while (true) {\n          top[numTop++] = queue.pop();\n          if (queue.size() == 0\n              || !(queue.top()).current.equals(top[0].current)) {\n            break;\n          }\n        }\n        current = top[0].current;\n      }\n      \n      private void pushTop() {\n        // call next() on each top, and put back into queue\n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            top[i].current = top[i].iterator.next();\n            queue.add(top[i]);\n          } else {\n            // no more terms\n            top[i].current = null;\n          }\n        }\n        numTop = 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** provides a merged view across multiple iterators */\n  static Iterator<Term> mergedIterator(final List<Iterator<Term>> iterators) {\n    return new Iterator<Term>() {\n      Term current;\n      TermMergeQueue queue = new TermMergeQueue(iterators.size());\n      SubIterator[] top = new SubIterator[iterators.size()];\n      int numTop;\n      \n      {\n        int index = 0;\n        for (Iterator<Term> iterator : iterators) {\n          if (iterator.hasNext()) {\n            SubIterator sub = new SubIterator();\n            sub.current = iterator.next();\n            sub.iterator = iterator;\n            sub.index = index++;\n            queue.add(sub);\n          }\n        }\n      }\n      \n      public boolean hasNext() {\n        if (queue.size() > 0) {\n          return true;\n        }\n        \n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            return true;\n          }\n        }\n        return false;\n      }\n      \n      public Term next() {\n        // restore queue\n        pushTop();\n        \n        // gather equal top fields\n        if (queue.size() > 0) {\n          pullTop();\n        } else {\n          current = null;\n        }\n        return current;\n      }\n      \n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private void pullTop() {\n        // extract all subs from the queue that have the same top term\n        assert numTop == 0;\n        while (true) {\n          top[numTop++] = queue.pop();\n          if (queue.size() == 0\n              || !(queue.top()).current.equals(top[0].current)) {\n            break;\n          }\n        }\n        current = top[0].current;\n      }\n      \n      private void pushTop() {\n        // call next() on each top, and put back into queue\n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            top[i].current = top[i].iterator.next();\n            queue.add(top[i]);\n          } else {\n            // no more terms\n            top[i].current = null;\n          }\n        }\n        numTop = 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb07ab105350b80ed9d63ca64b117084ed7391bc","date":1344824719,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/CoalescedDeletes#mergedIterator(List[Iterator[Term]]).mjava","sourceNew":null,"sourceOld":"  /** provides a merged view across multiple iterators */\n  static Iterator<Term> mergedIterator(final List<Iterator<Term>> iterators) {\n    return new Iterator<Term>() {\n      Term current;\n      TermMergeQueue queue = new TermMergeQueue(iterators.size());\n      SubIterator[] top = new SubIterator[iterators.size()];\n      int numTop;\n      \n      {\n        int index = 0;\n        for (Iterator<Term> iterator : iterators) {\n          if (iterator.hasNext()) {\n            SubIterator sub = new SubIterator();\n            sub.current = iterator.next();\n            sub.iterator = iterator;\n            sub.index = index++;\n            queue.add(sub);\n          }\n        }\n      }\n      \n      public boolean hasNext() {\n        if (queue.size() > 0) {\n          return true;\n        }\n        \n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            return true;\n          }\n        }\n        return false;\n      }\n      \n      public Term next() {\n        // restore queue\n        pushTop();\n        \n        // gather equal top fields\n        if (queue.size() > 0) {\n          pullTop();\n        } else {\n          current = null;\n        }\n        return current;\n      }\n      \n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private void pullTop() {\n        // extract all subs from the queue that have the same top term\n        assert numTop == 0;\n        while (true) {\n          top[numTop++] = queue.pop();\n          if (queue.size() == 0\n              || !(queue.top()).current.equals(top[0].current)) {\n            break;\n          }\n        }\n        current = top[0].current;\n      }\n      \n      private void pushTop() {\n        // call next() on each top, and put back into queue\n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            top[i].current = top[i].iterator.next();\n            queue.add(top[i]);\n          } else {\n            // no more terms\n            top[i].current = null;\n          }\n        }\n        numTop = 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/CoalescedDeletes#mergedIterator(List[Iterator[Term]]).mjava","sourceNew":null,"sourceOld":"  /** provides a merged view across multiple iterators */\n  static Iterator<Term> mergedIterator(final List<Iterator<Term>> iterators) {\n    return new Iterator<Term>() {\n      Term current;\n      TermMergeQueue queue = new TermMergeQueue(iterators.size());\n      SubIterator[] top = new SubIterator[iterators.size()];\n      int numTop;\n      \n      {\n        int index = 0;\n        for (Iterator<Term> iterator : iterators) {\n          if (iterator.hasNext()) {\n            SubIterator sub = new SubIterator();\n            sub.current = iterator.next();\n            sub.iterator = iterator;\n            sub.index = index++;\n            queue.add(sub);\n          }\n        }\n      }\n      \n      public boolean hasNext() {\n        if (queue.size() > 0) {\n          return true;\n        }\n        \n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            return true;\n          }\n        }\n        return false;\n      }\n      \n      public Term next() {\n        // restore queue\n        pushTop();\n        \n        // gather equal top fields\n        if (queue.size() > 0) {\n          pullTop();\n        } else {\n          current = null;\n        }\n        return current;\n      }\n      \n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private void pullTop() {\n        // extract all subs from the queue that have the same top term\n        assert numTop == 0;\n        while (true) {\n          top[numTop++] = queue.pop();\n          if (queue.size() == 0\n              || !(queue.top()).current.equals(top[0].current)) {\n            break;\n          }\n        }\n        current = top[0].current;\n      }\n      \n      private void pushTop() {\n        // call next() on each top, and put back into queue\n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            top[i].current = top[i].iterator.next();\n            queue.add(top[i]);\n          } else {\n            // no more terms\n            top[i].current = null;\n          }\n        }\n        numTop = 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/CoalescedDeletes#mergedIterator(List[Iterator[Term]]).mjava","sourceNew":null,"sourceOld":"  /** provides a merged view across multiple iterators */\n  static Iterator<Term> mergedIterator(final List<Iterator<Term>> iterators) {\n    return new Iterator<Term>() {\n      Term current;\n      TermMergeQueue queue = new TermMergeQueue(iterators.size());\n      SubIterator[] top = new SubIterator[iterators.size()];\n      int numTop;\n      \n      {\n        int index = 0;\n        for (Iterator<Term> iterator : iterators) {\n          if (iterator.hasNext()) {\n            SubIterator sub = new SubIterator();\n            sub.current = iterator.next();\n            sub.iterator = iterator;\n            sub.index = index++;\n            queue.add(sub);\n          }\n        }\n      }\n      \n      public boolean hasNext() {\n        if (queue.size() > 0) {\n          return true;\n        }\n        \n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            return true;\n          }\n        }\n        return false;\n      }\n      \n      public Term next() {\n        // restore queue\n        pushTop();\n        \n        // gather equal top fields\n        if (queue.size() > 0) {\n          pullTop();\n        } else {\n          current = null;\n        }\n        return current;\n      }\n      \n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private void pullTop() {\n        // extract all subs from the queue that have the same top term\n        assert numTop == 0;\n        while (true) {\n          top[numTop++] = queue.pop();\n          if (queue.size() == 0\n              || !(queue.top()).current.equals(top[0].current)) {\n            break;\n          }\n        }\n        current = top[0].current;\n      }\n      \n      private void pushTop() {\n        // call next() on each top, and put back into queue\n        for (int i = 0; i < numTop; i++) {\n          if (top[i].iterator.hasNext()) {\n            top[i].current = top[i].iterator.next();\n            queue.add(top[i]);\n          } else {\n            // no more terms\n            top[i].current = null;\n          }\n        }\n        numTop = 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7869f64c874ebf7f317d22c00baf2b6857797a6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fb07ab105350b80ed9d63ca64b117084ed7391bc":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb07ab105350b80ed9d63ca64b117084ed7391bc"]},"commit2Childs":{"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c7869f64c874ebf7f317d22c00baf2b6857797a6","fb07ab105350b80ed9d63ca64b117084ed7391bc","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"fb07ab105350b80ed9d63ca64b117084ed7391bc":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}