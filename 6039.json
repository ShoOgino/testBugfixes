{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doUnionScoring(Collector,DocsEnum[][],Collector[]).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doUnionScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSidewaysScorer#doUnionScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  private void doUnionScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doUnionScoring\");\n    //}\n\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n\n    // NOTE: this is basically a specialized version of\n    // BooleanScorer, to the minShouldMatch=N-1 case, but\n    // carefully tracking which dimension failed to match\n\n    int nextChunkStart = CHUNK;\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n      int filledCount = 0;\n      int docID = baseScorer.docID();\n      //if (DEBUG) {\n      //  System.out.println(\"  base docID=\" + docID);\n      //}\n      while (docID < nextChunkStart) {\n        int slot = docID & MASK;\n        //if (DEBUG) {\n        //  System.out.println(\"    docIDs[slot=\" + slot + \"]=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n        //}\n\n        // Mark slot as valid:\n        assert docIDs[slot] != docID: \"slot=\" + slot + \" docID=\" + docID;\n        docIDs[slot] = docID;\n        scores[slot] = baseScorer.score();\n        filledSlots[filledCount++] = slot;\n        missingDims[slot] = 0;\n        counts[slot] = 1;\n\n        docID = baseScorer.nextDoc();\n      }\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n\n      // First drill-down dim, basically adds SHOULD onto\n      // the baseQuery:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim=0 [\" + dims[0].dim + \"]\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        docID = docsEnum.docID();\n        //if (DEBUG) {\n        //  System.out.println(\"    start docID=\" + docID);\n        //}\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID) {\n            //if (DEBUG) {\n            //  System.out.println(\"      set docID=\" + docID + \" count=2\");\n            //}\n            missingDims[slot] = 1;\n            counts[slot] = 2;\n          }\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      for(int dim=1;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          docID = docsEnum.docID();\n          //if (DEBUG) {\n          //  System.out.println(\"    start docID=\" + docID);\n          //}\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // This doc is still in the running...\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            docID = docsEnum.nextDoc();\n          }\n\n          // TODO: sometimes use advance?\n\n          /*\n            int docBase = nextChunkStart - CHUNK;\n            for(int i=0;i<filledCount;i++) {\n              int slot = filledSlots[i];\n              docID = docBase + filledSlots[i];\n              if (docIDs[slot] == docID && counts[slot] >= dim) {\n                // This doc is still in the running...\n                int ddDocID = docsEnum.docID();\n                if (ddDocID < docID) {\n                  ddDocID = docsEnum.advance(docID);\n                }\n                if (ddDocID == docID) {\n                  if (missingDims[slot] >= dim && counts[slot] == allMatchCount) {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                   // }\n                    missingDims[slot] = dim+1;\n                    counts[slot] = dim+2;\n                  } else {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                   // }\n                    counts[slot] = dim+1;\n                  }\n                }\n              }\n            }            \n          */\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        // NOTE: This is actually in-order collection,\n        // because we only accept docs originally returned by\n        // the baseScorer (ie that Scorer is AND'd)\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        //System.out.println(\"  collect doc=\" + collectDocID + \" main.freq=\" + (counts[slot]-1) + \" main.doc=\" + collectDocID + \" exactCount=\" + numDims);\n        if (counts[slot] == 1+numDims) {\n          //System.out.println(\"    hit\");\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          //System.out.println(\"    sw\");\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":"  private void doUnionScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doUnionScoring\");\n    //}\n\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n\n    // NOTE: this is basically a specialized version of\n    // BooleanScorer, to the minShouldMatch=N-1 case, but\n    // carefully tracking which dimension failed to match\n\n    int nextChunkStart = CHUNK;\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n      int filledCount = 0;\n      int docID = baseScorer.docID();\n      //if (DEBUG) {\n      //  System.out.println(\"  base docID=\" + docID);\n      //}\n      while (docID < nextChunkStart) {\n        int slot = docID & MASK;\n        //if (DEBUG) {\n        //  System.out.println(\"    docIDs[slot=\" + slot + \"]=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n        //}\n\n        // Mark slot as valid:\n        assert docIDs[slot] != docID: \"slot=\" + slot + \" docID=\" + docID;\n        docIDs[slot] = docID;\n        scores[slot] = baseScorer.score();\n        filledSlots[filledCount++] = slot;\n        missingDims[slot] = 0;\n        counts[slot] = 1;\n\n        docID = baseScorer.nextDoc();\n      }\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n\n      // First drill-down dim, basically adds SHOULD onto\n      // the baseQuery:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim=0 [\" + dims[0].dim + \"]\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        docID = docsEnum.docID();\n        //if (DEBUG) {\n        //  System.out.println(\"    start docID=\" + docID);\n        //}\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID) {\n            //if (DEBUG) {\n            //  System.out.println(\"      set docID=\" + docID + \" count=2\");\n            //}\n            missingDims[slot] = 1;\n            counts[slot] = 2;\n          }\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      for(int dim=1;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          docID = docsEnum.docID();\n          //if (DEBUG) {\n          //  System.out.println(\"    start docID=\" + docID);\n          //}\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // This doc is still in the running...\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            docID = docsEnum.nextDoc();\n          }\n\n          // TODO: sometimes use advance?\n\n          /*\n            int docBase = nextChunkStart - CHUNK;\n            for(int i=0;i<filledCount;i++) {\n              int slot = filledSlots[i];\n              docID = docBase + filledSlots[i];\n              if (docIDs[slot] == docID && counts[slot] >= dim) {\n                // This doc is still in the running...\n                int ddDocID = docsEnum.docID();\n                if (ddDocID < docID) {\n                  ddDocID = docsEnum.advance(docID);\n                }\n                if (ddDocID == docID) {\n                  if (missingDims[slot] >= dim && counts[slot] == allMatchCount) {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                   // }\n                    missingDims[slot] = dim+1;\n                    counts[slot] = dim+2;\n                  } else {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                   // }\n                    counts[slot] = dim+1;\n                  }\n                }\n              }\n            }            \n          */\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        // NOTE: This is actually in-order collection,\n        // because we only accept docs originally returned by\n        // the baseScorer (ie that Scorer is AND'd)\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        //System.out.println(\"  collect doc=\" + collectDocID + \" main.freq=\" + (counts[slot]-1) + \" main.doc=\" + collectDocID + \" exactCount=\" + numDims);\n        if (counts[slot] == 1+numDims) {\n          //System.out.println(\"    hit\");\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          //System.out.println(\"    sw\");\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doUnionScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doUnionScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  private void doUnionScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doUnionScoring\");\n    //}\n\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n\n    // NOTE: this is basically a specialized version of\n    // BooleanScorer, to the minShouldMatch=N-1 case, but\n    // carefully tracking which dimension failed to match\n\n    int nextChunkStart = CHUNK;\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n      int filledCount = 0;\n      int docID = baseScorer.docID();\n      //if (DEBUG) {\n      //  System.out.println(\"  base docID=\" + docID);\n      //}\n      while (docID < nextChunkStart) {\n        int slot = docID & MASK;\n        //if (DEBUG) {\n        //  System.out.println(\"    docIDs[slot=\" + slot + \"]=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n        //}\n\n        // Mark slot as valid:\n        assert docIDs[slot] != docID: \"slot=\" + slot + \" docID=\" + docID;\n        docIDs[slot] = docID;\n        scores[slot] = baseScorer.score();\n        filledSlots[filledCount++] = slot;\n        missingDims[slot] = 0;\n        counts[slot] = 1;\n\n        docID = baseScorer.nextDoc();\n      }\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n\n      // First drill-down dim, basically adds SHOULD onto\n      // the baseQuery:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim=0 [\" + dims[0].dim + \"]\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        docID = docsEnum.docID();\n        //if (DEBUG) {\n        //  System.out.println(\"    start docID=\" + docID);\n        //}\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID) {\n            //if (DEBUG) {\n            //  System.out.println(\"      set docID=\" + docID + \" count=2\");\n            //}\n            missingDims[slot] = 1;\n            counts[slot] = 2;\n          }\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      for(int dim=1;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          docID = docsEnum.docID();\n          //if (DEBUG) {\n          //  System.out.println(\"    start docID=\" + docID);\n          //}\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // This doc is still in the running...\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            docID = docsEnum.nextDoc();\n          }\n\n          // TODO: sometimes use advance?\n\n          /*\n            int docBase = nextChunkStart - CHUNK;\n            for(int i=0;i<filledCount;i++) {\n              int slot = filledSlots[i];\n              docID = docBase + filledSlots[i];\n              if (docIDs[slot] == docID && counts[slot] >= dim) {\n                // This doc is still in the running...\n                int ddDocID = docsEnum.docID();\n                if (ddDocID < docID) {\n                  ddDocID = docsEnum.advance(docID);\n                }\n                if (ddDocID == docID) {\n                  if (missingDims[slot] >= dim && counts[slot] == allMatchCount) {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                   // }\n                    missingDims[slot] = dim+1;\n                    counts[slot] = dim+2;\n                  } else {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                   // }\n                    counts[slot] = dim+1;\n                  }\n                }\n              }\n            }            \n          */\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        // NOTE: This is actually in-order collection,\n        // because we only accept docs originally returned by\n        // the baseScorer (ie that Scorer is AND'd)\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        //System.out.println(\"  collect doc=\" + collectDocID + \" main.freq=\" + (counts[slot]-1) + \" main.doc=\" + collectDocID + \" exactCount=\" + numDims);\n        if (counts[slot] == 1+numDims) {\n          //System.out.println(\"    hit\");\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          //System.out.println(\"    sw\");\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":"  private void doUnionScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doUnionScoring\");\n    //}\n\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n\n    // NOTE: this is basically a specialized version of\n    // BooleanScorer, to the minShouldMatch=N-1 case, but\n    // carefully tracking which dimension failed to match\n\n    int nextChunkStart = CHUNK;\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n      int filledCount = 0;\n      int docID = baseScorer.docID();\n      //if (DEBUG) {\n      //  System.out.println(\"  base docID=\" + docID);\n      //}\n      while (docID < nextChunkStart) {\n        int slot = docID & MASK;\n        //if (DEBUG) {\n        //  System.out.println(\"    docIDs[slot=\" + slot + \"]=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n        //}\n\n        // Mark slot as valid:\n        assert docIDs[slot] != docID: \"slot=\" + slot + \" docID=\" + docID;\n        docIDs[slot] = docID;\n        scores[slot] = baseScorer.score();\n        filledSlots[filledCount++] = slot;\n        missingDims[slot] = 0;\n        counts[slot] = 1;\n\n        docID = baseScorer.nextDoc();\n      }\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n\n      // First drill-down dim, basically adds SHOULD onto\n      // the baseQuery:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim=0 [\" + dims[0].dim + \"]\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        docID = docsEnum.docID();\n        //if (DEBUG) {\n        //  System.out.println(\"    start docID=\" + docID);\n        //}\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID) {\n            //if (DEBUG) {\n            //  System.out.println(\"      set docID=\" + docID + \" count=2\");\n            //}\n            missingDims[slot] = 1;\n            counts[slot] = 2;\n          }\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      for(int dim=1;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          docID = docsEnum.docID();\n          //if (DEBUG) {\n          //  System.out.println(\"    start docID=\" + docID);\n          //}\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // This doc is still in the running...\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            docID = docsEnum.nextDoc();\n          }\n\n          // TODO: sometimes use advance?\n\n          /*\n            int docBase = nextChunkStart - CHUNK;\n            for(int i=0;i<filledCount;i++) {\n              int slot = filledSlots[i];\n              docID = docBase + filledSlots[i];\n              if (docIDs[slot] == docID && counts[slot] >= dim) {\n                // This doc is still in the running...\n                int ddDocID = docsEnum.docID();\n                if (ddDocID < docID) {\n                  ddDocID = docsEnum.advance(docID);\n                }\n                if (ddDocID == docID) {\n                  if (missingDims[slot] >= dim && counts[slot] == allMatchCount) {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                   // }\n                    missingDims[slot] = dim+1;\n                    counts[slot] = dim+2;\n                  } else {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                   // }\n                    counts[slot] = dim+1;\n                  }\n                }\n              }\n            }            \n          */\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        // NOTE: This is actually in-order collection,\n        // because we only accept docs originally returned by\n        // the baseScorer (ie that Scorer is AND'd)\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        //System.out.println(\"  collect doc=\" + collectDocID + \" main.freq=\" + (counts[slot]-1) + \" main.doc=\" + collectDocID + \" exactCount=\" + numDims);\n        if (counts[slot] == 1+numDims) {\n          //System.out.println(\"    hit\");\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          //System.out.println(\"    sw\");\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doUnionScoring(Collector,DocIdSetIterator[],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doUnionScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  private void doUnionScoring(Collector collector, DocIdSetIterator[] disis, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doUnionScoring\");\n    //}\n\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n\n    // NOTE: this is basically a specialized version of\n    // BooleanScorer, to the minShouldMatch=N-1 case, but\n    // carefully tracking which dimension failed to match\n\n    int nextChunkStart = CHUNK;\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n      int filledCount = 0;\n      int docID = baseScorer.docID();\n      //if (DEBUG) {\n      //  System.out.println(\"  base docID=\" + docID);\n      //}\n      while (docID < nextChunkStart) {\n        int slot = docID & MASK;\n        //if (DEBUG) {\n        //  System.out.println(\"    docIDs[slot=\" + slot + \"]=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n        //}\n\n        // Mark slot as valid:\n        assert docIDs[slot] != docID: \"slot=\" + slot + \" docID=\" + docID;\n        docIDs[slot] = docID;\n        scores[slot] = baseScorer.score();\n        filledSlots[filledCount++] = slot;\n        missingDims[slot] = 0;\n        counts[slot] = 1;\n\n        docID = baseScorer.nextDoc();\n      }\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n\n      // First drill-down dim, basically adds SHOULD onto\n      // the baseQuery:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim=0 [\" + dims[0].dim + \"]\");\n      //}\n      DocIdSetIterator disi = disis[0];\n      if (disi != null) {\n        docID = disi.docID();\n        //if (DEBUG) {\n        //  System.out.println(\"    start docID=\" + docID);\n        //}\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID) {\n            //if (DEBUG) {\n            //  System.out.println(\"      set docID=\" + docID + \" count=2\");\n            //}\n            missingDims[slot] = 1;\n            counts[slot] = 2;\n          }\n          docID = disi.nextDoc();\n        }\n      }\n\n      for (int dim=1;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n\n        disi = disis[dim];\n        if (disi != null) {\n          docID = disi.docID();\n          //if (DEBUG) {\n          //  System.out.println(\"    start docID=\" + docID);\n          //}\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // This doc is still in the running...\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            docID = disi.nextDoc();\n          }\n        }\n      }\n\n      // Collect:\n      //System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      for (int i=0;i<filledCount;i++) {\n        // NOTE: This is actually in-order collection,\n        // because we only accept docs originally returned by\n        // the baseScorer (ie that Scorer is AND'd)\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        //System.out.println(\"  collect doc=\" + collectDocID + \" main.freq=\" + (counts[slot]-1) + \" main.doc=\" + collectDocID + \" exactCount=\" + numDims);\n        if (counts[slot] == 1+numDims) {\n          //System.out.println(\"    hit\");\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          //System.out.println(\"    sw\");\n          collectNearMiss(sidewaysCollectors[missingDims[slot]]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":"  private void doUnionScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doUnionScoring\");\n    //}\n\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n\n    // NOTE: this is basically a specialized version of\n    // BooleanScorer, to the minShouldMatch=N-1 case, but\n    // carefully tracking which dimension failed to match\n\n    int nextChunkStart = CHUNK;\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n      int filledCount = 0;\n      int docID = baseScorer.docID();\n      //if (DEBUG) {\n      //  System.out.println(\"  base docID=\" + docID);\n      //}\n      while (docID < nextChunkStart) {\n        int slot = docID & MASK;\n        //if (DEBUG) {\n        //  System.out.println(\"    docIDs[slot=\" + slot + \"]=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n        //}\n\n        // Mark slot as valid:\n        assert docIDs[slot] != docID: \"slot=\" + slot + \" docID=\" + docID;\n        docIDs[slot] = docID;\n        scores[slot] = baseScorer.score();\n        filledSlots[filledCount++] = slot;\n        missingDims[slot] = 0;\n        counts[slot] = 1;\n\n        docID = baseScorer.nextDoc();\n      }\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n\n      // First drill-down dim, basically adds SHOULD onto\n      // the baseQuery:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim=0 [\" + dims[0].dim + \"]\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        docID = docsEnum.docID();\n        //if (DEBUG) {\n        //  System.out.println(\"    start docID=\" + docID);\n        //}\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID) {\n            //if (DEBUG) {\n            //  System.out.println(\"      set docID=\" + docID + \" count=2\");\n            //}\n            missingDims[slot] = 1;\n            counts[slot] = 2;\n          }\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      for(int dim=1;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          docID = docsEnum.docID();\n          //if (DEBUG) {\n          //  System.out.println(\"    start docID=\" + docID);\n          //}\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // This doc is still in the running...\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"      set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            docID = docsEnum.nextDoc();\n          }\n\n          // TODO: sometimes use advance?\n\n          /*\n            int docBase = nextChunkStart - CHUNK;\n            for(int i=0;i<filledCount;i++) {\n              int slot = filledSlots[i];\n              docID = docBase + filledSlots[i];\n              if (docIDs[slot] == docID && counts[slot] >= dim) {\n                // This doc is still in the running...\n                int ddDocID = docsEnum.docID();\n                if (ddDocID < docID) {\n                  ddDocID = docsEnum.advance(docID);\n                }\n                if (ddDocID == docID) {\n                  if (missingDims[slot] >= dim && counts[slot] == allMatchCount) {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                   // }\n                    missingDims[slot] = dim+1;\n                    counts[slot] = dim+2;\n                  } else {\n                  //if (DEBUG) {\n                  //    System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                   // }\n                    counts[slot] = dim+1;\n                  }\n                }\n              }\n            }            \n          */\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        // NOTE: This is actually in-order collection,\n        // because we only accept docs originally returned by\n        // the baseScorer (ie that Scorer is AND'd)\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        //System.out.println(\"  collect doc=\" + collectDocID + \" main.freq=\" + (counts[slot]-1) + \" main.doc=\" + collectDocID + \" exactCount=\" + numDims);\n        if (counts[slot] == 1+numDims) {\n          //System.out.println(\"    hit\");\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          //System.out.println(\"    sw\");\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","21d36d0db865f7b84026b447bec653469a6e66df"],"40640359164f629dd440a47df2e145d084ce9645":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["40640359164f629dd440a47df2e145d084ce9645"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","3cc728b07df73b197e6d940d27f9b08b63918f13"],"21d36d0db865f7b84026b447bec653469a6e66df":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["40640359164f629dd440a47df2e145d084ce9645"],"40640359164f629dd440a47df2e145d084ce9645":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}