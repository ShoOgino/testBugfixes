{"path":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, termAtt.term());\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(termAtt.term()); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, termAtt.term());\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(termAtt.term()); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7347509fad0711ac30cb15a746e9a3830a38ebd","date":1275388513,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, termAtt.toString());\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(termAtt.toString()); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, termAtt.term());\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(termAtt.term()); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f5b43095f980581c7d8cc84b9899eef00ba5e1b","date":1279723029,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n        BytesRef bytes = new BytesRef();\n        termAtt.toBytesRef(bytes);\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, bytes);\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(bytes); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, termAtt.toString());\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(termAtt.toString()); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n        BytesRef bytes = new BytesRef();\n        termAtt.toBytesRef(bytes);\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, bytes);\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(bytes); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, termAtt.toString());\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(termAtt.toString()); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3d07f1ae3b58102f36f3393c397d78ba4e547a4","date":1300715535,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n        BytesRef bytes = new BytesRef();\n        termAtt.toBytesRef(bytes);\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, bytes);\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(bytes); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n        BytesRef bytes = new BytesRef();\n        termAtt.toBytesRef(bytes);\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, bytes);\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(bytes); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n\t\t\twhile (ts.incrementToken()) {\n        BytesRef bytes = new BytesRef();\n        termAtt.toBytesRef(bytes);\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, bytes);\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(bytes); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4","date":1305207152,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00746ad002a54281629e3b6f3eb39833a33f093e","date":1305306799,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\tTokenStream ts = analyzer.tokenStream(fieldName, new StringReader(text));\n\t\ttry\n\t\t{\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n\t\t\t\tif (term == null)\n\t\t\t\t{\n\t\t\t\t\tterm = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\t} else\n\t\t\t\t{\n//\t\t\t\t\t create from previous to save fieldName.intern overhead\n\t\t\t\t\tterm = term.createTerm(new BytesRef(bytes)); \n\t\t\t\t}\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b68b0aeb05de4dd5b24fc5ffd51e2fbd5d571df2","date":1313460667,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"  public Query getQuery(Element e) throws ParserException {\n    String fieldName = DOMUtils.getAttributeWithInheritanceOrFail(e, \"fieldName\");\n    String text = DOMUtils.getNonBlankTextOrFail(e);\n\n    BooleanQuery bq = new BooleanQuery(DOMUtils.getAttribute(e, \"disableCoord\", false));\n    bq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e, \"minimumNumberShouldMatch\", 0));\n    try {\n      TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n      TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n      Term term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n      while (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n        bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n      }\n      ts.end();\n      ts.close();\n    }\n    catch (IOException ioe) {\n      throw new RuntimeException(\"Error constructing terms from index:\" + ioe);\n    }\n\n    bq.setBoost(DOMUtils.getAttribute(e, \"boost\", 1.0f));\n    return bq;\n  }\n\n","sourceOld":"\tpublic Query getQuery(Element e) throws ParserException {\n\t\t\n        String fieldName=DOMUtils.getAttributeWithInheritanceOrFail(e,\"fieldName\");\n \t\tString text=DOMUtils.getNonBlankTextOrFail(e);\n \t\t\n\t\tBooleanQuery bq=new BooleanQuery(DOMUtils.getAttribute(e,\"disableCoord\",false));\n\t\tbq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e,\"minimumNumberShouldMatch\",0));\n\t\ttry\n\t\t{\n\t    TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n\t\t  TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n\t\t\tTerm term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n\t\t\twhile (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n\t\t\t\tbq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));\n\t\t\t}\n\t\t\tts.end();\n\t\t\tts.close();\n\t\t} \n\t\tcatch (IOException ioe)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Error constructing terms from index:\"\n\t\t\t\t\t+ ioe);\n\t\t}\n  \t\tbq.setBoost(DOMUtils.getAttribute(e,\"boost\",1.0f));\n\n  \t\treturn bq;\n\t\t\n\t}\n\n","bugFix":null,"bugIntro":["782ed6a4b4ba50ec19734fc8db4e570ee193d627"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"251550f5d19b526a76f8c5126ae7bb2d22cf8935","date":1315202008,"type":5,"author":"Christopher John Male","isMerge":false,"pathNew":"modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsQueryBuilder#getQuery(Element).mjava","pathOld":"lucene/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/TermsQueryBuilder#getQuery(Element).mjava","sourceNew":"  public Query getQuery(Element e) throws ParserException {\n    String fieldName = DOMUtils.getAttributeWithInheritanceOrFail(e, \"fieldName\");\n    String text = DOMUtils.getNonBlankTextOrFail(e);\n\n    BooleanQuery bq = new BooleanQuery(DOMUtils.getAttribute(e, \"disableCoord\", false));\n    bq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e, \"minimumNumberShouldMatch\", 0));\n    try {\n      TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n      TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n      Term term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n      while (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n        bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n      }\n      ts.end();\n      ts.close();\n    }\n    catch (IOException ioe) {\n      throw new RuntimeException(\"Error constructing terms from index:\" + ioe);\n    }\n\n    bq.setBoost(DOMUtils.getAttribute(e, \"boost\", 1.0f));\n    return bq;\n  }\n\n","sourceOld":"  public Query getQuery(Element e) throws ParserException {\n    String fieldName = DOMUtils.getAttributeWithInheritanceOrFail(e, \"fieldName\");\n    String text = DOMUtils.getNonBlankTextOrFail(e);\n\n    BooleanQuery bq = new BooleanQuery(DOMUtils.getAttribute(e, \"disableCoord\", false));\n    bq.setMinimumNumberShouldMatch(DOMUtils.getAttribute(e, \"minimumNumberShouldMatch\", 0));\n    try {\n      TokenStream ts = analyzer.reusableTokenStream(fieldName, new StringReader(text));\n      TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);\n      Term term = null;\n      BytesRef bytes = termAtt.getBytesRef();\n      ts.reset();\n      while (ts.incrementToken()) {\n        termAtt.fillBytesRef();\n        term = new Term(fieldName, new BytesRef(bytes));\n        bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n      }\n      ts.end();\n      ts.close();\n    }\n    catch (IOException ioe) {\n      throw new RuntimeException(\"Error constructing terms from index:\" + ioe);\n    }\n\n    bq.setBoost(DOMUtils.getAttribute(e, \"boost\", 1.0f));\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b68b0aeb05de4dd5b24fc5ffd51e2fbd5d571df2":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["00746ad002a54281629e3b6f3eb39833a33f093e"],"251550f5d19b526a76f8c5126ae7bb2d22cf8935":["b68b0aeb05de4dd5b24fc5ffd51e2fbd5d571df2"],"5f4e87790277826a2aea119328600dfb07761f32":["a7347509fad0711ac30cb15a746e9a3830a38ebd","1f5b43095f980581c7d8cc84b9899eef00ba5e1b"],"2553b00f699380c64959ccb27991289aae87be2e":["a3776dccca01c11e7046323cfad46a3b4a471233","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["00746ad002a54281629e3b6f3eb39833a33f093e","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["5f4e87790277826a2aea119328600dfb07761f32","b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","00746ad002a54281629e3b6f3eb39833a33f093e"],"e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4":["b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["1f5b43095f980581c7d8cc84b9899eef00ba5e1b","b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"a3776dccca01c11e7046323cfad46a3b4a471233":["b3d07f1ae3b58102f36f3393c397d78ba4e547a4","00746ad002a54281629e3b6f3eb39833a33f093e"],"1f5b43095f980581c7d8cc84b9899eef00ba5e1b":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["d619839baa8ce5503e496b94a9e42ad6f079293f","e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4"],"00746ad002a54281629e3b6f3eb39833a33f093e":["e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4"],"b3d07f1ae3b58102f36f3393c397d78ba4e547a4":["1f5b43095f980581c7d8cc84b9899eef00ba5e1b"],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["251550f5d19b526a76f8c5126ae7bb2d22cf8935"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b68b0aeb05de4dd5b24fc5ffd51e2fbd5d571df2":["251550f5d19b526a76f8c5126ae7bb2d22cf8935"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["b68b0aeb05de4dd5b24fc5ffd51e2fbd5d571df2","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"251550f5d19b526a76f8c5126ae7bb2d22cf8935":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5f4e87790277826a2aea119328600dfb07761f32":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","00746ad002a54281629e3b6f3eb39833a33f093e"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"a3776dccca01c11e7046323cfad46a3b4a471233":["2553b00f699380c64959ccb27991289aae87be2e"],"1f5b43095f980581c7d8cc84b9899eef00ba5e1b":["5f4e87790277826a2aea119328600dfb07761f32","d619839baa8ce5503e496b94a9e42ad6f079293f","b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"00746ad002a54281629e3b6f3eb39833a33f093e":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","d083e83f225b11e5fdd900e83d26ddb385b6955c","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"b3d07f1ae3b58102f36f3393c397d78ba4e547a4":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["5f4e87790277826a2aea119328600dfb07761f32","1f5b43095f980581c7d8cc84b9899eef00ba5e1b"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","c3a8a449466c1ff7ce2274fe73dab487256964b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}