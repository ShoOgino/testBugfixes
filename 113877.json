{"path":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","commits":[{"id":"232d48b2fd10ac5189a0ac4480ace7421be9de93","date":1334848212,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","pathOld":"/dev/null","sourceNew":"    public final void reset() {\n      it = cachedStates.iterator();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c1b87b155748a27fbed84a0ffb3f8799177451e","date":1346349018,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","sourceNew":"    @Override\n    public final void reset() throws IOException {\n      // NOTE: this acts like rewind if you call it again\n      if (input != lastReader) {\n        lastReader = input;\n        cachedStates.clear();\n        stringValue = null;\n        binaryValue = null;\n        ParseResult res = parser.parse(input, this);\n        if (res != null) {\n          stringValue = res.str;\n          binaryValue = res.bin;\n          if (res.states != null) {\n            cachedStates.addAll(res.states);\n          }\n        }\n      }\n      it = cachedStates.iterator();\n    }\n\n","sourceOld":"    public final void reset() {\n      it = cachedStates.iterator();\n    }\n\n","bugFix":null,"bugIntro":["90092e3ad74adf68ec9507e7046fe5a39039964c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","sourceNew":"    @Override\n    public final void reset() throws IOException {\n      // NOTE: this acts like rewind if you call it again\n      if (input != lastReader) {\n        lastReader = input;\n        cachedStates.clear();\n        stringValue = null;\n        binaryValue = null;\n        ParseResult res = parser.parse(input, this);\n        if (res != null) {\n          stringValue = res.str;\n          binaryValue = res.bin;\n          if (res.states != null) {\n            cachedStates.addAll(res.states);\n          }\n        }\n      }\n      it = cachedStates.iterator();\n    }\n\n","sourceOld":"    public final void reset() {\n      it = cachedStates.iterator();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338","date":1389274049,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","sourceNew":"    @Override\n    public final void reset() throws IOException {\n      // NOTE: this acts like rewind if you call it again\n      if (it == null) {\n        super.reset();\n        cachedStates.clear();\n        stringValue = null;\n        binaryValue = null;\n        ParseResult res = parser.parse(input, this);\n        if (res != null) {\n          stringValue = res.str;\n          binaryValue = res.bin;\n          if (res.states != null) {\n            cachedStates.addAll(res.states);\n          }\n        }\n      }\n      it = cachedStates.iterator();\n    }\n\n","sourceOld":"    @Override\n    public final void reset() throws IOException {\n      // NOTE: this acts like rewind if you call it again\n      if (input != lastReader) {\n        lastReader = input;\n        cachedStates.clear();\n        stringValue = null;\n        binaryValue = null;\n        ParseResult res = parser.parse(input, this);\n        if (res != null) {\n          stringValue = res.str;\n          binaryValue = res.bin;\n          if (res.states != null) {\n            cachedStates.addAll(res.states);\n          }\n        }\n      }\n      it = cachedStates.iterator();\n    }\n\n","bugFix":null,"bugIntro":["90092e3ad74adf68ec9507e7046fe5a39039964c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90092e3ad74adf68ec9507e7046fe5a39039964c","date":1453355496,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.PreAnalyzedTokenizer#reset().mjava","sourceNew":"    /**\n     * Throws a delayed exception if one was thrown from decodeInput()\n     * while reading from the input reader.\n     */\n    @Override\n    public final void reset() throws IOException {\n      super.reset();\n      if (readerConsumptionException != null) {\n        IOException e = new IOException(readerConsumptionException);\n        readerConsumptionException = null;\n        throw e;\n      }\n      it = cachedStates.iterator();\n    }\n\n","sourceOld":"    @Override\n    public final void reset() throws IOException {\n      // NOTE: this acts like rewind if you call it again\n      if (it == null) {\n        super.reset();\n        cachedStates.clear();\n        stringValue = null;\n        binaryValue = null;\n        ParseResult res = parser.parse(input, this);\n        if (res != null) {\n          stringValue = res.str;\n          binaryValue = res.bin;\n          if (res.states != null) {\n            cachedStates.addAll(res.states);\n          }\n        }\n      }\n      it = cachedStates.iterator();\n    }\n\n","bugFix":["4c1b87b155748a27fbed84a0ffb3f8799177451e","ae889fd5c8a69f6b5d130d3c895bfa5b04d07338"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c1b87b155748a27fbed84a0ffb3f8799177451e":["232d48b2fd10ac5189a0ac4480ace7421be9de93"],"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338":["4c1b87b155748a27fbed84a0ffb3f8799177451e"],"90092e3ad74adf68ec9507e7046fe5a39039964c":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"232d48b2fd10ac5189a0ac4480ace7421be9de93":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["232d48b2fd10ac5189a0ac4480ace7421be9de93","4c1b87b155748a27fbed84a0ffb3f8799177451e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["90092e3ad74adf68ec9507e7046fe5a39039964c"]},"commit2Childs":{"4c1b87b155748a27fbed84a0ffb3f8799177451e":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338","05a14b2611ead08655a2b2bdc61632eb31316e57"],"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338":["90092e3ad74adf68ec9507e7046fe5a39039964c"],"90092e3ad74adf68ec9507e7046fe5a39039964c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["232d48b2fd10ac5189a0ac4480ace7421be9de93"],"232d48b2fd10ac5189a0ac4480ace7421be9de93":["4c1b87b155748a27fbed84a0ffb3f8799177451e","05a14b2611ead08655a2b2bdc61632eb31316e57"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}