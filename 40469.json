{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","commits":[{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static Automaton determinize(Automaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ddee54b1c3df60fd6198e3aa64c78038a1be8df","date":1487008231,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    ArrayDeque<SortedIntSet.FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    ArrayDeque<SortedIntSet.FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    ArrayDeque<SortedIntSet.FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    ArrayDeque<SortedIntSet.FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d6b23a02f76f15e0dd99a6951055a45aa5c43c48"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6b23a02f76f15e0dd99a6951055a45aa5c43c48","date":1581020205,"type":3,"author":"Mike","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    // Same initial values and state will always have the same hashCode\n    FrozenIntSet initialset = new FrozenIntSet(new int[] { 0 }, 683, 0);\n\n    // Create state 0:\n    b.createState();\n\n    ArrayDeque<FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<IntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    ArrayDeque<SortedIntSet.FrozenIntSet> worklist = new ArrayDeque<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","897b06b1364bd1f658a8be7591e43f0851458e7f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"022a4de90e0479b604264ca9c2e134c996454ab3":["8b316f82baae88f5e279893a9cb7eee51fd8902f","5ddee54b1c3df60fd6198e3aa64c78038a1be8df"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"d6b23a02f76f15e0dd99a6951055a45aa5c43c48":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d6b23a02f76f15e0dd99a6951055a45aa5c43c48"],"5ddee54b1c3df60fd6198e3aa64c78038a1be8df":["8b316f82baae88f5e279893a9cb7eee51fd8902f"]},"commit2Childs":{"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["d6b23a02f76f15e0dd99a6951055a45aa5c43c48"],"d6b23a02f76f15e0dd99a6951055a45aa5c43c48":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["022a4de90e0479b604264ca9c2e134c996454ab3","5ddee54b1c3df60fd6198e3aa64c78038a1be8df"],"5ddee54b1c3df60fd6198e3aa64c78038a1be8df":["022a4de90e0479b604264ca9c2e134c996454ab3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}