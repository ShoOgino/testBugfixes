{"path":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","sourceNew":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0 ) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0 ) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","sourceNew":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0 ) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","sourceNew":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0 ) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","sourceNew":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermStates(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.ParallelArraysTermCollector#collect(BytesRef).mjava","sourceNew":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermStates(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean collect(BytesRef bytes) throws IOException {\n      final int e = terms.add(bytes);\n      final TermState state = termsEnum.termState();\n      assert state != null; \n      if (e < 0) {\n        // duplicate term: update docFreq\n        final int pos = (-e)-1;\n        array.termState[pos].register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        assert array.boost[pos] == boostAtt.getBoost() : \"boost should be equal in all segment TermsEnums\";\n      } else {\n        // new entry: we populate the entry initially\n        array.boost[e] = boostAtt.getBoost();\n        array.termState[e] = new TermContext(topReaderContext, state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        ScoringRewrite.this.checkMaxClauseCount(terms.size());\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["3e8715d826e588419327562287d5d6a8040d63d6","a6e9f769521480a623f897c0d59089b919fa4239"],"a6e9f769521480a623f897c0d59089b919fa4239":["3e8715d826e588419327562287d5d6a8040d63d6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239","d2638f781be724518ff6c2263d14a48cf6e68017"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}