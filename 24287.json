{"path":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","commits":[{"id":"487de3f55283f58d7e02a16993f8be55bbe32061","date":1502123368,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Query getResultQuery() {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      GraphQuery gq = weight.getGraphQuery();\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (gq.isUseAutn()) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(gq.getFromField()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(gq.getFromField(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"644de864e024cdc6f1631b340e14c6d32c62352b","date":1502307834,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = (matchField.hasDocValues() && !matchField.indexed())\n            ? new DocValuesTermsQuery(matchField.getName(), termList)\n            : new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":["487de3f55283f58d7e02a16993f8be55bbe32061"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = (matchField.hasDocValues() && !matchField.indexed())\n            ? new DocValuesTermsQuery(matchField.getName(), termList)\n            : new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Query getResultQuery() {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      GraphQuery gq = weight.getGraphQuery();\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (gq.isUseAutn()) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(gq.getFromField()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(gq.getFromField(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = (matchField.hasDocValues() && !matchField.indexed())\n            ? new DocValuesTermsQuery(matchField.getName(), termList)\n            : new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba33781da68babcaa5828121b443d3eb5c9d8480","date":1590595589,"type":4,"author":"Erick Erickson","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = (matchField.hasDocValues() && !matchField.indexed())\n            ? new DocValuesTermsQuery(matchField.getName(), termList)\n            : new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","487de3f55283f58d7e02a16993f8be55bbe32061"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","644de864e024cdc6f1631b340e14c6d32c62352b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"487de3f55283f58d7e02a16993f8be55bbe32061":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","644de864e024cdc6f1631b340e14c6d32c62352b"],"644de864e024cdc6f1631b340e14c6d32c62352b":["487de3f55283f58d7e02a16993f8be55bbe32061"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["644de864e024cdc6f1631b340e14c6d32c62352b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba33781da68babcaa5828121b443d3eb5c9d8480"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","58884af1f68e9d61c217c753fbd6266d86a63b14","487de3f55283f58d7e02a16993f8be55bbe32061"],"487de3f55283f58d7e02a16993f8be55bbe32061":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","644de864e024cdc6f1631b340e14c6d32c62352b"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"644de864e024cdc6f1631b340e14c6d32c62352b":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","ba33781da68babcaa5828121b443d3eb5c9d8480"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}