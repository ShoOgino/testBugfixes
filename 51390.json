{"path":"sandbox/contributions/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","commits":[{"id":"e561bdf81b5b983639de610f7c878f3e2382bf24","date":1099437089,"type":0,"author":"David Spencer","isMerge":false,"pathNew":"sandbox/contributions/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param IndexReader the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa8dcd4adc562c6e8da67c42872ef9194f8598fa","date":1108145465,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"sandbox/contributions/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param IndexReader the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param IndexReader the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa8dcd4adc562c6e8da67c42872ef9194f8598fa":["e561bdf81b5b983639de610f7c878f3e2382bf24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e561bdf81b5b983639de610f7c878f3e2382bf24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa8dcd4adc562c6e8da67c42872ef9194f8598fa"]},"commit2Childs":{"aa8dcd4adc562c6e8da67c42872ef9194f8598fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e561bdf81b5b983639de610f7c878f3e2382bf24"],"e561bdf81b5b983639de610f7c878f3e2382bf24":["aa8dcd4adc562c6e8da67c42872ef9194f8598fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}