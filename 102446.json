{"path":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","commits":[{"id":"9cf250cb8fdff62f4b753866d44e5bf59bfd1616","date":1483789944,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, ScoreMode.COMPLETE_NO_SCORES);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, ScoreMode.COMPLETE_NO_SCORES);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createWeight(searcher.rewrite(fastMatchQuery), ScoreMode.COMPLETE_NO_SCORES, 1);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, ScoreMode.COMPLETE_NO_SCORES);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createWeight(searcher.rewrite(fastMatchQuery), ScoreMode.COMPLETE_NO_SCORES, 1);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, ScoreMode.COMPLETE_NO_SCORES);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d58e44159788900f4a2113b84463dc3fbbf80f20":["417142ff08fda9cf0b72d5133e63097a166c6458","475584d5e08a22ad3fc7babefe006d77bc744567"],"475584d5e08a22ad3fc7babefe006d77bc744567":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"9cf250cb8fdff62f4b753866d44e5bf59bfd1616":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"417142ff08fda9cf0b72d5133e63097a166c6458":["9cf250cb8fdff62f4b753866d44e5bf59bfd1616","9fc47cb7b4346802411bb432f501ed0673d7119e"]},"commit2Childs":{"d58e44159788900f4a2113b84463dc3fbbf80f20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"9cf250cb8fdff62f4b753866d44e5bf59bfd1616":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"417142ff08fda9cf0b72d5133e63097a166c6458":["d58e44159788900f4a2113b84463dc3fbbf80f20","475584d5e08a22ad3fc7babefe006d77bc744567"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}