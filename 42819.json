{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","commits":[{"id":"09603b329b773f13c5bc71091a8e683671cbc9ba","date":1399576172,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"/dev/null","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n    }\n    \n    // TODO: mergepolicy, mergescheduler, etc have mutable state on indexwriter\n    // every setter must be tested\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2073c4bcb23ab968f7b7dd186dcb3ae5c26ad2","date":1399578209,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(random(), 1, 4);\n        int maxMergeCount = TestUtil.nextInt(random(), maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n    }\n    \n    // TODO: mergepolicy, etc have mutable state on indexwriter\n    // every setter must be tested\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n    }\n    \n    // TODO: mergepolicy, mergescheduler, etc have mutable state on indexwriter\n    // every setter must be tested\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf577160741c5af67dd773af2d3f8d21e9a69a0e","date":1399579121,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(random(), 1, 4);\n        int maxMergeCount = TestUtil.nextInt(random(), maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n    }\n    \n    // TODO: mergepolicy, etc have mutable state on indexwriter\n    // every setter must be tested\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a677119c295ef994a716ca33562fac8d3bae1bac","date":1399580014,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65d74bb6a98cc85f8bf3264929e5015175ab5060","date":1399625164,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static synchronized void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"221f4466c3d651221b8ed1ee82fea94dd0df7fa2","date":1399637078,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static synchronized void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00d7ec41e1c0ac55be361ea80e377bb7ea8f2bd1","date":1399638359,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRam = r.nextBoolean();\n        if (flushByRam) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      boolean flushByRam = r.nextBoolean();\n      if (flushByRam) { \n        c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n        c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      } else {\n        if (rarely(r)) {\n          // crazy value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n        } else {\n          // reasonable value\n          c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n        }\n        c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb","date":1400265925,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = random().nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRam = r.nextBoolean();\n        if (flushByRam) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = random().nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRam = r.nextBoolean();\n        if (flushByRam) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4ce441f8e4ad5db9698284d95ee55efe098a4f1","date":1408563380,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = random().nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2131047ecceac64b54ba70feec3d26bbd7e483d7","date":1411862069,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change merge integrity check parameters\n      c.setCheckIntegrityAtMerge(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08667204dc771b0e987fa2c8d269326d0f60bcac","date":1429542180,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings to:\\n\" + c);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5592cc96e61043beee6ba728228191892f495d54","date":1434060173,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        ((ConcurrentMergeScheduler)ms).setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change warmer parameters\n      if (r.nextBoolean()) {\n        c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n      } else {\n        c.setMergedSegmentWarmer(null);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change buffered deletes parameters\n      boolean limitBufferedDeletes = r.nextBoolean();\n      if (limitBufferedDeletes) {\n        c.setMaxBufferedDeleteTerms(TestUtil.nextInt(r, 1, 1000));\n      } else {\n        c.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a90cc8c90aa53ddf51fbd15019989ac269514a3","date":1531845066,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setDeletesPctAllowed(20 + random().nextDouble() * 30);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setDeletesPctAllowed(20 + random().nextDouble() * 30);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setReclaimDeletesWeight(r.nextDouble()*4);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffe681f212e5073c69955b4ad22946794c84940","date":1560182863,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeChangeLiveIndexWriterConfig(Random,LiveIndexWriterConfig).mjava","sourceNew":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setDeletesPctAllowed(20 + random().nextDouble() * 30);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \").append(previousLines[i]).append(\"\\n\");\n            diff.append(\"+ \").append(currentLines[i]).append(\"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","sourceOld":"  // if you want it in LiveIndexWriterConfig: it must and will be tested here.\n  public static void maybeChangeLiveIndexWriterConfig(Random r, LiveIndexWriterConfig c) {\n    boolean didChange = false;\n\n    String previous = c.toString();\n    \n    if (rarely(r)) {\n      // change flush parameters:\n      // this is complicated because the api requires you \"invoke setters in a magical order!\"\n      // LUCENE-5661: workaround for race conditions in the API\n      synchronized (c) {\n        boolean flushByRAM;\n        switch (liveIWCFlushMode) {\n        case BY_RAM:\n          flushByRAM = true;\n          break;\n        case BY_DOCS:\n          flushByRAM = false;\n          break;\n        case EITHER:\n          flushByRAM = r.nextBoolean();\n          break;\n        default:\n          throw new AssertionError();\n        }\n        if (flushByRAM) { \n          c.setRAMBufferSizeMB(TestUtil.nextInt(r, 1, 10));\n          c.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        } else {\n          if (rarely(r)) {\n            // crazy value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n          } else {\n            // reasonable value\n            c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n          }\n          c.setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      IndexWriter.IndexReaderWarmer curWarmer = c.getMergedSegmentWarmer();\n      if (curWarmer == null || curWarmer instanceof SimpleMergedSegmentWarmer) {\n        // change warmer parameters\n        if (r.nextBoolean()) {\n          c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n        } else {\n          c.setMergedSegmentWarmer(null);\n        }\n      }\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CFS flush parameters\n      c.setUseCompoundFile(r.nextBoolean());\n      didChange = true;\n    }\n    \n    if (rarely(r)) {\n      // change CMS merge parameters\n      MergeScheduler ms = c.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;\n        int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n        int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n        boolean enableAutoIOThrottle = random().nextBoolean();\n        if (enableAutoIOThrottle) {\n          cms.enableAutoIOThrottle();\n        } else {\n          cms.disableAutoIOThrottle();\n        }\n        cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n        didChange = true;\n      }\n    }\n    \n    if (rarely(r)) {\n      MergePolicy mp = c.getMergePolicy();\n      configureRandom(r, mp);\n      if (mp instanceof LogMergePolicy) {\n        LogMergePolicy logmp = (LogMergePolicy) mp;\n        logmp.setCalibrateSizeByDeletes(r.nextBoolean());\n        if (rarely(r)) {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 2, 9));\n        } else {\n          logmp.setMergeFactor(TestUtil.nextInt(r, 10, 50));\n        }\n      } else if (mp instanceof TieredMergePolicy) {\n        TieredMergePolicy tmp = (TieredMergePolicy) mp;\n        if (rarely(r)) {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 2, 9));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 2, 9));\n        } else {\n          tmp.setMaxMergeAtOnce(TestUtil.nextInt(r, 10, 50));\n          tmp.setMaxMergeAtOnceExplicit(TestUtil.nextInt(r, 10, 50));\n        }\n        if (rarely(r)) {\n          tmp.setMaxMergedSegmentMB(0.2 + r.nextDouble() * 2.0);\n        } else {\n          tmp.setMaxMergedSegmentMB(r.nextDouble() * 100);\n        }\n        tmp.setFloorSegmentMB(0.2 + r.nextDouble() * 2.0);\n        tmp.setForceMergeDeletesPctAllowed(0.0 + r.nextDouble() * 30.0);\n        if (rarely(r)) {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 2, 20));\n        } else {\n          tmp.setSegmentsPerTier(TestUtil.nextInt(r, 10, 50));\n        }\n        configureRandom(r, tmp);\n        tmp.setDeletesPctAllowed(20 + random().nextDouble() * 30);\n      }\n      didChange = true;\n    }\n    if (VERBOSE && didChange) {\n      String current = c.toString();\n      String previousLines[] = previous.split(\"\\n\");\n      String currentLines[] = current.split(\"\\n\");\n      StringBuilder diff = new StringBuilder();\n\n      // this should always be the case, diff each line\n      if (previousLines.length == currentLines.length) {\n        for (int i = 0; i < previousLines.length; i++) {\n          if (!previousLines[i].equals(currentLines[i])) {\n            diff.append(\"- \" + previousLines[i] + \"\\n\");\n            diff.append(\"+ \" + currentLines[i] + \"\\n\");\n          }\n        }\n      } else {\n        // but just in case of something ridiculous...\n        diff.append(current.toString());\n      }\n      \n      // its possible to be empty, if we \"change\" a value to what it had before.\n      if (diff.length() > 0) {\n        System.out.println(\"NOTE: LuceneTestCase: randomly changed IWC's live settings:\");\n        System.out.println(diff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ffe681f212e5073c69955b4ad22946794c84940":["4a90cc8c90aa53ddf51fbd15019989ac269514a3"],"00d7ec41e1c0ac55be361ea80e377bb7ea8f2bd1":["221f4466c3d651221b8ed1ee82fea94dd0df7fa2"],"221f4466c3d651221b8ed1ee82fea94dd0df7fa2":["65d74bb6a98cc85f8bf3264929e5015175ab5060"],"cf577160741c5af67dd773af2d3f8d21e9a69a0e":["6c2073c4bcb23ab968f7b7dd186dcb3ae5c26ad2"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["68496c2200e559fb7802f7575427b7a482659afb"],"a677119c295ef994a716ca33562fac8d3bae1bac":["cf577160741c5af67dd773af2d3f8d21e9a69a0e"],"4a90cc8c90aa53ddf51fbd15019989ac269514a3":["28288370235ed02234a64753cdbf0c6ec096304a"],"65d74bb6a98cc85f8bf3264929e5015175ab5060":["a677119c295ef994a716ca33562fac8d3bae1bac"],"56572ec06f1407c066d6b7399413178b33176cd8":["00d7ec41e1c0ac55be361ea80e377bb7ea8f2bd1","5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"08667204dc771b0e987fa2c8d269326d0f60bcac":["9bb9a29a5e71a90295f175df8919802993142c9a"],"f4ce441f8e4ad5db9698284d95ee55efe098a4f1":["5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"09603b329b773f13c5bc71091a8e683671cbc9ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["68496c2200e559fb7802f7575427b7a482659afb","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb":["00d7ec41e1c0ac55be361ea80e377bb7ea8f2bd1"],"28288370235ed02234a64753cdbf0c6ec096304a":["68496c2200e559fb7802f7575427b7a482659afb","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"6c2073c4bcb23ab968f7b7dd186dcb3ae5c26ad2":["09603b329b773f13c5bc71091a8e683671cbc9ba"],"5592cc96e61043beee6ba728228191892f495d54":["08667204dc771b0e987fa2c8d269326d0f60bcac"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","4a90cc8c90aa53ddf51fbd15019989ac269514a3"],"9bb9a29a5e71a90295f175df8919802993142c9a":["f4ce441f8e4ad5db9698284d95ee55efe098a4f1","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["f4ce441f8e4ad5db9698284d95ee55efe098a4f1"],"68496c2200e559fb7802f7575427b7a482659afb":["5592cc96e61043beee6ba728228191892f495d54","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2ffe681f212e5073c69955b4ad22946794c84940"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["5592cc96e61043beee6ba728228191892f495d54"]},"commit2Childs":{"2ffe681f212e5073c69955b4ad22946794c84940":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"00d7ec41e1c0ac55be361ea80e377bb7ea8f2bd1":["56572ec06f1407c066d6b7399413178b33176cd8","5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"221f4466c3d651221b8ed1ee82fea94dd0df7fa2":["00d7ec41e1c0ac55be361ea80e377bb7ea8f2bd1"],"cf577160741c5af67dd773af2d3f8d21e9a69a0e":["a677119c295ef994a716ca33562fac8d3bae1bac"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a677119c295ef994a716ca33562fac8d3bae1bac":["65d74bb6a98cc85f8bf3264929e5015175ab5060"],"4a90cc8c90aa53ddf51fbd15019989ac269514a3":["2ffe681f212e5073c69955b4ad22946794c84940","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"65d74bb6a98cc85f8bf3264929e5015175ab5060":["221f4466c3d651221b8ed1ee82fea94dd0df7fa2"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"08667204dc771b0e987fa2c8d269326d0f60bcac":["5592cc96e61043beee6ba728228191892f495d54"],"f4ce441f8e4ad5db9698284d95ee55efe098a4f1":["9bb9a29a5e71a90295f175df8919802993142c9a","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"09603b329b773f13c5bc71091a8e683671cbc9ba":["6c2073c4bcb23ab968f7b7dd186dcb3ae5c26ad2"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["4a90cc8c90aa53ddf51fbd15019989ac269514a3","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb":["56572ec06f1407c066d6b7399413178b33176cd8","f4ce441f8e4ad5db9698284d95ee55efe098a4f1"],"6c2073c4bcb23ab968f7b7dd186dcb3ae5c26ad2":["cf577160741c5af67dd773af2d3f8d21e9a69a0e"],"5592cc96e61043beee6ba728228191892f495d54":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"9bb9a29a5e71a90295f175df8919802993142c9a":["08667204dc771b0e987fa2c8d269326d0f60bcac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09603b329b773f13c5bc71091a8e683671cbc9ba"],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["9bb9a29a5e71a90295f175df8919802993142c9a"],"68496c2200e559fb7802f7575427b7a482659afb":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}