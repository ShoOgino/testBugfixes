{"path":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","commits":[{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>Commits all pending updates (added & deleted documents)\n   * to the index, and syncs all referenced index files,\n   * such that a reader will see the changes.  Note that\n   * this does not wait for any running background merges to\n   * finish.  This may be a costly operation, so you should\n   * test the cost in your application and do it only when\n   * really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss (though, see the note below).  Note that\n   * this does not wait for any running background merges to\n   * finish.  This may be a costly operation, so you should\n   * test the cost in your application and do it only when\n   * really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n\n    message(\"commit: start\");\n\n    if (autoCommit || pendingCommit == null) {\n      message(\"commit: now prepare\");\n      prepareCommit(true);\n    } else\n      message(\"commit: already prepared\");\n\n    finishCommit();\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending updates (added & deleted documents)\n   * to the index, and syncs all referenced index files,\n   * such that a reader will see the changes.  Note that\n   * this does not wait for any running background merges to\n   * finish.  This may be a costly operation, so you should\n   * test the cost in your application and do it only when\n   * really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2586f96f60332eb97ecd2934b0763791462568b2","date":1220116589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  public final void commit() throws CorruptIndexException, IOException {\n\n    ensureOpen();\n\n    // Only let one thread do the prepare/finish at a time\n    waitForCommit();\n\n    try {\n      message(\"commit: start\");\n\n      if (autoCommit || pendingCommit == null) {\n        message(\"commit: now prepare\");\n        prepareCommit(true);\n      } else\n        message(\"commit: already prepared\");\n\n      finishCommit();\n    } finally {\n      doneCommit();\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss (though, see the note below).  Note that\n   * this does not wait for any running background merges to\n   * finish.  This may be a costly operation, so you should\n   * test the cost in your application and do it only when\n   * really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n\n    message(\"commit: start\");\n\n    if (autoCommit || pendingCommit == null) {\n      message(\"commit: now prepare\");\n      prepareCommit(true);\n    } else\n      message(\"commit: already prepared\");\n\n    finishCommit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc","date":1221503613,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss.  Note that this does not wait for any\n   * running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   */\n\n  public final void commit() throws CorruptIndexException, IOException {\n\n    ensureOpen();\n\n    // Only let one thread do the prepare/finish at a time\n    waitForCommit();\n\n    try {\n      message(\"commit: start\");\n\n      if (autoCommit || pendingCommit == null) {\n        message(\"commit: now prepare\");\n        prepareCommit(true);\n      } else\n        message(\"commit: already prepared\");\n\n      finishCommit();\n    } finally {\n      doneCommit();\n    }\n  }\n\n","sourceOld":"  public final void commit() throws CorruptIndexException, IOException {\n\n    ensureOpen();\n\n    // Only let one thread do the prepare/finish at a time\n    waitForCommit();\n\n    try {\n      message(\"commit: start\");\n\n      if (autoCommit || pendingCommit == null) {\n        message(\"commit: now prepare\");\n        prepareCommit(true);\n      } else\n        message(\"commit: already prepared\");\n\n      finishCommit();\n    } finally {\n      doneCommit();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7fe9985d49937438f4dad2dbfabc93f8196c8b3","date":1222123293,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss.  Note that this does not wait for any\n   * running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * @see #prepareCommit\n   */\n\n  public final void commit() throws CorruptIndexException, IOException {\n\n    ensureOpen();\n\n    // Only let one thread do the prepare/finish at a time\n    waitForCommit();\n\n    try {\n      message(\"commit: start\");\n\n      if (autoCommit || pendingCommit == null) {\n        message(\"commit: now prepare\");\n        prepareCommit(true);\n      } else\n        message(\"commit: already prepared\");\n\n      finishCommit();\n    } finally {\n      doneCommit();\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss.  Note that this does not wait for any\n   * running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   */\n\n  public final void commit() throws CorruptIndexException, IOException {\n\n    ensureOpen();\n\n    // Only let one thread do the prepare/finish at a time\n    waitForCommit();\n\n    try {\n      message(\"commit: start\");\n\n      if (autoCommit || pendingCommit == null) {\n        message(\"commit: now prepare\");\n        prepareCommit(true);\n      } else\n        message(\"commit: already prepared\");\n\n      finishCommit();\n    } finally {\n      doneCommit();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b1444275c93a8051a6fe6158639467a144ae0a4","date":1224502393,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /** Commits all changes to the index.\n   *  @see #commit(String) */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss.  Note that this does not wait for any\n   * running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * @see #prepareCommit\n   */\n\n  public final void commit() throws CorruptIndexException, IOException {\n\n    ensureOpen();\n\n    // Only let one thread do the prepare/finish at a time\n    waitForCommit();\n\n    try {\n      message(\"commit: start\");\n\n      if (autoCommit || pendingCommit == null) {\n        message(\"commit: now prepare\");\n        prepareCommit(true);\n      } else\n        message(\"commit: already prepared\");\n\n      finishCommit();\n    } finally {\n      doneCommit();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9665d17707cc21b1db995118ff36129723139ab","date":1225384420,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss.  Note that this does not wait for any\n   * running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(String)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /** Commits all changes to the index.\n   *  @see #commit(String) */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9d77409ef691522dec92aba98c936e9122090c6","date":1238703417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending changes (added & deleted\n   * documents, optimizations, segment merges, added\n   * indexes, etc.) to the index, and syncs all referenced\n   * index files, such that a reader will see the changes\n   * and the index updates will survive an OS or machine\n   * crash or power loss.  Note that this does not wait for\n   * any running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(String)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending updates (added & deleted\n   * documents) to the index, and syncs all referenced index\n   * files, such that a reader will see the changes and the\n   * index updates will survive an OS or machine crash or\n   * power loss.  Note that this does not wait for any\n   * running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(String)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3ab91f3bb602daf6393fa7f78b11afd3400d669","date":1243282044,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending changes (added & deleted\n   * documents, optimizations, segment merges, added\n   * indexes, etc.) to the index, and syncs all referenced\n   * index files, such that a reader will see the changes\n   * and the index updates will survive an OS or machine\n   * crash or power loss.  Note that this does not wait for\n   * any running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(Map)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending changes (added & deleted\n   * documents, optimizations, segment merges, added\n   * indexes, etc.) to the index, and syncs all referenced\n   * index files, such that a reader will see the changes\n   * and the index updates will survive an OS or machine\n   * crash or power loss.  Note that this does not wait for\n   * any running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(String)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit().mjava","sourceNew":"  /**\n   * <p>Commits all pending changes (added & deleted\n   * documents, optimizations, segment merges, added\n   * indexes, etc.) to the index, and syncs all referenced\n   * index files, such that a reader will see the changes\n   * and the index updates will survive an OS or machine\n   * crash or power loss.  Note that this does not wait for\n   * any running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(Map)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /**\n   * <p>Commits all pending changes (added & deleted\n   * documents, optimizations, segment merges, added\n   * indexes, etc.) to the index, and syncs all referenced\n   * index files, such that a reader will see the changes\n   * and the index updates will survive an OS or machine\n   * crash or power loss.  Note that this does not wait for\n   * any running background merges to finish.  This may be a\n   * costly operation, so you should test the cost in your\n   * application and do it only when really necessary.</p>\n   *\n   * <p> Note that this operation calls Directory.sync on\n   * the index files.  That call should not return until the\n   * file contents & metadata are on stable storage.  For\n   * FSDirectory, this calls the OS's fsync.  But, beware:\n   * some hardware devices may in fact cache writes even\n   * during fsync, and return before the bits are actually\n   * on stable storage, to give the appearance of faster\n   * performance.  If you have such a device, and it does\n   * not have a battery backup (for example) then on power\n   * loss it may still lose data.  Lucene cannot guarantee\n   * consistency on such devices.  </p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @see #prepareCommit\n   * @see #commit(Map)\n   */\n  public final void commit() throws CorruptIndexException, IOException {\n    commit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e9665d17707cc21b1db995118ff36129723139ab":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"4b1444275c93a8051a6fe6158639467a144ae0a4":["b7fe9985d49937438f4dad2dbfabc93f8196c8b3"],"b7fe9985d49937438f4dad2dbfabc93f8196c8b3":["05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc"],"455aeff4fef915340c5b19d71d5e147034e83093":["e82780afe6097066eb5befb86e9432f077667e3d"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["f9d77409ef691522dec92aba98c936e9122090c6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f9d77409ef691522dec92aba98c936e9122090c6":["e9665d17707cc21b1db995118ff36129723139ab"],"e82780afe6097066eb5befb86e9432f077667e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2586f96f60332eb97ecd2934b0763791462568b2":["455aeff4fef915340c5b19d71d5e147034e83093"],"05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc":["2586f96f60332eb97ecd2934b0763791462568b2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"]},"commit2Childs":{"e9665d17707cc21b1db995118ff36129723139ab":["f9d77409ef691522dec92aba98c936e9122090c6"],"4b1444275c93a8051a6fe6158639467a144ae0a4":["e9665d17707cc21b1db995118ff36129723139ab"],"b7fe9985d49937438f4dad2dbfabc93f8196c8b3":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"455aeff4fef915340c5b19d71d5e147034e83093":["2586f96f60332eb97ecd2934b0763791462568b2"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e82780afe6097066eb5befb86e9432f077667e3d"],"f9d77409ef691522dec92aba98c936e9122090c6":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"],"e82780afe6097066eb5befb86e9432f077667e3d":["455aeff4fef915340c5b19d71d5e147034e83093"],"2586f96f60332eb97ecd2934b0763791462568b2":["05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc"],"05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc":["b7fe9985d49937438f4dad2dbfabc93f8196c8b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}