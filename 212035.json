{"path":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#setParams(String).mjava","commits":[{"id":"7bb889a868ab9d608bde8136f42ed7234a3a927b","date":1359393528,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#setParams(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sets the params.\n   * Analysis component factory names may optionally include the \"Factory\" suffix.\n   *\n   * @param params analysis pipeline specification: name, (optional) positionIncrementGap,\n   *               (optional) offsetGap, 0+ CharFilterFactory's, 1 TokenizerFactory,\n   *               and 0+ TokenFilterFactory's\n   */\n  @Override\n  public void setParams(String params) {\n    super.setParams(params);\n    ArgType expectedArgType = ArgType.ANALYZER_ARG;\n\n    final StreamTokenizer stok = new StreamTokenizer(new StringReader(params));\n    stok.commentChar('#');\n    stok.quoteChar('\"');\n    stok.quoteChar('\\'');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar(':');\n    stok.ordinaryChar(',');\n    try {\n      while (stok.nextToken() != StreamTokenizer.TT_EOF) {\n        switch (stok.ttype) {\n          case ',': {\n            // Do nothing\n            break;\n          }\n          case StreamTokenizer.TT_WORD: {\n            if (expectedArgType.equals(ArgType.ANALYZER_ARG)) {\n              final String argName = stok.sval;\n              if ( ! argName.equalsIgnoreCase(\"name\")\n                  && ! argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  && ! argName.equalsIgnoreCase(\"offsetGap\")) {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing 'name' param to AnalyzerFactory: '\" + params + \"'\");\n              }\n              stok.nextToken();\n              if (stok.ttype != ':') {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n              }\n\n              stok.nextToken();\n              String argValue = stok.sval;\n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER: {\n                  argValue = Double.toString(stok.nval);\n                  // Drop the \".0\" from numbers, for integer arguments\n                  argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst(\"\");\n                  // Intentional fallthrough\n                }\n                case '\"':\n                case '\\'':\n                case StreamTokenizer.TT_WORD: {\n                  if (argName.equalsIgnoreCase(\"name\")) {\n                    factoryName = argValue;\n                    expectedArgType = ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER;\n                  } else {\n                    int intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(argValue);\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + argValue + \"'\", e);\n                    }\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                  }\n                  break;\n                }\n                case StreamTokenizer.TT_EOF: {\n                  throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                }\n                default: {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                }\n              }\n            } else if (expectedArgType.equals(ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER)) {\n              final String argName = stok.sval;\n\n              if (argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  || argName.equalsIgnoreCase(\"offsetGap\")) {\n                stok.nextToken();\n                if (stok.ttype != ':') {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n                }\n                stok.nextToken();\n                int intArgValue = (int)stok.nval;\n                switch (stok.ttype) {\n                  case '\"':\n                  case '\\'':\n                  case StreamTokenizer.TT_WORD: {\n                    intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(stok.sval.trim());\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + stok.sval + \"'\", e);\n                    }\n                    // Intentional fall-through\n                  }\n                  case StreamTokenizer.TT_NUMBER: {\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                    break;\n                  }\n                  case StreamTokenizer.TT_EOF: {\n                    throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                  }\n                  default: {\n                    throw new RuntimeException\n                        (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                  }\n                }\n                break;\n              }\n              try {\n                final Class<? extends CharFilterFactory> clazz;\n                clazz = lookupAnalysisClass(argName, CharFilterFactory.class);\n                createAnalysisPipelineComponent(stok, clazz);\n              } catch (IllegalArgumentException e) {\n                try {\n                  final Class<? extends TokenizerFactory> clazz;\n                  clazz = lookupAnalysisClass(argName, TokenizerFactory.class);\n                  createAnalysisPipelineComponent(stok, clazz);\n                  expectedArgType = ArgType.TOKENFILTER;\n                } catch (IllegalArgumentException e2) {\n                  throw new RuntimeException(\"Line #\" + lineno(stok) + \": Can't find class '\"\n                                             + argName + \"' as CharFilterFactory or TokenizerFactory\");\n                }\n              }\n            } else { // expectedArgType = ArgType.TOKENFILTER\n              final String className = stok.sval;\n              final Class<? extends TokenFilterFactory> clazz;\n              try {\n                clazz = lookupAnalysisClass(className, TokenFilterFactory.class);\n              } catch (IllegalArgumentException e) {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Can't find class '\" + className + \"' as TokenFilterFactory\");\n              }\n              createAnalysisPipelineComponent(stok, clazz);\n            }\n            break;\n          }\n          default: {\n            throw new RuntimeException(\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n          }\n        }\n      }\n    } catch (RuntimeException e) {\n      if (e.getMessage().startsWith(\"Line #\")) {\n        throw e;\n      } else {\n        throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", e);\n      }\n    } catch (Throwable t) {\n      throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", t);\n    }\n\n    final AnalyzerFactory analyzerFactory = new AnalyzerFactory\n        (charFilterFactories, tokenizerFactory, tokenFilterFactories);\n    analyzerFactory.setPositionIncrementGap(positionIncrementGap);\n    analyzerFactory.setOffsetGap(offsetGap);\n    getRunData().getAnalyzerFactories().put(factoryName, analyzerFactory);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":0,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#setParams(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sets the params.\n   * Analysis component factory names may optionally include the \"Factory\" suffix.\n   *\n   * @param params analysis pipeline specification: name, (optional) positionIncrementGap,\n   *               (optional) offsetGap, 0+ CharFilterFactory's, 1 TokenizerFactory,\n   *               and 0+ TokenFilterFactory's\n   */\n  @Override\n  public void setParams(String params) {\n    super.setParams(params);\n    ArgType expectedArgType = ArgType.ANALYZER_ARG;\n\n    final StreamTokenizer stok = new StreamTokenizer(new StringReader(params));\n    stok.commentChar('#');\n    stok.quoteChar('\"');\n    stok.quoteChar('\\'');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar(':');\n    stok.ordinaryChar(',');\n    try {\n      while (stok.nextToken() != StreamTokenizer.TT_EOF) {\n        switch (stok.ttype) {\n          case ',': {\n            // Do nothing\n            break;\n          }\n          case StreamTokenizer.TT_WORD: {\n            if (expectedArgType.equals(ArgType.ANALYZER_ARG)) {\n              final String argName = stok.sval;\n              if ( ! argName.equalsIgnoreCase(\"name\")\n                  && ! argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  && ! argName.equalsIgnoreCase(\"offsetGap\")) {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing 'name' param to AnalyzerFactory: '\" + params + \"'\");\n              }\n              stok.nextToken();\n              if (stok.ttype != ':') {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n              }\n\n              stok.nextToken();\n              String argValue = stok.sval;\n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER: {\n                  argValue = Double.toString(stok.nval);\n                  // Drop the \".0\" from numbers, for integer arguments\n                  argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst(\"\");\n                  // Intentional fallthrough\n                }\n                case '\"':\n                case '\\'':\n                case StreamTokenizer.TT_WORD: {\n                  if (argName.equalsIgnoreCase(\"name\")) {\n                    factoryName = argValue;\n                    expectedArgType = ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER;\n                  } else {\n                    int intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(argValue);\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + argValue + \"'\", e);\n                    }\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                  }\n                  break;\n                }\n                case StreamTokenizer.TT_EOF: {\n                  throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                }\n                default: {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                }\n              }\n            } else if (expectedArgType.equals(ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER)) {\n              final String argName = stok.sval;\n\n              if (argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  || argName.equalsIgnoreCase(\"offsetGap\")) {\n                stok.nextToken();\n                if (stok.ttype != ':') {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n                }\n                stok.nextToken();\n                int intArgValue = (int)stok.nval;\n                switch (stok.ttype) {\n                  case '\"':\n                  case '\\'':\n                  case StreamTokenizer.TT_WORD: {\n                    intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(stok.sval.trim());\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + stok.sval + \"'\", e);\n                    }\n                    // Intentional fall-through\n                  }\n                  case StreamTokenizer.TT_NUMBER: {\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                    break;\n                  }\n                  case StreamTokenizer.TT_EOF: {\n                    throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                  }\n                  default: {\n                    throw new RuntimeException\n                        (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                  }\n                }\n                break;\n              }\n              try {\n                final Class<? extends CharFilterFactory> clazz;\n                clazz = lookupAnalysisClass(argName, CharFilterFactory.class);\n                createAnalysisPipelineComponent(stok, clazz);\n              } catch (IllegalArgumentException e) {\n                try {\n                  final Class<? extends TokenizerFactory> clazz;\n                  clazz = lookupAnalysisClass(argName, TokenizerFactory.class);\n                  createAnalysisPipelineComponent(stok, clazz);\n                  expectedArgType = ArgType.TOKENFILTER;\n                } catch (IllegalArgumentException e2) {\n                  throw new RuntimeException(\"Line #\" + lineno(stok) + \": Can't find class '\"\n                                             + argName + \"' as CharFilterFactory or TokenizerFactory\");\n                }\n              }\n            } else { // expectedArgType = ArgType.TOKENFILTER\n              final String className = stok.sval;\n              final Class<? extends TokenFilterFactory> clazz;\n              try {\n                clazz = lookupAnalysisClass(className, TokenFilterFactory.class);\n              } catch (IllegalArgumentException e) {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Can't find class '\" + className + \"' as TokenFilterFactory\");\n              }\n              createAnalysisPipelineComponent(stok, clazz);\n            }\n            break;\n          }\n          default: {\n            throw new RuntimeException(\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n          }\n        }\n      }\n    } catch (RuntimeException e) {\n      if (e.getMessage().startsWith(\"Line #\")) {\n        throw e;\n      } else {\n        throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", e);\n      }\n    } catch (Throwable t) {\n      throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", t);\n    }\n\n    final AnalyzerFactory analyzerFactory = new AnalyzerFactory\n        (charFilterFactories, tokenizerFactory, tokenFilterFactories);\n    analyzerFactory.setPositionIncrementGap(positionIncrementGap);\n    analyzerFactory.setOffsetGap(offsetGap);\n    getRunData().getAnalyzerFactories().put(factoryName, analyzerFactory);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dc707eb4c159b3029aac235f5f36bb3c7b58ee4","date":1439660917,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#setParams(String).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#setParams(String).mjava","sourceNew":"  /**\n   * Sets the params.\n   * Analysis component factory names may optionally include the \"Factory\" suffix.\n   *\n   * @param params analysis pipeline specification: name, (optional) positionIncrementGap,\n   *               (optional) offsetGap, 0+ CharFilterFactory's, 1 TokenizerFactory,\n   *               and 0+ TokenFilterFactory's\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public void setParams(String params) {\n    super.setParams(params);\n    ArgType expectedArgType = ArgType.ANALYZER_ARG;\n\n    final StreamTokenizer stok = new StreamTokenizer(new StringReader(params));\n    stok.commentChar('#');\n    stok.quoteChar('\"');\n    stok.quoteChar('\\'');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar(':');\n    stok.ordinaryChar(',');\n    try {\n      while (stok.nextToken() != StreamTokenizer.TT_EOF) {\n        switch (stok.ttype) {\n          case ',': {\n            // Do nothing\n            break;\n          }\n          case StreamTokenizer.TT_WORD: {\n            if (expectedArgType.equals(ArgType.ANALYZER_ARG)) {\n              final String argName = stok.sval;\n              if ( ! argName.equalsIgnoreCase(\"name\")\n                  && ! argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  && ! argName.equalsIgnoreCase(\"offsetGap\")) {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing 'name' param to AnalyzerFactory: '\" + params + \"'\");\n              }\n              stok.nextToken();\n              if (stok.ttype != ':') {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n              }\n\n              stok.nextToken();\n              String argValue = stok.sval;\n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER: {\n                  argValue = Double.toString(stok.nval);\n                  // Drop the \".0\" from numbers, for integer arguments\n                  argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst(\"\");\n                  // Intentional fallthrough\n                }\n                case '\"':\n                case '\\'':\n                case StreamTokenizer.TT_WORD: {\n                  if (argName.equalsIgnoreCase(\"name\")) {\n                    factoryName = argValue;\n                    expectedArgType = ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER;\n                  } else {\n                    int intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(argValue);\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + argValue + \"'\", e);\n                    }\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                  }\n                  break;\n                }\n                case StreamTokenizer.TT_EOF: {\n                  throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                }\n                default: {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                }\n              }\n            } else if (expectedArgType.equals(ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER)) {\n              final String argName = stok.sval;\n\n              if (argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  || argName.equalsIgnoreCase(\"offsetGap\")) {\n                stok.nextToken();\n                if (stok.ttype != ':') {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n                }\n                stok.nextToken();\n                int intArgValue = (int)stok.nval;\n                switch (stok.ttype) {\n                  case '\"':\n                  case '\\'':\n                  case StreamTokenizer.TT_WORD: {\n                    intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(stok.sval.trim());\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + stok.sval + \"'\", e);\n                    }\n                    // Intentional fall-through\n                  }\n                  case StreamTokenizer.TT_NUMBER: {\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                    break;\n                  }\n                  case StreamTokenizer.TT_EOF: {\n                    throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                  }\n                  default: {\n                    throw new RuntimeException\n                        (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                  }\n                }\n                break;\n              }\n              try {\n                final Class<? extends CharFilterFactory> clazz;\n                clazz = lookupAnalysisClass(argName, CharFilterFactory.class);\n                createAnalysisPipelineComponent(stok, clazz);\n              } catch (IllegalArgumentException e) {\n                try {\n                  final Class<? extends TokenizerFactory> clazz;\n                  clazz = lookupAnalysisClass(argName, TokenizerFactory.class);\n                  createAnalysisPipelineComponent(stok, clazz);\n                  expectedArgType = ArgType.TOKENFILTER;\n                } catch (IllegalArgumentException e2) {\n                  throw new RuntimeException(\"Line #\" + lineno(stok) + \": Can't find class '\"\n                                             + argName + \"' as CharFilterFactory or TokenizerFactory\");\n                }\n              }\n            } else { // expectedArgType = ArgType.TOKENFILTER\n              final String className = stok.sval;\n              final Class<? extends TokenFilterFactory> clazz;\n              try {\n                clazz = lookupAnalysisClass(className, TokenFilterFactory.class);\n              } catch (IllegalArgumentException e) {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Can't find class '\" + className + \"' as TokenFilterFactory\");\n              }\n              createAnalysisPipelineComponent(stok, clazz);\n            }\n            break;\n          }\n          default: {\n            throw new RuntimeException(\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n          }\n        }\n      }\n    } catch (RuntimeException e) {\n      if (e.getMessage().startsWith(\"Line #\")) {\n        throw e;\n      } else {\n        throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", e);\n      }\n    } catch (Throwable t) {\n      throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", t);\n    }\n\n    final AnalyzerFactory analyzerFactory = new AnalyzerFactory\n        (charFilterFactories, tokenizerFactory, tokenFilterFactories);\n    analyzerFactory.setPositionIncrementGap(positionIncrementGap);\n    analyzerFactory.setOffsetGap(offsetGap);\n    getRunData().getAnalyzerFactories().put(factoryName, analyzerFactory);\n  }\n\n","sourceOld":"  /**\n   * Sets the params.\n   * Analysis component factory names may optionally include the \"Factory\" suffix.\n   *\n   * @param params analysis pipeline specification: name, (optional) positionIncrementGap,\n   *               (optional) offsetGap, 0+ CharFilterFactory's, 1 TokenizerFactory,\n   *               and 0+ TokenFilterFactory's\n   */\n  @Override\n  public void setParams(String params) {\n    super.setParams(params);\n    ArgType expectedArgType = ArgType.ANALYZER_ARG;\n\n    final StreamTokenizer stok = new StreamTokenizer(new StringReader(params));\n    stok.commentChar('#');\n    stok.quoteChar('\"');\n    stok.quoteChar('\\'');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar(':');\n    stok.ordinaryChar(',');\n    try {\n      while (stok.nextToken() != StreamTokenizer.TT_EOF) {\n        switch (stok.ttype) {\n          case ',': {\n            // Do nothing\n            break;\n          }\n          case StreamTokenizer.TT_WORD: {\n            if (expectedArgType.equals(ArgType.ANALYZER_ARG)) {\n              final String argName = stok.sval;\n              if ( ! argName.equalsIgnoreCase(\"name\")\n                  && ! argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  && ! argName.equalsIgnoreCase(\"offsetGap\")) {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing 'name' param to AnalyzerFactory: '\" + params + \"'\");\n              }\n              stok.nextToken();\n              if (stok.ttype != ':') {\n                throw new RuntimeException\n                    (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n              }\n\n              stok.nextToken();\n              String argValue = stok.sval;\n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER: {\n                  argValue = Double.toString(stok.nval);\n                  // Drop the \".0\" from numbers, for integer arguments\n                  argValue = TRAILING_DOT_ZERO_PATTERN.matcher(argValue).replaceFirst(\"\");\n                  // Intentional fallthrough\n                }\n                case '\"':\n                case '\\'':\n                case StreamTokenizer.TT_WORD: {\n                  if (argName.equalsIgnoreCase(\"name\")) {\n                    factoryName = argValue;\n                    expectedArgType = ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER;\n                  } else {\n                    int intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(argValue);\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + argValue + \"'\", e);\n                    }\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                  }\n                  break;\n                }\n                case StreamTokenizer.TT_EOF: {\n                  throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                }\n                default: {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                }\n              }\n            } else if (expectedArgType.equals(ArgType.ANALYZER_ARG_OR_CHARFILTER_OR_TOKENIZER)) {\n              final String argName = stok.sval;\n\n              if (argName.equalsIgnoreCase(\"positionIncrementGap\")\n                  || argName.equalsIgnoreCase(\"offsetGap\")) {\n                stok.nextToken();\n                if (stok.ttype != ':') {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Missing ':' after '\" + argName + \"' param to AnalyzerFactory\");\n                }\n                stok.nextToken();\n                int intArgValue = (int)stok.nval;\n                switch (stok.ttype) {\n                  case '\"':\n                  case '\\'':\n                  case StreamTokenizer.TT_WORD: {\n                    intArgValue = 0;\n                    try {\n                      intArgValue = Integer.parseInt(stok.sval.trim());\n                    } catch (NumberFormatException e) {\n                      throw new RuntimeException\n                          (\"Line #\" + lineno(stok) + \": Exception parsing \" + argName + \" value '\" + stok.sval + \"'\", e);\n                    }\n                    // Intentional fall-through\n                  }\n                  case StreamTokenizer.TT_NUMBER: {\n                    if (argName.equalsIgnoreCase(\"positionIncrementGap\")) {\n                      positionIncrementGap = intArgValue;\n                    } else if (argName.equalsIgnoreCase(\"offsetGap\")) {\n                      offsetGap = intArgValue;\n                    }\n                    break;\n                  }\n                  case StreamTokenizer.TT_EOF: {\n                    throw new RuntimeException(\"Unexpected EOF: \" + stok.toString());\n                  }\n                  default: {\n                    throw new RuntimeException\n                        (\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n                  }\n                }\n                break;\n              }\n              try {\n                final Class<? extends CharFilterFactory> clazz;\n                clazz = lookupAnalysisClass(argName, CharFilterFactory.class);\n                createAnalysisPipelineComponent(stok, clazz);\n              } catch (IllegalArgumentException e) {\n                try {\n                  final Class<? extends TokenizerFactory> clazz;\n                  clazz = lookupAnalysisClass(argName, TokenizerFactory.class);\n                  createAnalysisPipelineComponent(stok, clazz);\n                  expectedArgType = ArgType.TOKENFILTER;\n                } catch (IllegalArgumentException e2) {\n                  throw new RuntimeException(\"Line #\" + lineno(stok) + \": Can't find class '\"\n                                             + argName + \"' as CharFilterFactory or TokenizerFactory\");\n                }\n              }\n            } else { // expectedArgType = ArgType.TOKENFILTER\n              final String className = stok.sval;\n              final Class<? extends TokenFilterFactory> clazz;\n              try {\n                clazz = lookupAnalysisClass(className, TokenFilterFactory.class);\n              } catch (IllegalArgumentException e) {\n                  throw new RuntimeException\n                      (\"Line #\" + lineno(stok) + \": Can't find class '\" + className + \"' as TokenFilterFactory\");\n              }\n              createAnalysisPipelineComponent(stok, clazz);\n            }\n            break;\n          }\n          default: {\n            throw new RuntimeException(\"Line #\" + lineno(stok) + \": Unexpected token: \" + stok.toString());\n          }\n        }\n      }\n    } catch (RuntimeException e) {\n      if (e.getMessage().startsWith(\"Line #\")) {\n        throw e;\n      } else {\n        throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", e);\n      }\n    } catch (Throwable t) {\n      throw new RuntimeException(\"Line #\" + lineno(stok) + \": \", t);\n    }\n\n    final AnalyzerFactory analyzerFactory = new AnalyzerFactory\n        (charFilterFactories, tokenizerFactory, tokenFilterFactories);\n    analyzerFactory.setPositionIncrementGap(positionIncrementGap);\n    analyzerFactory.setOffsetGap(offsetGap);\n    getRunData().getAnalyzerFactories().put(factoryName, analyzerFactory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7bb889a868ab9d608bde8136f42ed7234a3a927b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3dc707eb4c159b3029aac235f5f36bb3c7b58ee4":["7bb889a868ab9d608bde8136f42ed7234a3a927b"],"de522d9303bd67c8473a269a1319125d1f3700e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7bb889a868ab9d608bde8136f42ed7234a3a927b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3dc707eb4c159b3029aac235f5f36bb3c7b58ee4"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7bb889a868ab9d608bde8136f42ed7234a3a927b","de522d9303bd67c8473a269a1319125d1f3700e0"],"7bb889a868ab9d608bde8136f42ed7234a3a927b":["3dc707eb4c159b3029aac235f5f36bb3c7b58ee4","de522d9303bd67c8473a269a1319125d1f3700e0"],"3dc707eb4c159b3029aac235f5f36bb3c7b58ee4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["de522d9303bd67c8473a269a1319125d1f3700e0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}