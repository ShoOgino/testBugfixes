{"path":"lucene/core/src/java/org/apache/lucene/document/ShapeField#encodeTriangle(byte[],int,int,boolean,int,int,boolean,int,int,boolean).mjava","commits":[{"id":"09c1e6d465800c73af60624bf9d4459a19f7940c","date":1579293280,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/ShapeField#encodeTriangle(byte[],int,int,boolean,int,int,boolean,int,int,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeField#encodeTriangle(byte[],int,int,boolean,int,int,boolean,int,int,boolean).mjava","sourceNew":"  /**\n   * A triangle is encoded using 6 points and an extra point with encoded information in three bits of how to reconstruct it.\n   * Triangles are encoded with CCW orientation and might be rotated to limit the number of possible reconstructions to 2^3.\n   * Reconstruction always happens from west to east.\n   */\n  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, boolean abFromShape, int bLat, int bLon, boolean bcFromShape, int cLat, int cLon, boolean caFromShape) {\n    assert bytes.length == 7 * BYTES;\n    int aX;\n    int bX;\n    int cX;\n    int aY;\n    int bY;\n    int cY;\n    boolean ab, bc, ca;\n    //change orientation if CW\n    if (GeoUtils.orient(aLon, aLat, bLon, bLat, cLon, cLat) == -1) {\n      aX = cLon;\n      bX = bLon;\n      cX = aLon;\n      aY = cLat;\n      bY = bLat;\n      cY = aLat;\n      ab = bcFromShape;\n      bc = abFromShape;\n      ca = caFromShape;\n    } else {\n      aX = aLon;\n      bX = bLon;\n      cX = cLon;\n      aY = aLat;\n      bY = bLat;\n      cY = cLat;\n      ab = abFromShape;\n      bc = bcFromShape;\n      ca = caFromShape;\n    }\n    //rotate edges and place minX at the beginning\n    if (bX < aX || cX < aX) {\n      if (bX < cX) {\n        int tempX = aX;\n        int tempY = aY;\n        boolean tempBool = ab;\n        aX = bX;\n        aY = bY;\n        ab = bc;\n        bX = cX;\n        bY = cY;\n        bc = ca;\n        cX = tempX;\n        cY = tempY;\n        ca = tempBool;\n      } else if (cX < aX) {\n        int tempX = aX;\n        int tempY = aY;\n        boolean tempBool = ab;\n        aX = cX;\n        aY = cY;\n        ab = ca;\n        cX = bX;\n        cY = bY;\n        ca = bc;\n        bX = tempX;\n        bY = tempY;\n        bc = tempBool;\n      }\n    } else if (aX == bX && aX == cX) {\n      //degenerated case, all points with same longitude\n      //we need to prevent that aX is in the middle (not part of the MBS)\n      if (bY < aY || cY < aY) {\n        if (bY < cY) {\n          int tempX = aX;\n          int tempY = aY;\n          boolean tempBool = ab;\n          aX = bX;\n          aY = bY;\n          ab = bc;\n          bX = cX;\n          bY = cY;\n          bc = ca;\n          cX = tempX;\n          cY = tempY;\n          ca = tempBool;\n        } else if (cY < aY) {\n          int tempX = aX;\n          int tempY = aY;\n          boolean tempBool = ab;\n          aX = cX;\n          aY = cY;\n          ab = ca;\n          cX = bX;\n          cY = bY;\n          ca = bc;\n          bX = tempX;\n          bY = tempY;\n          bc = tempBool;\n        }\n      }\n    }\n\n    int minX = aX;\n    int minY = StrictMath.min(aY, StrictMath.min(bY, cY));\n    int maxX = StrictMath.max(aX, StrictMath.max(bX, cX));\n    int maxY = StrictMath.max(aY, StrictMath.max(bY, cY));\n\n    int bits, x, y;\n    if (minY == aY) {\n      if (maxY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MINY_MINX_MAXY_MAXX_Y_X;\n      } else if (maxY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MINY_MINX_Y_X_MAXY_MAXX;\n      } else {\n        y = bY;\n        x = cX;\n        bits = MINY_MINX_Y_MAXX_MAXY_X;\n      }\n    } else if (maxY == aY) {\n      if (minY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MAXY_MINX_MINY_MAXX_Y_X;\n      } else if (minY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MAXY_MINX_Y_X_MINY_MAXX;\n      } else {\n        y = cY;\n        x = bX;\n        bits = MAXY_MINX_MINY_X_Y_MAXX;\n      }\n    }  else if (maxX == bX && minY == bY) {\n      y = aY;\n      x = cX;\n      bits = Y_MINX_MINY_MAXX_MAXY_X;\n    } else if (maxX == cX && maxY == cY) {\n      y = aY;\n      x = bX;\n      bits = Y_MINX_MINY_X_MAXY_MAXX;\n    } else {\n      throw new IllegalArgumentException(\"Could not encode the provided triangle\");\n    }\n    bits |= (ab) ? (1 << 3) : 0;\n    bits |= (bc) ? (1 << 4) : 0;\n    bits |= (ca) ? (1 << 5) : 0;\n    NumericUtils.intToSortableBytes(minY, bytes, 0);\n    NumericUtils.intToSortableBytes(minX, bytes, BYTES);\n    NumericUtils.intToSortableBytes(maxY, bytes, 2 * BYTES);\n    NumericUtils.intToSortableBytes(maxX, bytes, 3 * BYTES);\n    NumericUtils.intToSortableBytes(y, bytes, 4 * BYTES);\n    NumericUtils.intToSortableBytes(x, bytes, 5 * BYTES);\n    NumericUtils.intToSortableBytes(bits, bytes, 6 * BYTES);\n  }\n\n","sourceOld":"  /**\n   * A triangle is encoded using 6 points and an extra point with encoded information in three bits of how to reconstruct it.\n   * Triangles are encoded with CCW orientation and might be rotated to limit the number of possible reconstructions to 2^3.\n   * Reconstruction always happens from west to east.\n   */\n  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, boolean abFromShape, int bLat, int bLon, boolean bcFromShape, int cLat, int cLon, boolean caFromShape) {\n    assert bytes.length == 7 * BYTES;\n    int aX;\n    int bX;\n    int cX;\n    int aY;\n    int bY;\n    int cY;\n    boolean ab, bc, ca;\n    //change orientation if CW\n    if (GeoUtils.orient(aLon, aLat, bLon, bLat, cLon, cLat) == -1) {\n      aX = cLon;\n      bX = bLon;\n      cX = aLon;\n      aY = cLat;\n      bY = bLat;\n      cY = aLat;\n      ab = bcFromShape;\n      bc = abFromShape;\n      ca = caFromShape;\n    } else {\n      aX = aLon;\n      bX = bLon;\n      cX = cLon;\n      aY = aLat;\n      bY = bLat;\n      cY = cLat;\n      ab = abFromShape;\n      bc = bcFromShape;\n      ca = caFromShape;\n    }\n    //rotate edges and place minX at the beginning\n    if (bX < aX || cX < aX) {\n      if (bX < cX) {\n        int tempX = aX;\n        int tempY = aY;\n        boolean tempBool = ab;\n        aX = bX;\n        aY = bY;\n        ab = bc;\n        bX = cX;\n        bY = cY;\n        bc = ca;\n        cX = tempX;\n        cY = tempY;\n        ca = tempBool;\n      } else if (cX < aX) {\n        int tempX = aX;\n        int tempY = aY;\n        boolean tempBool = ab;\n        aX = cX;\n        aY = cY;\n        ab = ca;\n        cX = bX;\n        cY = bY;\n        ca = bc;\n        bX = tempX;\n        bY = tempY;\n        bc = tempBool;\n      }\n    } else if (aX == bX && aX == cX) {\n      //degenerated case, all points with same longitude\n      //we need to prevent that aX is in the middle (not part of the MBS)\n      if (bY < aY || cY < aY) {\n        if (bY < cY) {\n          int tempX = aX;\n          int tempY = aY;\n          boolean tempBool = ab;\n          aX = bX;\n          aY = bY;\n          ab = bc;\n          bX = cX;\n          bY = cY;\n          bc = ca;\n          cX = tempX;\n          cY = tempY;\n          ca = tempBool;\n        } else if (cY < aY) {\n          int tempX = aX;\n          int tempY = aY;\n          boolean tempBool = ab;\n          aX = cX;\n          aY = cY;\n          ab = ca;\n          cX = bX;\n          cY = bY;\n          ca = bc;\n          bX = tempX;\n          bY = tempY;\n          bc = tempBool;\n        }\n      }\n    }\n\n    int minX = aX;\n    int minY = StrictMath.min(aY, StrictMath.min(bY, cY));\n    int maxX = StrictMath.max(aX, StrictMath.max(bX, cX));\n    int maxY = StrictMath.max(aY, StrictMath.max(bY, cY));\n\n    int bits, x, y;\n    if (minY == aY) {\n      if (maxY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MINY_MINX_MAXY_MAXX_Y_X;\n      } else if (maxY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MINY_MINX_Y_X_MAXY_MAXX;\n      } else {\n        y = bY;\n        x = cX;\n        bits = MINY_MINX_Y_MAXX_MAXY_X;\n      }\n    } else if (maxY == aY) {\n      if (minY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MAXY_MINX_MINY_MAXX_Y_X;\n      } else if (minY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MAXY_MINX_Y_X_MINY_MAXX;\n      } else {\n        y = cY;\n        x = bX;\n        bits = MAXY_MINX_MINY_X_Y_MAXX;\n      }\n    }  else if (maxX == bX && minY == bY) {\n      y = aY;\n      x = cX;\n      bits = Y_MINX_MINY_MAXX_MAXY_X;\n    } else if (maxX == cX && maxY == cY) {\n      y = aY;\n      x = bX;\n      bits = Y_MINX_MINY_X_MAXY_MAXX;\n    } else {\n      throw new IllegalArgumentException(\"Could not encode the provided triangle\");\n    }\n    bits |= (ab) ? (1 << 3) : 0;\n    bits |= (bc) ? (1 << 4) : 0;\n    bits |= (ca) ? (1 << 5) : 0;\n    NumericUtils.intToSortableBytes(minY, bytes, 0);\n    NumericUtils.intToSortableBytes(minX, bytes, BYTES);\n    NumericUtils.intToSortableBytes(maxY, bytes, 2 * BYTES);\n    NumericUtils.intToSortableBytes(maxX, bytes, 3 * BYTES);\n    NumericUtils.intToSortableBytes(y, bytes, 4 * BYTES);\n    NumericUtils.intToSortableBytes(x, bytes, 5 * BYTES);\n    NumericUtils.intToSortableBytes(bits, bytes, 6 * BYTES);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09c1e6d465800c73af60624bf9d4459a19f7940c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09c1e6d465800c73af60624bf9d4459a19f7940c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09c1e6d465800c73af60624bf9d4459a19f7940c"],"09c1e6d465800c73af60624bf9d4459a19f7940c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}