{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","commits":[{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2afd23a6f1242190c3409d8d81d5c5912d607fc9","date":1310477482,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2afd23a6f1242190c3409d8d81d5c5912d607fc9":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"7b91922b55d15444d554721b352861d028eb8278":["2afd23a6f1242190c3409d8d81d5c5912d607fc9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"2afd23a6f1242190c3409d8d81d5c5912d607fc9":["7b91922b55d15444d554721b352861d028eb8278"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","5d004d0e0b3f65bb40da76d476d659d7888270e8","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["2afd23a6f1242190c3409d8d81d5c5912d607fc9","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}