{"path":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","commits":[{"id":"fe3edda347939cc6859dbf4287e84f3e8e4bb939","date":1372696449,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<SchemaField>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) {\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","sourceOld":null,"bugFix":null,"bugIntro":["c5e2610b40339a9229fd44387a4a33aa04f86a69","cb4852bb249b16ea6b193580b83f713c8a39016c","a54972b2387f87fdd92600308f9a0d477b1f53b0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<SchemaField>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) {\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) {\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<SchemaField>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) {\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec756ece2bfff759a9615a1d8f833e4f5f26e96b","date":1402433820,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the latest schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n          // We should never get here, since selector.shouldMutate(field) will exclude already existing fields\n        } catch(ManagedIndexSchema.SchemaChangedInZkException e) {\n          log.debug(\"Schema changed while processing request - retrying.\");\n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) {\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cb4852bb249b16ea6b193580b83f713c8a39016c","date":1402435389,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the latest schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          if (null != newSchema) {\n            cmd.getReq().getCore().setLatestSchema(newSchema);\n            cmd.getReq().updateSchemaToLatest();\n            log.debug(\"Successfully added field(s) to the schema.\");\n            break; // success - exit from the retry loop\n          } else {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n          }\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n          // We should never get here, since selector.shouldMutate(field) will exclude already existing fields\n        } catch(ManagedIndexSchema.SchemaChangedInZkException e) {\n          log.debug(\"Schema changed while processing request - retrying.\");\n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the latest schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          cmd.getReq().getCore().setLatestSchema(newSchema);\n          cmd.getReq().updateSchemaToLatest();\n          log.debug(\"Successfully added field(s) to the schema.\");\n          break; // success - exit from the retry loop\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n          // We should never get here, since selector.shouldMutate(field) will exclude already existing fields\n        } catch(ManagedIndexSchema.SchemaChangedInZkException e) {\n          log.debug(\"Schema changed while processing request - retrying.\");\n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","bugFix":["fe3edda347939cc6859dbf4287e84f3e8e4bb939"],"bugIntro":["a54972b2387f87fdd92600308f9a0d477b1f53b0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a54972b2387f87fdd92600308f9a0d477b1f53b0","date":1404789654,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the latest schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          synchronized (oldSchema.getSchemaUpdateLock()) {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              cmd.getReq().getCore().setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          }\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n          // We should never get here, since selector.shouldMutate(field) will exclude already existing fields\n        } catch(ManagedIndexSchema.SchemaChangedInZkException e) {\n          log.debug(\"Schema changed while processing request - retrying.\");\n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the latest schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          IndexSchema newSchema = oldSchema.addFields(newFields);\n          if (null != newSchema) {\n            cmd.getReq().getCore().setLatestSchema(newSchema);\n            cmd.getReq().updateSchemaToLatest();\n            log.debug(\"Successfully added field(s) to the schema.\");\n            break; // success - exit from the retry loop\n          } else {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n          }\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n          // We should never get here, since selector.shouldMutate(field) will exclude already existing fields\n        } catch(ManagedIndexSchema.SchemaChangedInZkException e) {\n          log.debug(\"Schema changed while processing request - retrying.\");\n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","bugFix":["cb4852bb249b16ea6b193580b83f713c8a39016c","fe3edda347939cc6859dbf4287e84f3e8e4bb939"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f13b9d4c228e77327b284419c8cafd16913a7a19","date":1405437837,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the current schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getCore().getLatestSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      for (;;) {\n        final IndexSchema oldSchema = core.getLatestSchema();\n        List<SchemaField> newFields = new ArrayList<>();\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the latest schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        try {\n          synchronized (oldSchema.getSchemaUpdateLock()) {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              cmd.getReq().getCore().setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          }\n        } catch(ManagedIndexSchema.FieldExistsException e) {\n          log.debug(\"At least one field to be added already exists in the schema - retrying.\");\n          // No action: at least one field to be added already exists in the schema, so retry \n          // We should never get here, since selector.shouldMutate(field) will exclude already existing fields\n        } catch(ManagedIndexSchema.SchemaChangedInZkException e) {\n          log.debug(\"Schema changed while processing request - retrying.\");\n        }\n      }\n      super.processAdd(cmd);\n    }                          \n\n","bugFix":null,"bugIntro":["c5e2610b40339a9229fd44387a4a33aa04f86a69"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5e2610b40339a9229fd44387a4a33aa04f86a69","date":1434399249,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = mapValueClassesToFieldType(entry.getValue());\n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        for (final String fieldName : doc.getFieldNames()) {\n          if (selector.shouldMutate(fieldName)) { // returns false if the field already exists in the current schema\n            String fieldTypeName = mapValueClassesToFieldType(doc.getField(fieldName));\n            newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n          }\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":["fe3edda347939cc6859dbf4287e84f3e8e4bb939","f13b9d4c228e77327b284419c8cafd16913a7a19"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2fdcdc967538d037b1437d31f172b07265a4b9b","date":1444263273,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = mapValueClassesToFieldType(entry.getValue());\n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = mapValueClassesToFieldType(entry.getValue());\n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b377fd91b7578d0c02b259b5112d667e4d5f8e6","date":1499349411,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (String fieldName : newCopyFields.keySet()) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : newCopyFields.get(fieldName).values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (String srcField : newCopyFields.keySet()) {\n              for (Integer maxChars : newCopyFields.get(srcField).keySet()) {\n                newSchema = newSchema.addCopyFields(srcField, \n                  newCopyFields.get(srcField).get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()), \n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = mapValueClassesToFieldType(entry.getValue());\n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (String fieldName : newCopyFields.keySet()) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : newCopyFields.get(fieldName).values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (String srcField : newCopyFields.keySet()) {\n              for (Integer maxChars : newCopyFields.get(srcField).keySet()) {\n                newSchema = newSchema.addCopyFields(srcField, \n                  newCopyFields.get(srcField).get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()), \n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = mapValueClassesToFieldType(entry.getValue());\n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"Fields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields);\n            if (null != newSchema) {\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n            String fieldName = entry.getKey();\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : entry.getValue().values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n              String srcField = entry.getKey();\n              for (Integer maxChars : entry.getValue().keySet()) {\n                newSchema = newSchema.addCopyFields(srcField,\n                    entry.getValue().get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()),\n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (String fieldName : newCopyFields.keySet()) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : newCopyFields.get(fieldName).values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (String srcField : newCopyFields.keySet()) {\n              for (Integer maxChars : newCopyFields.get(srcField).keySet()) {\n                newSchema = newSchema.addCopyFields(srcField, \n                  newCopyFields.get(srcField).get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()), \n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n            String fieldName = entry.getKey();\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : entry.getValue().values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n              String srcField = entry.getKey();\n              for (Integer maxChars : entry.getValue().keySet()) {\n                newSchema = newSchema.addCopyFields(srcField,\n                    entry.getValue().get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()),\n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (String fieldName : newCopyFields.keySet()) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : newCopyFields.get(fieldName).values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (String srcField : newCopyFields.keySet()) {\n              for (Integer maxChars : newCopyFields.get(srcField).keySet()) {\n                newSchema = newSchema.addCopyFields(srcField, \n                  newCopyFields.get(srcField).get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()), \n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n            String fieldName = entry.getKey();\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : entry.getValue().values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(\"{}\", builder);\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n              String srcField = entry.getKey();\n              for (Integer maxChars : entry.getValue().keySet()) {\n                newSchema = newSchema.addCopyFields(srcField,\n                    entry.getValue().get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()),\n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","sourceOld":"    @Override\n    public void processAdd(AddUpdateCommand cmd) throws IOException {\n      if ( ! cmd.getReq().getSchema().isMutable()) {\n        final String message = \"This IndexSchema is not mutable.\";\n        throw new SolrException(BAD_REQUEST, message);\n      }\n      final SolrInputDocument doc = cmd.getSolrInputDocument();\n      final SolrCore core = cmd.getReq().getCore();\n      // use the cmd's schema rather than the latest, because the schema\n      // can be updated during processing.  Using the cmd's schema guarantees\n      // this will be detected and the cmd's schema updated.\n      IndexSchema oldSchema = cmd.getReq().getSchema();\n      for (;;) {\n        List<SchemaField> newFields = new ArrayList<>();\n        // Group copyField defs per field and then per maxChar, to adapt to IndexSchema API \n        Map<String,Map<Integer,List<CopyFieldDef>>> newCopyFields = new HashMap<>();\n        // build a selector each time through the loop b/c the schema we are\n        // processing may have changed\n        FieldNameSelector selector = buildSelector(oldSchema);\n        Map<String,List<SolrInputField>> unknownFields = new HashMap<>();\n        getUnknownFields(selector, doc, unknownFields);\n        for (final Map.Entry<String,List<SolrInputField>> entry : unknownFields.entrySet()) {\n          String fieldName = entry.getKey();\n          String fieldTypeName = defaultFieldType;\n          TypeMapping typeMapping = mapValueClassesToFieldType(entry.getValue());\n          if (typeMapping != null) {\n            fieldTypeName = typeMapping.fieldTypeName;\n            if (!typeMapping.copyFieldDefs.isEmpty()) {\n              newCopyFields.put(fieldName,\n                  typeMapping.copyFieldDefs.stream().collect(Collectors.groupingBy(CopyFieldDef::getMaxChars)));\n            }\n          } \n          newFields.add(oldSchema.newField(fieldName, fieldTypeName, Collections.<String,Object>emptyMap()));\n        }\n        if (newFields.isEmpty() && newCopyFields.isEmpty()) {\n          // nothing to do - no fields will be added - exit from the retry loop\n          log.debug(\"No fields or copyFields to add to the schema.\");\n          break;\n        } else if ( isImmutableConfigSet(core) ) {\n          final String message = \"This ConfigSet is immutable.\";\n          throw new SolrException(BAD_REQUEST, message);\n        }\n        if (log.isDebugEnabled()) {\n          StringBuilder builder = new StringBuilder();\n          builder.append(\"\\nFields to be added to the schema: [\");\n          boolean isFirst = true;\n          for (SchemaField field : newFields) {\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(field.getName());\n            builder.append(\"{type=\").append(field.getType().getTypeName()).append(\"}\");\n          }\n          builder.append(\"]\");\n          builder.append(\"\\nCopyFields to be added to the schema: [\");\n          isFirst = true;\n          for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n            String fieldName = entry.getKey();\n            builder.append(isFirst ? \"\" : \",\");\n            isFirst = false;\n            builder.append(\"source=\").append(fieldName).append(\"{\");\n            for (List<CopyFieldDef> copyFieldDefList : entry.getValue().values()) {\n              for (CopyFieldDef copyFieldDef : copyFieldDefList) {\n                builder.append(\"{dest=\").append(copyFieldDef.getDest(fieldName));\n                builder.append(\", maxChars=\").append(copyFieldDef.getMaxChars()).append(\"}\");\n              }\n            }\n            builder.append(\"}\");\n          }\n          builder.append(\"]\");\n          log.debug(builder.toString());\n        }\n        // Need to hold the lock during the entire attempt to ensure that\n        // the schema on the request is the latest\n        synchronized (oldSchema.getSchemaUpdateLock()) {\n          try {\n            IndexSchema newSchema = oldSchema.addFields(newFields, Collections.emptyMap(), false);\n            // Add copyFields\n            for (Map.Entry<String, Map<Integer, List<CopyFieldDef>>> entry : newCopyFields.entrySet()) {\n              String srcField = entry.getKey();\n              for (Integer maxChars : entry.getValue().keySet()) {\n                newSchema = newSchema.addCopyFields(srcField,\n                    entry.getValue().get(maxChars).stream().map(f -> f.getDest(srcField)).collect(Collectors.toList()),\n                  maxChars);\n              }\n            }\n            if (null != newSchema) {\n              ((ManagedIndexSchema)newSchema).persistManagedSchema(false);\n              core.setLatestSchema(newSchema);\n              cmd.getReq().updateSchemaToLatest();\n              log.debug(\"Successfully added field(s) and copyField(s) to the schema.\");\n              break; // success - exit from the retry loop\n            } else {\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed to add fields and/or copyFields.\");\n            }\n          } catch (ManagedIndexSchema.FieldExistsException e) {\n            log.error(\"At least one field to be added already exists in the schema - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n            log.debug(\"Schema changed while processing request - retrying.\");\n            oldSchema = core.getLatestSchema();\n            cmd.getReq().updateSchemaToLatest();\n          }\n        }\n      }\n      super.processAdd(cmd);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4b377fd91b7578d0c02b259b5112d667e4d5f8e6":["f2fdcdc967538d037b1437d31f172b07265a4b9b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["fe3edda347939cc6859dbf4287e84f3e8e4bb939"],"c5e2610b40339a9229fd44387a4a33aa04f86a69":["f13b9d4c228e77327b284419c8cafd16913a7a19"],"740d649f013f07efbeb73ca854f106c60166e7c0":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fe3edda347939cc6859dbf4287e84f3e8e4bb939"],"f2fdcdc967538d037b1437d31f172b07265a4b9b":["c5e2610b40339a9229fd44387a4a33aa04f86a69"],"cb4852bb249b16ea6b193580b83f713c8a39016c":["ec756ece2bfff759a9615a1d8f833e4f5f26e96b"],"f13b9d4c228e77327b284419c8cafd16913a7a19":["a54972b2387f87fdd92600308f9a0d477b1f53b0"],"a54972b2387f87fdd92600308f9a0d477b1f53b0":["cb4852bb249b16ea6b193580b83f713c8a39016c"],"ec756ece2bfff759a9615a1d8f833e4f5f26e96b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["4b377fd91b7578d0c02b259b5112d667e4d5f8e6"],"fe3edda347939cc6859dbf4287e84f3e8e4bb939":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e73d8d559120669b47658108d818b637df5456ea":["f2fdcdc967538d037b1437d31f172b07265a4b9b","4b377fd91b7578d0c02b259b5112d667e4d5f8e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"],"b0b597c65628ca9e73913a07e81691f8229bae35":["4b377fd91b7578d0c02b259b5112d667e4d5f8e6","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"4b377fd91b7578d0c02b259b5112d667e4d5f8e6":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","e73d8d559120669b47658108d818b637df5456ea","b0b597c65628ca9e73913a07e81691f8229bae35"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ec756ece2bfff759a9615a1d8f833e4f5f26e96b"],"c5e2610b40339a9229fd44387a4a33aa04f86a69":["f2fdcdc967538d037b1437d31f172b07265a4b9b"],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"f2fdcdc967538d037b1437d31f172b07265a4b9b":["4b377fd91b7578d0c02b259b5112d667e4d5f8e6","e73d8d559120669b47658108d818b637df5456ea"],"cb4852bb249b16ea6b193580b83f713c8a39016c":["a54972b2387f87fdd92600308f9a0d477b1f53b0"],"f13b9d4c228e77327b284419c8cafd16913a7a19":["c5e2610b40339a9229fd44387a4a33aa04f86a69"],"a54972b2387f87fdd92600308f9a0d477b1f53b0":["f13b9d4c228e77327b284419c8cafd16913a7a19"],"ec756ece2bfff759a9615a1d8f833e4f5f26e96b":["cb4852bb249b16ea6b193580b83f713c8a39016c"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["740d649f013f07efbeb73ca854f106c60166e7c0","b0b597c65628ca9e73913a07e81691f8229bae35"],"fe3edda347939cc6859dbf4287e84f3e8e4bb939":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","fe3edda347939cc6859dbf4287e84f3e8e4bb939"],"e73d8d559120669b47658108d818b637df5456ea":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","e73d8d559120669b47658108d818b637df5456ea","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}