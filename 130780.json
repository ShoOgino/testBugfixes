{"path":"solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsRecoverLeaseTest#testMultiThreaded().mjava","commits":[{"id":"e4bec8aad484912847547ca94038e1a3641c7bc7","date":1430228162,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsRecoverLeaseTest#testMultiThreaded().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMultiThreaded() throws Exception {\n    long startRecoverLeaseSuccessCount = FSHDFSUtils.RECOVER_LEASE_SUCCESS_COUNT.get();\n    \n    final URI uri = dfsCluster.getURI();\n    final Path path = new Path(uri);\n    final Configuration conf = new Configuration();\n    conf.setBoolean(\"fs.hdfs.impl.disable.cache\", true);\n    \n    // n threads create files\n    class WriterThread extends Thread {\n      private FileSystem fs;\n      private int id;\n      \n      public WriterThread(int id) {\n        this.id = id;\n        try {\n          fs = FileSystem.get(path.toUri(), conf);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public void run() {\n        Path testFile = new Path(uri.toString() + \"/file-\" + id);\n        FSDataOutputStream out;\n        try {\n          out = fs.create(testFile);\n          \n          if (random().nextBoolean()) {\n            int cnt = random().nextInt(100);\n            for (int i = 0; i < cnt; i++) {\n              out.write(random().nextInt(20000));\n            }\n            out.hflush();\n          }\n        } catch (IOException e) {\n          throw new RuntimeException();\n        }\n      }\n      \n      public void close() throws IOException {\n        fs.close();\n      }\n      \n      public int getFileId() {\n        return id;\n      }\n    }\n    \n    class RecoverThread extends Thread {\n      private FileSystem fs;\n      private int id;\n      \n      public RecoverThread(int id) {\n        this.id = id;\n        try {\n          fs = FileSystem.get(path.toUri(), conf);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public void run() {\n        Path testFile = new Path(uri.toString() + \"/file-\" + id);\n        try {\n          FSHDFSUtils.recoverFileLease(fs, testFile, conf, new CallerInfo() {\n            \n            @Override\n            public boolean isCallerClosed() {\n              return false;\n            }\n          });\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      public void close() throws IOException {\n        fs.close();\n      }\n    }\n    \n    Set<WriterThread> writerThreads = new HashSet<WriterThread>();\n    Set<RecoverThread> recoverThreads = new HashSet<RecoverThread>();\n    \n    int threadCount = 3;\n    for (int i = 0; i < threadCount; i++) {\n      WriterThread wt = new WriterThread(i);\n      writerThreads.add(wt);\n      wt.run();\n    }\n    \n    for (WriterThread wt : writerThreads) {\n      wt.join();\n    }\n    \n    Thread.sleep(2000);\n    \n    for (WriterThread wt : writerThreads) {\n      RecoverThread rt = new RecoverThread(wt.getFileId());\n      recoverThreads.add(rt);\n      rt.run();\n    }\n    \n    for (WriterThread wt : writerThreads) {\n      wt.close();\n    }\n    \n    for (RecoverThread rt : recoverThreads) {\n      rt.close();\n    }\n\n    assertEquals(threadCount, FSHDFSUtils.RECOVER_LEASE_SUCCESS_COUNT.get() - startRecoverLeaseSuccessCount);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"add53de9835b2cd1a7a80b4e0036afee171c9fdf","date":1552937136,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsRecoverLeaseTest#testMultiThreaded().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/hdfs/HdfsRecoverLeaseTest#testMultiThreaded().mjava","sourceNew":"  @Test\n  public void testMultiThreaded() throws Exception {\n    long startRecoverLeaseSuccessCount = FSHDFSUtils.RECOVER_LEASE_SUCCESS_COUNT.get();\n    \n    final URI uri = dfsCluster.getURI();\n    final Path path = new Path(uri);\n    final Configuration conf = HdfsTestUtil.getClientConfiguration(dfsCluster);\n    \n    // n threads create files\n    class WriterThread extends Thread {\n      private FileSystem fs;\n      private int id;\n      \n      public WriterThread(int id) {\n        this.id = id;\n        try {\n          fs = FileSystem.get(path.toUri(), conf);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public void run() {\n        Path testFile = new Path(uri.toString() + \"/file-\" + id);\n        FSDataOutputStream out;\n        try {\n          out = fs.create(testFile);\n          \n          if (random().nextBoolean()) {\n            int cnt = random().nextInt(100);\n            for (int i = 0; i < cnt; i++) {\n              out.write(random().nextInt(20000));\n            }\n            out.hflush();\n          }\n        } catch (IOException e) {\n          throw new RuntimeException();\n        }\n      }\n      \n      public void close() throws IOException {\n        fs.close();\n      }\n      \n      public int getFileId() {\n        return id;\n      }\n    }\n    \n    class RecoverThread extends Thread {\n      private FileSystem fs;\n      private int id;\n      \n      public RecoverThread(int id) {\n        this.id = id;\n        try {\n          fs = FileSystem.get(path.toUri(), conf);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public void run() {\n        Path testFile = new Path(uri.toString() + \"/file-\" + id);\n        try {\n          FSHDFSUtils.recoverFileLease(fs, testFile, conf, new CallerInfo() {\n            \n            @Override\n            public boolean isCallerClosed() {\n              return false;\n            }\n          });\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      public void close() throws IOException {\n        fs.close();\n      }\n    }\n    \n    Set<WriterThread> writerThreads = new HashSet<WriterThread>();\n    Set<RecoverThread> recoverThreads = new HashSet<RecoverThread>();\n    \n    int threadCount = 3;\n    for (int i = 0; i < threadCount; i++) {\n      WriterThread wt = new WriterThread(i);\n      writerThreads.add(wt);\n      wt.run();\n    }\n    \n    for (WriterThread wt : writerThreads) {\n      wt.join();\n    }\n    \n    Thread.sleep(2000);\n    \n    for (WriterThread wt : writerThreads) {\n      RecoverThread rt = new RecoverThread(wt.getFileId());\n      recoverThreads.add(rt);\n      rt.run();\n    }\n    \n    for (WriterThread wt : writerThreads) {\n      wt.close();\n    }\n    \n    for (RecoverThread rt : recoverThreads) {\n      rt.close();\n    }\n\n    assertEquals(threadCount, FSHDFSUtils.RECOVER_LEASE_SUCCESS_COUNT.get() - startRecoverLeaseSuccessCount);\n    \n  }\n\n","sourceOld":"  @Test\n  public void testMultiThreaded() throws Exception {\n    long startRecoverLeaseSuccessCount = FSHDFSUtils.RECOVER_LEASE_SUCCESS_COUNT.get();\n    \n    final URI uri = dfsCluster.getURI();\n    final Path path = new Path(uri);\n    final Configuration conf = new Configuration();\n    conf.setBoolean(\"fs.hdfs.impl.disable.cache\", true);\n    \n    // n threads create files\n    class WriterThread extends Thread {\n      private FileSystem fs;\n      private int id;\n      \n      public WriterThread(int id) {\n        this.id = id;\n        try {\n          fs = FileSystem.get(path.toUri(), conf);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public void run() {\n        Path testFile = new Path(uri.toString() + \"/file-\" + id);\n        FSDataOutputStream out;\n        try {\n          out = fs.create(testFile);\n          \n          if (random().nextBoolean()) {\n            int cnt = random().nextInt(100);\n            for (int i = 0; i < cnt; i++) {\n              out.write(random().nextInt(20000));\n            }\n            out.hflush();\n          }\n        } catch (IOException e) {\n          throw new RuntimeException();\n        }\n      }\n      \n      public void close() throws IOException {\n        fs.close();\n      }\n      \n      public int getFileId() {\n        return id;\n      }\n    }\n    \n    class RecoverThread extends Thread {\n      private FileSystem fs;\n      private int id;\n      \n      public RecoverThread(int id) {\n        this.id = id;\n        try {\n          fs = FileSystem.get(path.toUri(), conf);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public void run() {\n        Path testFile = new Path(uri.toString() + \"/file-\" + id);\n        try {\n          FSHDFSUtils.recoverFileLease(fs, testFile, conf, new CallerInfo() {\n            \n            @Override\n            public boolean isCallerClosed() {\n              return false;\n            }\n          });\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      public void close() throws IOException {\n        fs.close();\n      }\n    }\n    \n    Set<WriterThread> writerThreads = new HashSet<WriterThread>();\n    Set<RecoverThread> recoverThreads = new HashSet<RecoverThread>();\n    \n    int threadCount = 3;\n    for (int i = 0; i < threadCount; i++) {\n      WriterThread wt = new WriterThread(i);\n      writerThreads.add(wt);\n      wt.run();\n    }\n    \n    for (WriterThread wt : writerThreads) {\n      wt.join();\n    }\n    \n    Thread.sleep(2000);\n    \n    for (WriterThread wt : writerThreads) {\n      RecoverThread rt = new RecoverThread(wt.getFileId());\n      recoverThreads.add(rt);\n      rt.run();\n    }\n    \n    for (WriterThread wt : writerThreads) {\n      wt.close();\n    }\n    \n    for (RecoverThread rt : recoverThreads) {\n      rt.close();\n    }\n\n    assertEquals(threadCount, FSHDFSUtils.RECOVER_LEASE_SUCCESS_COUNT.get() - startRecoverLeaseSuccessCount);\n    \n  }\n\n","bugFix":["e4bec8aad484912847547ca94038e1a3641c7bc7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e4bec8aad484912847547ca94038e1a3641c7bc7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"add53de9835b2cd1a7a80b4e0036afee171c9fdf":["e4bec8aad484912847547ca94038e1a3641c7bc7"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e4bec8aad484912847547ca94038e1a3641c7bc7"],"e4bec8aad484912847547ca94038e1a3641c7bc7":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"add53de9835b2cd1a7a80b4e0036afee171c9fdf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}