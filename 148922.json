{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      // delete by query...\n      // TODO: handle versioned and distributed deleteByQuery\n\n      // even in non zk mode, tests simulate updates from a leader\n      if(!zkEnabled) {\n        isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n      } else {\n        zkCheck();\n      }\n      \n      processDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      // delete by query...\n      // TODO: handle versioned and distributed deleteByQuery\n\n      // even in non zk mode, tests simulate updates from a leader\n      if(!zkEnabled) {\n        isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n      } else {\n        zkCheck();\n      }\n      \n      processDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      // delete by query...\n      // TODO: handle versioned and distributed deleteByQuery\n\n      // even in non zk mode, tests simulate updates from a leader\n      if(!zkEnabled) {\n        isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n      } else {\n        zkCheck();\n      }\n      \n      processDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df5e4eb47076636341c2cfdc58472477477d7e96","date":1329187541,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      // delete by query...\n      // TODO: handle versioned and distributed deleteByQuery\n\n      // even in non zk mode, tests simulate updates from a leader\n      if(!zkEnabled) {\n        isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n      } else {\n        zkCheck();\n      }\n      \n      processDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d","date":1330786058,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      if (isLeader && !req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n        log.error(\"Abort sending request to replicas, we are no longer leader\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Abort sending request to replicas, we are no longer leader\");\n      }\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      if (isLeader && !req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n        log.error(\"Abort sending request to replicas, we are no longer leader\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Abort sending request to replicas, we are no longer leader\");\n      }\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2806236d9dfa336ac413d3724a4123e7cf4d1e93","date":1348631501,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // we already will have forwarded this from our local commit\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d7c0c8a97beb56d2e168604f9928de17981eabe","date":1357257676,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f1ea787bab5bdb5e72685e55424898da05509b6","date":1370289750,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.syncDelete(cmd, subShardLeaders, params);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96adbab674ae121f8b6b3e10474070b4bd97a219","date":1373614333,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.syncDelete(cmd, subShardLeaders, params);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.syncDelete(cmd, subShardLeaders, params);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.syncDelete(cmd, subShardLeaders, params);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.syncDelete(cmd, subShardLeaders, params);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.syncDelete(cmd, subShardLeaders, params);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0","date":1385584801,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      } else if (log.isDebugEnabled()) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a51acc2e27bfb18091f9395494aebe82266f7ce7","date":1385611742,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      } else if (log.isDebugEnabled()) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21d6ea084cd3d72cd738a74805c054e9c2bea79c","date":1400661702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), null, null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"747dd71fefcbc7142661c25334b74c518fef4d81","date":1423504825,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":["c5a558d54519c651068ddb202f03befefb1514a7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7350fba633b826986454e97668c5ad03b46bcaca","date":1446484423,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>();\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","date":1452195469,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14a570ea289e0d989057de081e0a4fb0255f4a53","date":1508372334,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribDelete(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<String>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615bf5b56d95ed8c9bf06a402db6c817d6bff21a","date":1509492118,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n      return;\n    }\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    \n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribDelete(cmd, nodes, params);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e","date":1551802585,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["7350fba633b826986454e97668c5ad03b46bcaca"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8f1ea787bab5bdb5e72685e55424898da05509b6","96adbab674ae121f8b6b3e10474070b4bd97a219"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["df5e4eb47076636341c2cfdc58472477477d7e96","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["c5a558d54519c651068ddb202f03befefb1514a7"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["21d6ea084cd3d72cd738a74805c054e9c2bea79c"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"b7605579001505896d48b07160075a5c8b8e128e":["a51acc2e27bfb18091f9395494aebe82266f7ce7","21d6ea084cd3d72cd738a74805c054e9c2bea79c"],"07749612bed4eb54dd05255c1434c301133310c1":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["14a570ea289e0d989057de081e0a4fb0255f4a53"],"21d6ea084cd3d72cd738a74805c054e9c2bea79c":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7350fba633b826986454e97668c5ad03b46bcaca":["747dd71fefcbc7142661c25334b74c518fef4d81"],"7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0":["3333dd7044501b4f20231ea55ab64e688285d153"],"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d":["df5e4eb47076636341c2cfdc58472477477d7e96"],"407687e67faf6e1f02a211ca078d8e3eed631027":["2806236d9dfa336ac413d3724a4123e7cf4d1e93","c5a558d54519c651068ddb202f03befefb1514a7"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"747dd71fefcbc7142661c25334b74c518fef4d81":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["e2fe35ac47f8f51356d6c1724455d18f31c94fae","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"2806236d9dfa336ac413d3724a4123e7cf4d1e93":["a6378064655e76cd7b908b1cab4ce425b384b508"],"da888af1ab894358122a22229051215f58cf4d54":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0"],"c5a558d54519c651068ddb202f03befefb1514a7":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["a51acc2e27bfb18091f9395494aebe82266f7ce7","21d6ea084cd3d72cd738a74805c054e9c2bea79c"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","a51acc2e27bfb18091f9395494aebe82266f7ce7"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"df5e4eb47076636341c2cfdc58472477477d7e96":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"14a570ea289e0d989057de081e0a4fb0255f4a53":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"3333dd7044501b4f20231ea55ab64e688285d153":["da888af1ab894358122a22229051215f58cf4d54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07749612bed4eb54dd05255c1434c301133310c1"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["14a570ea289e0d989057de081e0a4fb0255f4a53"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"8f1ea787bab5bdb5e72685e55424898da05509b6":["37a0f60745e53927c4c876cfe5b5a58170f0646c","96adbab674ae121f8b6b3e10474070b4bd97a219"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["da888af1ab894358122a22229051215f58cf4d54"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","8f1ea787bab5bdb5e72685e55424898da05509b6"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["747dd71fefcbc7142661c25334b74c518fef4d81"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["a6378064655e76cd7b908b1cab4ce425b384b508"],"b7605579001505896d48b07160075a5c8b8e128e":[],"07749612bed4eb54dd05255c1434c301133310c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","05a14b2611ead08655a2b2bdc61632eb31316e57"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"21d6ea084cd3d72cd738a74805c054e9c2bea79c":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["37a0f60745e53927c4c876cfe5b5a58170f0646c","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"7350fba633b826986454e97668c5ad03b46bcaca":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"747dd71fefcbc7142661c25334b74c518fef4d81":["7350fba633b826986454e97668c5ad03b46bcaca"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"2806236d9dfa336ac413d3724a4123e7cf4d1e93":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"da888af1ab894358122a22229051215f58cf4d54":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","3333dd7044501b4f20231ea55ab64e688285d153"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"a6378064655e76cd7b908b1cab4ce425b384b508":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["b7605579001505896d48b07160075a5c8b8e128e","21d6ea084cd3d72cd738a74805c054e9c2bea79c","a656b32c3aa151037a8c52e9b134acc3cbf482bc","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"c5a558d54519c651068ddb202f03befefb1514a7":["3d7c0c8a97beb56d2e168604f9928de17981eabe","407687e67faf6e1f02a211ca078d8e3eed631027"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","df5e4eb47076636341c2cfdc58472477477d7e96"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"df5e4eb47076636341c2cfdc58472477477d7e96":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["07749612bed4eb54dd05255c1434c301133310c1"],"14a570ea289e0d989057de081e0a4fb0255f4a53":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"3333dd7044501b4f20231ea55ab64e688285d153":["7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["6013b4c7388f1627659c8f96c44abd10a294d3a6","05a14b2611ead08655a2b2bdc61632eb31316e57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7605579001505896d48b07160075a5c8b8e128e","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","a656b32c3aa151037a8c52e9b134acc3cbf482bc","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}