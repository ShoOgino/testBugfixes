{"path":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<? extends IndexReader> subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.size());\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs.get(nodeID).maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<? extends IndexReader> subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.size());\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs.get(nodeID).maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":["226aae72c0326f4299c16280195bade4530de537","4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<? extends IndexReader> subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.size());\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs.get(nodeID).maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<? extends IndexReader> subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.size());\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs.get(nodeID).maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<? extends IndexReader> subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.size());\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs.get(nodeID).maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<? extends IndexReader> subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.size());\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs.get(nodeID).maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits);\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits);\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits);\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits);\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits.value);\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits.value);\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits.value) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits.value, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits);\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits);\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e708f948b384f9aa85c665caee4486eb2d9e197d","date":1533106881,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits.value);\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits.value);\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits.value) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits.value, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertConsistent(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = TestUtil.nextInt(random(), 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final List<IndexReaderContext> subs = mockSearcher.getTopReaderContext().children();\n    assertEquals(numNodes, subs.size());\n\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = subs.get(nodeID).docBaseInParent;\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits.value);\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits.value);\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits.value) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits.value, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e708f948b384f9aa85c665caee4486eb2d9e197d":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["6613659748fe4411a7dcf85266e55db1f95f7315","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["6613659748fe4411a7dcf85266e55db1f95f7315"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e708f948b384f9aa85c665caee4486eb2d9e197d"]},"commit2Childs":{"e708f948b384f9aa85c665caee4486eb2d9e197d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3c188105a9aae04f56c24996f98f8333fc825d2e","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","6613659748fe4411a7dcf85266e55db1f95f7315","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}