{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","commits":[{"id":"322c7e6294f703248e9b818ca5b393b090ac05ad","date":1442166853,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"/dev/null","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fc580d29a38b378bb4bade72b21d983b06496819","fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","b4a1e501646d5889b8128849329c2e6e52fc3615","c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c48871ed951104729f5e17a8ee1091b43fa18980","date":1446564542,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      rateLimiters.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["b4a1e501646d5889b8128849329c2e6e52fc3615"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4a1e501646d5889b8128849329c2e6e52fc3615","date":1498729990,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","322c7e6294f703248e9b818ca5b393b090ac05ad"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      bufferedUpdatesStream.clear();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","date":1512420564,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc-rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc-rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n      throw tragedy;\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc-rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c","date":1521393811,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc-rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n      throw tragedy;\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    boolean success = false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized(this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc-rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\") ) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock);                     // release write lock\n        writeLock = null;\n      }\n\n      success = true;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"rollbackInternal\");\n      throw tragedy;\n    } finally {\n      if (success == false) {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n      }\n      synchronized(this) {\n        if (success == false) {\n          // we tried to be nice about it: do the minimum\n          \n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n            }\n            pendingCommit = null;\n          }\n          \n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n        }\n        closed = true;\n        closing = false;\n\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.dropAll(false);\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b8498afacfc8322268ca0d659d274fcce08d557","date":1524577248,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes \n      docWriter.abort(this); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      purge(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bdc52ba55664e70ae5a247af51566dd96fc2a1c","date":1583869220,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92b74780b4efed2011d2d1a19183689db904519e","date":1586516102,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      stopMerges = true; // this disables merges forever\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":null,"bugIntro":["fc580d29a38b378bb4bade72b21d983b06496819"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc580d29a38b378bb4bade72b21d983b06496819","date":1586627601,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized (this) {\n        // must be synced otherwise register merge might throw and exception if stopMerges\n        // changes concurrently, abortMerges is synced as well\n        stopMerges = true; // this disables merges forever\n        abortMerges();\n      }\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      stopMerges = true; // this disables merges forever\n      abortMerges();\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":["322c7e6294f703248e9b818ca5b393b090ac05ad","92b74780b4efed2011d2d1a19183689db904519e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b8a0bc175e864e198120c8694f8dbd34f0f2b7b","date":1588914174,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized (this) {\n        // must be synced otherwise register merge might throw and exception if stopMerges\n        // changes concurrently, abortMerges is synced as well\n        stopMerges = true; // this disables merges forever\n        abortMerges();\n        assert mergingSegments.isEmpty() : \"we aborted all merges but still have merging segments: \" + mergingSegments;\n      }\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized (this) {\n        // must be synced otherwise register merge might throw and exception if stopMerges\n        // changes concurrently, abortMerges is synced as well\n        stopMerges = true; // this disables merges forever\n        abortMerges();\n      }\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a775b68a26e2d19d1b5f16cd18a3bc8df738a302","date":1598253342,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#rollbackInternalNoCommit().mjava","sourceNew":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized (this) {\n        // must be synced otherwise register merge might throw and exception if merges\n        // changes concurrently, abortMerges is synced as well\n        abortMerges(); // this disables merges forever since we are closing and can't reenable them\n        assert mergingSegments.isEmpty() : \"we aborted all merges but still have merging segments: \" + mergingSegments;\n      }\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","sourceOld":"  private void rollbackInternalNoCommit() throws IOException {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"rollback\");\n    }\n    \n    try {\n      synchronized (this) {\n        // must be synced otherwise register merge might throw and exception if stopMerges\n        // changes concurrently, abortMerges is synced as well\n        stopMerges = true; // this disables merges forever\n        abortMerges();\n        assert mergingSegments.isEmpty() : \"we aborted all merges but still have merging segments: \" + mergingSegments;\n      }\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"rollback: done finish merges\");\n      }\n\n      // Must pre-close in case it increments changeCount so that we can then\n      // set it to false before calling rollbackInternal\n      mergeScheduler.close();\n\n      docWriter.close(); // mark it as closed first to prevent subsequent indexing actions/flushes\n      assert !Thread.holdsLock(this) : \"IndexWriter lock should never be hold when aborting\";\n      docWriter.abort(); // don't sync on IW here\n      docWriter.flushControl.waitForFlush(); // wait for all concurrently running flushes\n      publishFlushedSegments(true); // empty the flush ticket queue otherwise we might not have cleaned up all resources\n      eventQueue.close();\n      synchronized (this) {\n\n        if (pendingCommit != null) {\n          pendingCommit.rollbackCommit(directory);\n          try {\n            deleter.decRef(pendingCommit);\n          } finally {\n            pendingCommit = null;\n            notifyAll();\n          }\n        }\n        final int totalMaxDoc = segmentInfos.totalMaxDoc();\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances so IFD below will remove\n        // any segments we flushed since the last commit:\n        segmentInfos.rollbackSegmentInfos(rollbackSegments);\n        int rollbackMaxDoc = segmentInfos.totalMaxDoc();\n        // now we need to adjust this back to the rolled back SI but don't set it to the absolute value\n        // otherwise we might hide internal bugsf\n        adjustPendingNumDocs(-(totalMaxDoc - rollbackMaxDoc));\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"rollback: infos=\" + segString(segmentInfos));\n        }\n\n        testPoint(\"rollback before checkpoint\");\n\n        // Ask deleter to locate unreferenced files & remove\n        // them ... only when we are not experiencing a tragedy, else\n        // these methods throw ACE:\n        if (tragedy.get() == null) {\n          deleter.checkpoint(segmentInfos, false);\n          deleter.refresh();\n          deleter.close();\n        }\n\n        lastCommitChangeCount = changeCount.get();\n        // Don't bother saving any changes in our segmentInfos\n        readerPool.close();\n        // Must set closed while inside same sync block where we call deleter.refresh, else concurrent threads may try to sneak a flush in,\n        // after we leave this sync block and before we enter the sync block in the finally clause below that sets closed:\n        closed = true;\n\n        IOUtils.close(writeLock); // release write lock\n        writeLock = null;\n        closed = true;\n        closing = false;\n        // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n        notifyAll();\n      }\n    } catch (Throwable throwable) {\n      try {\n        // Must not hold IW's lock while closing\n        // mergeScheduler: this can lead to deadlock,\n        // e.g. TestIW.testThreadInterruptDeadlock\n        IOUtils.closeWhileHandlingException(mergeScheduler);\n        synchronized (this) {\n          // we tried to be nice about it: do the minimum\n          // don't leak a segments_N file if there is a pending commit\n          if (pendingCommit != null) {\n            try {\n              pendingCommit.rollbackCommit(directory);\n              deleter.decRef(pendingCommit);\n            } catch (Throwable t) {\n              throwable.addSuppressed(t);\n            }\n            pendingCommit = null;\n          }\n\n          // close all the closeables we can (but important is readerPool and writeLock to prevent leaks)\n          IOUtils.closeWhileHandlingException(readerPool, deleter, writeLock);\n          writeLock = null;\n          closed = true;\n          closing = false;\n\n          // So any \"concurrently closing\" threads wake up and see that the close has now completed:\n          notifyAll();\n        }\n      } catch (Throwable t) {\n        throwable.addSuppressed(t);\n      } finally {\n        if (throwable instanceof VirtualMachineError) {\n          try {\n            tragicEvent(throwable, \"rollbackInternal\");\n          } catch (Throwable t1){\n            throwable.addSuppressed(t1);\n          }\n        }\n      }\n      throw throwable;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"322c7e6294f703248e9b818ca5b393b090ac05ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"a775b68a26e2d19d1b5f16cd18a3bc8df738a302":["7b8a0bc175e864e198120c8694f8dbd34f0f2b7b"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["c48871ed951104729f5e17a8ee1091b43fa18980"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["845b760a99e5f369fcd0a5d723a87b8def6a3f56","af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c"],"30c8e5574b55d57947e989443dfde611646530ee":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","b4a1e501646d5889b8128849329c2e6e52fc3615"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"b4a1e501646d5889b8128849329c2e6e52fc3615":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"c48871ed951104729f5e17a8ee1091b43fa18980":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"6b8498afacfc8322268ca0d659d274fcce08d557":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fc580d29a38b378bb4bade72b21d983b06496819":["92b74780b4efed2011d2d1a19183689db904519e"],"7b8a0bc175e864e198120c8694f8dbd34f0f2b7b":["fc580d29a38b378bb4bade72b21d983b06496819"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["b4a1e501646d5889b8128849329c2e6e52fc3615"],"3bdc52ba55664e70ae5a247af51566dd96fc2a1c":["6b8498afacfc8322268ca0d659d274fcce08d557"],"92b74780b4efed2011d2d1a19183689db904519e":["3bdc52ba55664e70ae5a247af51566dd96fc2a1c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a775b68a26e2d19d1b5f16cd18a3bc8df738a302"]},"commit2Childs":{"322c7e6294f703248e9b818ca5b393b090ac05ad":["c48871ed951104729f5e17a8ee1091b43fa18980"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["203e3fcf513c02ee2c07015f2ce277e26dc60907","af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a775b68a26e2d19d1b5f16cd18a3bc8df738a302":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"30c8e5574b55d57947e989443dfde611646530ee":[],"1926100d9b67becc9701c54266fee3ba7878a5f0":["6b8498afacfc8322268ca0d659d274fcce08d557"],"b4a1e501646d5889b8128849329c2e6e52fc3615":["30c8e5574b55d57947e989443dfde611646530ee","fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["30c8e5574b55d57947e989443dfde611646530ee"],"28288370235ed02234a64753cdbf0c6ec096304a":["b4a1e501646d5889b8128849329c2e6e52fc3615"],"c48871ed951104729f5e17a8ee1091b43fa18980":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"6b8498afacfc8322268ca0d659d274fcce08d557":["3bdc52ba55664e70ae5a247af51566dd96fc2a1c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["322c7e6294f703248e9b818ca5b393b090ac05ad"],"fc580d29a38b378bb4bade72b21d983b06496819":["7b8a0bc175e864e198120c8694f8dbd34f0f2b7b"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"7b8a0bc175e864e198120c8694f8dbd34f0f2b7b":["a775b68a26e2d19d1b5f16cd18a3bc8df738a302"],"3bdc52ba55664e70ae5a247af51566dd96fc2a1c":["92b74780b4efed2011d2d1a19183689db904519e"],"92b74780b4efed2011d2d1a19183689db904519e":["fc580d29a38b378bb4bade72b21d983b06496819"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}