{"path":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\t@Override\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\t@Override\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e00f80591de714c6975f454e33e0fa5218b5902","date":1294514405,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\t@Override\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"323f871ffe96b871d8c534a614be60751bb023c2","date":1294820532,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad68f0b439c4c71e87d2905799fdc28eb3174f3e","date":1294830907,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\t@Override\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9325c7ff9928fabe81c28553b41fc7aa57dfab","date":1295896411,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\t@Override\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ce8d53d5582eaa6a0c771c9b119d480f41da59c","date":1297466174,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(String fieldName, FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"160d004a0e8f5361a446f9d01456aee1c1af20dc","date":1301061642,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public float computeNorm(FieldInvertState state) {\n          return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public float computeNorm(FieldInvertState state) {\n          return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public float computeNorm(FieldInvertState state) {\n          return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarityProvider s = new DefaultSimilarity() {\n            @Override\n            public float computeNorm(FieldInvertState state) {\n              return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n            }\n          };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f3cee3d20b0c786e6fca20539454262e29edcab","date":1310101685,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public float computeNorm(FieldInvertState state) {\n          return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public float computeNorm(FieldInvertState state) {\n          return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1291e4568eb7d9463d751627596ef14baf4c1603","date":1310112572,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public float computeNorm(FieldInvertState state) {\n          return state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength());\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3a0403b45dfe384fae4a1b6e96c3265d000c498","date":1321445981,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n\tIndexReader reader = IndexReader.open(store, false);\n  searcher = new IndexSearcher(reader);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n  reader.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\treader = IndexReader.open(store, false);\n\tsearcher = new IndexSearcher(reader);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n    reader.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store, false);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store, false);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4122a26e1fd0457a340616673a3d3aada370f713","date":1322955654,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":null,"sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n\tIndexReader reader = IndexReader.open(store, false);\n  searcher = new IndexSearcher(reader);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n  reader.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\treader = IndexReader.open(store, false);\n\tsearcher = new IndexSearcher(reader);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n    reader.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":null,"sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n\tIndexReader reader = IndexReader.open(store, false);\n  searcher = new IndexSearcher(reader);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n  reader.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\treader = IndexReader.open(store, false);\n\tsearcher = new IndexSearcher(reader);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n    reader.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":null,"sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n\tIndexReader reader = IndexReader.open(store, false);\n  searcher = new IndexSearcher(reader);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    @Override\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    @Override\n    public void setNextReader(AtomicReaderContext context) {\n      docBase = context.docBase;\n    }\n    @Override\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    @Override\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n  reader.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n  SimilarityProvider s = new DefaultSimilarityProvider() {\n    @Override\n    public Similarity get(String field) {\n      return new DefaultSimilarity() {\n        @Override\n        public byte computeNorm(FieldInvertState state) {\n          return encodeNormValue(state.getBoost() * (discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength()));\n        }\n      };\n    }\n  };\n\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\treader = IndexReader.open(store, false);\n\tsearcher = new IndexSearcher(reader);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      @Override\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n    reader.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f3cee3d20b0c786e6fca20539454262e29edcab":["160d004a0e8f5361a446f9d01456aee1c1af20dc"],"323f871ffe96b871d8c534a614be60751bb023c2":["3e00f80591de714c6975f454e33e0fa5218b5902"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["a3a0403b45dfe384fae4a1b6e96c3265d000c498","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["868da859b43505d9d2a023bfeae6dd0c795f5295","fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"fd9325c7ff9928fabe81c28553b41fc7aa57dfab":["ad68f0b439c4c71e87d2905799fdc28eb3174f3e"],"1291e4568eb7d9463d751627596ef14baf4c1603":["160d004a0e8f5361a446f9d01456aee1c1af20dc","0f3cee3d20b0c786e6fca20539454262e29edcab"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","160d004a0e8f5361a446f9d01456aee1c1af20dc"],"160d004a0e8f5361a446f9d01456aee1c1af20dc":["5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"3e00f80591de714c6975f454e33e0fa5218b5902":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["160d004a0e8f5361a446f9d01456aee1c1af20dc","0f3cee3d20b0c786e6fca20539454262e29edcab"],"ad68f0b439c4c71e87d2905799fdc28eb3174f3e":["323f871ffe96b871d8c534a614be60751bb023c2"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["f1bdbf92da222965b46c0a942c3857ba56e5c638","160d004a0e8f5361a446f9d01456aee1c1af20dc"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["9454a6510e2db155fb01faa5c049b06ece95fab9","fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["0f3cee3d20b0c786e6fca20539454262e29edcab"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["a3a0403b45dfe384fae4a1b6e96c3265d000c498","4122a26e1fd0457a340616673a3d3aada370f713"],"5ce8d53d5582eaa6a0c771c9b119d480f41da59c":["fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"4122a26e1fd0457a340616673a3d3aada370f713":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["9454a6510e2db155fb01faa5c049b06ece95fab9","ad68f0b439c4c71e87d2905799fdc28eb3174f3e"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0f3cee3d20b0c786e6fca20539454262e29edcab":["1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"323f871ffe96b871d8c534a614be60751bb023c2":["ad68f0b439c4c71e87d2905799fdc28eb3174f3e"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"fd9325c7ff9928fabe81c28553b41fc7aa57dfab":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","29ef99d61cda9641b6250bf9567329a6e65f901d","5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"1291e4568eb7d9463d751627596ef14baf4c1603":[],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"160d004a0e8f5361a446f9d01456aee1c1af20dc":["0f3cee3d20b0c786e6fca20539454262e29edcab","1291e4568eb7d9463d751627596ef14baf4c1603","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","f0b9507caf22f292ac0e5e59f62db4275adf4511","d619839baa8ce5503e496b94a9e42ad6f079293f"],"3e00f80591de714c6975f454e33e0fa5218b5902":["323f871ffe96b871d8c534a614be60751bb023c2"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":[],"ad68f0b439c4c71e87d2905799fdc28eb3174f3e":["fd9325c7ff9928fabe81c28553b41fc7aa57dfab","868da859b43505d9d2a023bfeae6dd0c795f5295"],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3615ce4a1f785ae1b779244de52c6a7d99227e60","4122a26e1fd0457a340616673a3d3aada370f713"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ce8d53d5582eaa6a0c771c9b119d480f41da59c":["f1bdbf92da222965b46c0a942c3857ba56e5c638","160d004a0e8f5361a446f9d01456aee1c1af20dc","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"4122a26e1fd0457a340616673a3d3aada370f713":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["3e00f80591de714c6975f454e33e0fa5218b5902","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","1291e4568eb7d9463d751627596ef14baf4c1603","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","f0b9507caf22f292ac0e5e59f62db4275adf4511","d619839baa8ce5503e496b94a9e42ad6f079293f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}