{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","commits":[{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"/dev/null","sourceNew":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            PriorityQueue<ReadersAndUpdates> queue = readerPool.getReadersByRam();\n            int count = 0;\n            while (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n              ReadersAndUpdates rld = queue.poll();\n              if (rld == null) {\n                break;\n              }\n\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["055d638a4196dbe214e915652b491642cfb7652b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10dae974eb4de913f4a2075cd10fb6dfcba04a99","date":1528877401,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","sourceNew":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            PriorityQueue<ReadersAndUpdates> queue = readerPool.getReadersByRam();\n            int count = 0;\n            while (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n              ReadersAndUpdates rld = queue.poll();\n              if (rld == null) {\n                break;\n              }\n\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                if (readerPool.get(rld.info, false) == null) {\n                  assert segmentInfos.contains(rld.info) == false : \"Segment [\" + rld.info + \"] is not dropped yet\";\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","sourceOld":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            PriorityQueue<ReadersAndUpdates> queue = readerPool.getReadersByRam();\n            int count = 0;\n            while (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n              ReadersAndUpdates rld = queue.poll();\n              if (rld == null) {\n                break;\n              }\n\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["055d638a4196dbe214e915652b491642cfb7652b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"055d638a4196dbe214e915652b491642cfb7652b","date":1529056889,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","sourceNew":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","sourceOld":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            PriorityQueue<ReadersAndUpdates> queue = readerPool.getReadersByRam();\n            int count = 0;\n            while (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n              ReadersAndUpdates rld = queue.poll();\n              if (rld == null) {\n                break;\n              }\n\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                if (readerPool.get(rld.info, false) == null) {\n                  assert segmentInfos.contains(rld.info) == false : \"Segment [\" + rld.info + \"] is not dropped yet\";\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","bugFix":["1926100d9b67becc9701c54266fee3ba7878a5f0","10dae974eb4de913f4a2075cd10fb6dfcba04a99"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","sourceNew":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","sourceOld":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            PriorityQueue<ReadersAndUpdates> queue = readerPool.getReadersByRam();\n            int count = 0;\n            while (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n              ReadersAndUpdates rld = queue.poll();\n              if (rld == null) {\n                break;\n              }\n\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","sourceNew":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","sourceOld":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            PriorityQueue<ReadersAndUpdates> queue = readerPool.getReadersByRam();\n            int count = 0;\n            while (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n              ReadersAndUpdates rld = queue.poll();\n              if (rld == null) {\n                break;\n              }\n\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f21f1920c232db2352489eed260fe5c1f39e5a0","date":1587748041,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","sourceNew":"  final void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = readerPool.ramBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, readerPool.ramBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","sourceOld":"  void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = getReaderPoolRamBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, getReaderPoolRamBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#writeSomeDocValuesUpdates().mjava","sourceNew":"  final void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.tryLock()) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = readerPool.ramBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, readerPool.ramBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  final void writeSomeDocValuesUpdates() throws IOException {\n    if (writeDocValuesLock.compareAndSet(false, true)) {\n      try {\n        final double ramBufferSizeMB = config.getRAMBufferSizeMB();\n        // If the reader pool is > 50% of our IW buffer, then write the updates:\n        if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n          long startNS = System.nanoTime();\n\n          long ramBytesUsed = readerPool.ramBytesUsed();\n          if (ramBytesUsed > 0.5 * ramBufferSizeMB * 1024 * 1024) {\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"now write some pending DV updates: %.2f MB used vs IWC Buffer %.2f MB\",\n                  ramBytesUsed/1024./1024., ramBufferSizeMB));\n            }\n\n            // Sort by largest ramBytesUsed:\n            final List<ReadersAndUpdates> list = readerPool.getReadersByRam();\n            int count = 0;\n            for (ReadersAndUpdates rld : list) {\n\n              if (ramBytesUsed <= 0.5 * ramBufferSizeMB * 1024 * 1024) {\n                break;\n              }\n              // We need to do before/after because not all RAM in this RAU is used by DV updates, and\n              // not all of those bytes can be written here:\n              long bytesUsedBefore = rld.ramBytesUsed.get();\n              if (bytesUsedBefore == 0) {\n                continue; // nothing to do here - lets not acquire the lock\n              }\n              // Only acquire IW lock on each write, since this is a time consuming operation.  This way\n              // other threads get a chance to run in between our writes.\n              synchronized (this) {\n                // It's possible that the segment of a reader returned by readerPool#getReadersByRam\n                // is dropped before being processed here. If it happens, we need to skip that reader.\n                // this is also best effort to free ram, there might be some other thread writing this rld concurrently\n                // which wins and then if readerPooling is off this rld will be dropped.\n                if (readerPool.get(rld.info, false) == null) {\n                  continue;\n                }\n                if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {\n                  checkpointNoSIS();\n                }\n              }\n              long bytesUsedAfter = rld.ramBytesUsed.get();\n              ramBytesUsed -= bytesUsedBefore - bytesUsedAfter;\n              count++;\n            }\n\n            if (infoStream.isEnabled(\"BD\")) {\n              infoStream.message(\"BD\", String.format(Locale.ROOT, \"done write some DV updates for %d segments: now %.2f MB used vs IWC Buffer %.2f MB; took %.2f sec\",\n                  count, readerPool.ramBytesUsed()/1024./1024., ramBufferSizeMB, ((System.nanoTime() - startNS)/1000000000.)));\n            }\n          }\n        }\n      } finally {\n        writeDocValuesLock.set(false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1926100d9b67becc9701c54266fee3ba7878a5f0","055d638a4196dbe214e915652b491642cfb7652b"],"055d638a4196dbe214e915652b491642cfb7652b":["10dae974eb4de913f4a2075cd10fb6dfcba04a99"],"9f21f1920c232db2352489eed260fe5c1f39e5a0":["055d638a4196dbe214e915652b491642cfb7652b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["9f21f1920c232db2352489eed260fe5c1f39e5a0"],"10dae974eb4de913f4a2075cd10fb6dfcba04a99":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["1926100d9b67becc9701c54266fee3ba7878a5f0","055d638a4196dbe214e915652b491642cfb7652b"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"055d638a4196dbe214e915652b491642cfb7652b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","9f21f1920c232db2352489eed260fe5c1f39e5a0","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"9f21f1920c232db2352489eed260fe5c1f39e5a0":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"10dae974eb4de913f4a2075cd10fb6dfcba04a99":["055d638a4196dbe214e915652b491642cfb7652b"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","10dae974eb4de913f4a2075cd10fb6dfcba04a99","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}