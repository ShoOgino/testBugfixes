{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","commits":[{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"/dev/null","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create 2 new collections rapid fire\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n    params.set(\"numReplicas\", 1);\n    params.set(\"numShards\", 3);\n    String collectionName = \"awholynewcollection\";\n    params.set(\"name\", collectionName);\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    String collectionName2 = \"awholynewcollection2\";\n    params.set(\"name\", collectionName2);\n    params.set(\"numShards\", 2);\n    clients.get(1).request(request);\n    \n    checkForCollection(collectionName, 3);\n    checkForCollection(collectionName2, 2);\n\n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    int which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    SolrServer client = clients.get(which);\n    client.add(doc);\n    \n    doc = getDoc(id, 7, i1, 123, tlong, 123, t1,\n        \"humpty dumpy had a great fall\");\n    which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    client = clients.get(which);\n    client.add(doc);\n    doc = getDoc(id, 8, i1, 876, tlong, 876, t1,\n        \"all the kings horses and all the kings men\");\n    which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    client = clients.get(which);\n    client.add(doc);\n    \n    commit();\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName2);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName2);\n    \n    printLayout();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252","1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8512200aed2724abd80dbeb686d3412d537b7d8a","date":1342139754,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create 2 new collections rapid fire\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n    params.set(\"numReplicas\", 1);\n    params.set(\"numShards\", 3);\n    String collectionName = \"awholynewcollection\";\n    params.set(\"name\", collectionName);\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    String collectionName2 = \"awholynewcollection2\";\n    params.set(\"name\", collectionName2);\n    params.set(\"numShards\", 2);\n    clients.get(1).request(request);\n    \n    checkForCollection(collectionName, 3);\n    checkForCollection(collectionName2, 2);\n\n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    int which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    SolrServer client = clients.get(which);\n    client.add(doc);\n    \n    doc = getDoc(id, 7, i1, 123, tlong, 123, t1,\n        \"humpty dumpy had a great fall\");\n    which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    client = clients.get(which);\n    client.add(doc);\n    doc = getDoc(id, 8, i1, 876, tlong, 876, t1,\n        \"all the kings horses and all the kings men\");\n    which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    client = clients.get(which);\n    client.add(doc);\n    \n    commit();\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName2);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName2);\n    \n    printLayout();\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252","1525b4dfbc0d413b8d7247da232009778e624836","aa16b24e8441c80ef7c503119e979670698c7233"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63fce89dfe8a5dcba79c726470441c175441f122","date":1342202709,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(9);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01d7038753e558c19fba37629cb45f9740316fe7","date":1342203005,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(9);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"/dev/null","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create 2 new collections rapid fire\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n    params.set(\"numReplicas\", 1);\n    params.set(\"numShards\", 3);\n    String collectionName = \"awholynewcollection\";\n    params.set(\"name\", collectionName);\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    String collectionName2 = \"awholynewcollection2\";\n    params.set(\"name\", collectionName2);\n    params.set(\"numShards\", 2);\n    clients.get(1).request(request);\n    \n    checkForCollection(collectionName, 3);\n    checkForCollection(collectionName2, 2);\n\n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    int which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    SolrServer client = clients.get(which);\n    client.add(doc);\n    \n    doc = getDoc(id, 7, i1, 123, tlong, 123, t1,\n        \"humpty dumpy had a great fall\");\n    which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    client = clients.get(which);\n    client.add(doc);\n    doc = getDoc(id, 8, i1, 876, tlong, 876, t1,\n        \"all the kings horses and all the kings men\");\n    which = (doc.getField(id).toString().hashCode() & 0x7fffffff)\n        % clients.size();\n    client = clients.get(which);\n    client.add(doc);\n    \n    commit();\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName2);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName2);\n    \n    printLayout();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02c4407b4b9457dc4320063077c630e4c70f49d6","date":1344098895,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404or503(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404or503(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404or503(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      final String baseUrl = ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().substring(\n          0,\n          ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().length()\n              - DEFAULT_COLLECTION.length() - 1);\n      \n      createNewSolrServer(\"\", baseUrl).request(request);\n    }\n    \n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int i = 0; i < cnt; i++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + i, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      clients.get(clientIndex).request(request);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon404or503(collectionClient);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    clients.get(0).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    clients.get(0).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085","02c4407b4b9457dc4320063077c630e4c70f49d6","8512200aed2724abd80dbeb686d3412d537b7d8a"],"bugIntro":["1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa16b24e8441c80ef7c503119e979670698c7233","date":1347735556,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      final String baseUrl = ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().substring(\n          0,\n          ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().length()\n              - DEFAULT_COLLECTION.length() - 1);\n      \n      createNewSolrServer(\"\", baseUrl).request(request);\n    }\n    \n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int i = 0; i < cnt; i++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + i, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(\"numReplicas\", numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      final String baseUrl = ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().substring(\n          0,\n          ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().length()\n              - DEFAULT_COLLECTION.length() - 1);\n      \n      createNewSolrServer(\"\", baseUrl).request(request);\n    }\n    \n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int i = 0; i < cnt; i++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + i, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":["8512200aed2724abd80dbeb686d3412d537b7d8a"],"bugIntro":["1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1525b4dfbc0d413b8d7247da232009778e624836","date":1351101135,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      final String baseUrl = ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().substring(\n          0,\n          ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().length()\n              - DEFAULT_COLLECTION.length() - 1);\n      \n      createNewSolrServer(\"\", baseUrl).request(request);\n    }\n    \n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int i = 0; i < cnt; i++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + i, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085","e19067e820b148e8dc0b240da4f2771cf7b68252","8512200aed2724abd80dbeb686d3412d537b7d8a","aa16b24e8441c80ef7c503119e979670698c7233"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    for (int i = 0; i < cnt; i++) {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATE.toString());\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplicas = _TestUtil.nextInt(random(), 0, 5) + 1;\n      params.set(\"numShards\", numShards);\n      params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas);\n      String collectionName = \"awholynewcollection_\" + i;\n      int clientIndex = random().nextInt(2);\n      List<Integer> list = new ArrayList<Integer>();\n      list.add(numShards);\n      list.add(numReplicas);\n      collectionInfos.put(collectionName, list);\n      params.set(\"name\", collectionName);\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n   \n      final String baseUrl = ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().substring(\n          0,\n          ((HttpSolrServer) clients.get(clientIndex)).getBaseURL().length()\n              - DEFAULT_COLLECTION.length() - 1);\n      \n      createNewSolrServer(\"\", baseUrl).request(request);\n    }\n    \n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    for (int i = 0; i < cnt; i++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + i, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index and retrieve a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf","date":1351542322,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    checkForCollection(collectionName, 1);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n  }\n\n","bugFix":null,"bugIntro":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9460da0c2d9281eb6a595fbb0f54b3908e10855e","date":1353388087,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 3) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    checkForCollection(collectionName, 1);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    checkForCollection(collectionName, 1);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c215736a9e29403edd2132d9f0829a287b428df4","date":1354641965,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplica = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * (numReplica + 1)) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, numReplica, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(1);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int numReplica = 1;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, numReplica, maxShardsPerNode);\n    \n    // TODO: enable this check after removing the 60 second wait in it\n    //checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 3) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    checkForCollection(collectionName, 1);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplica = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * (numReplica + 1)) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, numReplica, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(1);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int numReplica = 1;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, numReplica, maxShardsPerNode);\n    \n    // TODO: enable this check after removing the 60 second wait in it\n    //checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      createCollection(collectionInfos, i,\n          _TestUtil.nextInt(random(), 0, shardCount) + 1,\n          _TestUtil.nextInt(random(), 0, 5) + 1);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list.get(0));\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    checkForCollection(collectionName, 1);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","date":1355167764,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, replicationFactor, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, replicationFactor, maxShardsPerNode);\n    \n    // TODO: enable this check after removing the 60 second wait in it\n    //checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplica = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * (numReplica + 1)) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, numReplica, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(1);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int numReplica = 1;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, numReplica, maxShardsPerNode);\n    \n    // TODO: enable this check after removing the 60 second wait in it\n    //checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n  }\n\n","bugFix":["c215736a9e29403edd2132d9f0829a287b428df4","2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf"],"bugIntro":["d334938e866757266d62025305edd378ac505a06"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0a4eeff354e8081247783f424a8e5a0fe106633","date":1355250757,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, replicationFactor, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, replicationFactor, maxShardsPerNode);\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, replicationFactor, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, replicationFactor, maxShardsPerNode);\n    \n    // TODO: enable this check after removing the 60 second wait in it\n    //checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d334938e866757266d62025305edd378ac505a06","date":1355368871,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, replicationFactor, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, replicationFactor, maxShardsPerNode);\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"bugIntro":["5a82d855abc18f7ee3e1ec359d8f256c8c86977a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a57adc9bfabbc207ed17740dd86e0a2401ea385","date":1355507623,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":["5a82d855abc18f7ee3e1ec359d8f256c8c86977a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69439d0df009e0bb0038d1e427159f449dd670d","date":1355704683,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(15000);\n      collectionClient.setSoTimeout(30000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd94b8f2963276a11491ec893e23bda20020210a","date":1355713287,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(15000);\n      collectionClient.setSoTimeout(45000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(15000);\n      collectionClient.setSoTimeout(30000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10b7cc4fd48eab496747b73b517357dcd53d71a1","date":1355729999,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(20000);\n      collectionClient.setSoTimeout(60000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(15000);\n      collectionClient.setSoTimeout(45000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0eff89b16ebd0046c839c5d02ee44500be5c7886","date":1355766557,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(20000);\n      collectionClient.setSoTimeout(60000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":null,"sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int numReplica = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * (numReplica + 1)) / getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n      createCollection(collectionInfos, i, numShards, numReplica, maxShardsPerNode);\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(1);\n    checkForCollection(collectionName, list);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int liveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (liveNodes/2) + 1;\n    int numReplica = 1;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, cnt, numShards, numReplica, maxShardsPerNode);\n    \n    // TODO: enable this check after removing the 60 second wait in it\n    //checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","0eff89b16ebd0046c839c5d02ee44500be5c7886"],"f0a4eeff354e8081247783f424a8e5a0fe106633":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"bd94b8f2963276a11491ec893e23bda20020210a":["a69439d0df009e0bb0038d1e427159f449dd670d"],"2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"a69439d0df009e0bb0038d1e427159f449dd670d":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["1525b4dfbc0d413b8d7247da232009778e624836"],"aa16b24e8441c80ef7c503119e979670698c7233":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"aba371508186796cc6151d8223a5b4e16d02e26e":["33d0ed80b7b47e34ad3ff033a77544563aba3085","01d7038753e558c19fba37629cb45f9740316fe7"],"10b7cc4fd48eab496747b73b517357dcd53d71a1":["bd94b8f2963276a11491ec893e23bda20020210a"],"c215736a9e29403edd2132d9f0829a287b428df4":["9460da0c2d9281eb6a595fbb0f54b3908e10855e"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"0eff89b16ebd0046c839c5d02ee44500be5c7886":["10b7cc4fd48eab496747b73b517357dcd53d71a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2126b84bd093fa3d921582a109a0ee578c28126":["aa16b24e8441c80ef7c503119e979670698c7233","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"02c4407b4b9457dc4320063077c630e4c70f49d6":["01d7038753e558c19fba37629cb45f9740316fe7"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9460da0c2d9281eb6a595fbb0f54b3908e10855e":["2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf"],"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4":["c215736a9e29403edd2132d9f0829a287b428df4"],"407687e67faf6e1f02a211ca078d8e3eed631027":["2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf","c215736a9e29403edd2132d9f0829a287b428df4"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["02c4407b4b9457dc4320063077c630e4c70f49d6"],"63fce89dfe8a5dcba79c726470441c175441f122":["8512200aed2724abd80dbeb686d3412d537b7d8a"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","02c4407b4b9457dc4320063077c630e4c70f49d6"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["d334938e866757266d62025305edd378ac505a06"],"d334938e866757266d62025305edd378ac505a06":["f0a4eeff354e8081247783f424a8e5a0fe106633"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","01d7038753e558c19fba37629cb45f9740316fe7"],"01d7038753e558c19fba37629cb45f9740316fe7":["63fce89dfe8a5dcba79c726470441c175441f122"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","02c4407b4b9457dc4320063077c630e4c70f49d6"],"1525b4dfbc0d413b8d7247da232009778e624836":["aa16b24e8441c80ef7c503119e979670698c7233"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0eff89b16ebd0046c839c5d02ee44500be5c7886"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"f0a4eeff354e8081247783f424a8e5a0fe106633":["d334938e866757266d62025305edd378ac505a06"],"bd94b8f2963276a11491ec893e23bda20020210a":["10b7cc4fd48eab496747b73b517357dcd53d71a1"],"2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf":["9460da0c2d9281eb6a595fbb0f54b3908e10855e","407687e67faf6e1f02a211ca078d8e3eed631027"],"a69439d0df009e0bb0038d1e427159f449dd670d":["bd94b8f2963276a11491ec893e23bda20020210a"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf","f2126b84bd093fa3d921582a109a0ee578c28126"],"aa16b24e8441c80ef7c503119e979670698c7233":["f2126b84bd093fa3d921582a109a0ee578c28126","1525b4dfbc0d413b8d7247da232009778e624836"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"10b7cc4fd48eab496747b73b517357dcd53d71a1":["0eff89b16ebd0046c839c5d02ee44500be5c7886"],"c215736a9e29403edd2132d9f0829a287b428df4":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","407687e67faf6e1f02a211ca078d8e3eed631027"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["63fce89dfe8a5dcba79c726470441c175441f122"],"0eff89b16ebd0046c839c5d02ee44500be5c7886":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"02c4407b4b9457dc4320063077c630e4c70f49d6":["e19067e820b148e8dc0b240da4f2771cf7b68252","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["aba371508186796cc6151d8223a5b4e16d02e26e","8512200aed2724abd80dbeb686d3412d537b7d8a"],"9460da0c2d9281eb6a595fbb0f54b3908e10855e":["c215736a9e29403edd2132d9f0829a287b428df4"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4":["f0a4eeff354e8081247783f424a8e5a0fe106633"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["aa16b24e8441c80ef7c503119e979670698c7233"],"63fce89dfe8a5dcba79c726470441c175441f122":["01d7038753e558c19fba37629cb45f9740316fe7"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["a69439d0df009e0bb0038d1e427159f449dd670d"],"d334938e866757266d62025305edd378ac505a06":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"01d7038753e558c19fba37629cb45f9740316fe7":["aba371508186796cc6151d8223a5b4e16d02e26e","02c4407b4b9457dc4320063077c630e4c70f49d6","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"1525b4dfbc0d413b8d7247da232009778e624836":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}