{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#getRange().mjava","commits":[{"id":"f7623716022a9a68898e329e8ffe6c36d168fba7","date":1384524101,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#getRange().mjava","pathOld":"/dev/null","sourceNew":"    Range getRange() {\n      int lowerBound;\n      int upperBound;\n\n      if(triLevel) {\n        lowerBound = hashes[0] & masks[0] | hashes[1] & masks[1];\n        upperBound = lowerBound | masks[2];\n      } else {\n        lowerBound = hashes[0] & masks[0];\n        upperBound = lowerBound | masks[1];\n      }\n      //  If the upper bits are 0xF0000000, the range we want to cover is\n      //  0xF0000000 0xFfffffff\n\n      if ((masks[0] == 0 && !triLevel) || (masks[0] == 0 && masks[1] == 0 && triLevel)) {\n        // no bits used from first part of key.. the code above will produce 0x000000000->0xffffffff\n        // which only works on unsigned space, but we're using signed space.\n        lowerBound = Integer.MIN_VALUE;\n        upperBound = Integer.MAX_VALUE;\n      }\n      Range r = new Range(lowerBound, upperBound);\n      return r;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe","date":1384867512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#getRange().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#getRange().mjava","sourceNew":"    Range getRange() {\n      int lowerBound;\n      int upperBound;\n\n      if (triLevel) {\n        lowerBound = hashes[0] & masks[0] | hashes[1] & masks[1];\n        upperBound = lowerBound | masks[2];\n      } else {\n        lowerBound = hashes[0] & masks[0];\n        upperBound = lowerBound | masks[1];\n      }\n      //  If the upper bits are 0xF0000000, the range we want to cover is\n      //  0xF0000000 0xFfffffff\n\n      if ((masks[0] == 0 && !triLevel) || (masks[0] == 0 && masks[1] == 0 && triLevel)) {\n        // no bits used from first part of key.. the code above will produce 0x000000000->0xffffffff\n        // which only works on unsigned space, but we're using signed space.\n        lowerBound = Integer.MIN_VALUE;\n        upperBound = Integer.MAX_VALUE;\n      }\n      Range r = new Range(lowerBound, upperBound);\n      return r;\n    }\n\n","sourceOld":"    Range getRange() {\n      int lowerBound;\n      int upperBound;\n\n      if(triLevel) {\n        lowerBound = hashes[0] & masks[0] | hashes[1] & masks[1];\n        upperBound = lowerBound | masks[2];\n      } else {\n        lowerBound = hashes[0] & masks[0];\n        upperBound = lowerBound | masks[1];\n      }\n      //  If the upper bits are 0xF0000000, the range we want to cover is\n      //  0xF0000000 0xFfffffff\n\n      if ((masks[0] == 0 && !triLevel) || (masks[0] == 0 && masks[1] == 0 && triLevel)) {\n        // no bits used from first part of key.. the code above will produce 0x000000000->0xffffffff\n        // which only works on unsigned space, but we're using signed space.\n        lowerBound = Integer.MIN_VALUE;\n        upperBound = Integer.MAX_VALUE;\n      }\n      Range r = new Range(lowerBound, upperBound);\n      return r;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#getRange().mjava","pathOld":"/dev/null","sourceNew":"    Range getRange() {\n      int lowerBound;\n      int upperBound;\n\n      if (triLevel) {\n        lowerBound = hashes[0] & masks[0] | hashes[1] & masks[1];\n        upperBound = lowerBound | masks[2];\n      } else {\n        lowerBound = hashes[0] & masks[0];\n        upperBound = lowerBound | masks[1];\n      }\n      //  If the upper bits are 0xF0000000, the range we want to cover is\n      //  0xF0000000 0xFfffffff\n\n      if ((masks[0] == 0 && !triLevel) || (masks[0] == 0 && masks[1] == 0 && triLevel)) {\n        // no bits used from first part of key.. the code above will produce 0x000000000->0xffffffff\n        // which only works on unsigned space, but we're using signed space.\n        lowerBound = Integer.MIN_VALUE;\n        upperBound = Integer.MAX_VALUE;\n      }\n      Range r = new Range(lowerBound, upperBound);\n      return r;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["f7623716022a9a68898e329e8ffe6c36d168fba7"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","f7623716022a9a68898e329e8ffe6c36d168fba7"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}