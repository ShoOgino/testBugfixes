{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleCopyJob#start().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleCopyJob#start().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void start() throws IOException {\n    if (iter == null) {\n      iter = toCopy.iterator();\n\n      // Send all file names / offsets up front to avoid ping-ping latency:\n      try {\n\n        // This means we resumed an already in-progress copy; we do this one first:\n        if (current != null) {\n          c.out.writeByte((byte) 0);\n          c.out.writeString(current.name);\n          c.out.writeVLong(current.getBytesCopied());\n          totBytes += current.metaData.length;\n        }\n\n        for (Map.Entry<String,FileMetaData> ent : toCopy) {\n          String fileName = ent.getKey();\n          FileMetaData metaData = ent.getValue();\n          totBytes += metaData.length;\n          c.out.writeByte((byte) 0);\n          c.out.writeString(fileName);\n          c.out.writeVLong(0);\n        }\n        c.out.writeByte((byte) 1);\n        c.flush();\n        c.s.shutdownOutput();\n\n        if (current != null) {\n          // Do this only at the end, after sending all requested files, so we don't deadlock due to socket buffering waiting for primary to\n          // send us this length:\n          long len = c.in.readVLong();\n          if (len != current.metaData.length) {\n            throw new IllegalStateException(\"file \" + current.name + \": meta data says length=\" + current.metaData.length + \" but c.in says \" + len);\n          }\n        }\n\n        dest.message(\"SimpleCopyJob.init: done start files count=\" + toCopy.size() + \" totBytes=\" + totBytes);\n\n      } catch (Throwable t) {\n        cancel(\"exc during start\", t);\n        throw new NodeCommunicationException(\"exc during start\", t);\n      }\n    } else {\n      throw new IllegalStateException(\"already started\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleCopyJob#start().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void start() throws IOException {\n    if (iter == null) {\n      iter = toCopy.iterator();\n\n      // Send all file names / offsets up front to avoid ping-ping latency:\n      try {\n\n        // This means we resumed an already in-progress copy; we do this one first:\n        if (current != null) {\n          c.out.writeByte((byte) 0);\n          c.out.writeString(current.name);\n          c.out.writeVLong(current.getBytesCopied());\n          totBytes += current.metaData.length;\n        }\n\n        for (Map.Entry<String,FileMetaData> ent : toCopy) {\n          String fileName = ent.getKey();\n          FileMetaData metaData = ent.getValue();\n          totBytes += metaData.length;\n          c.out.writeByte((byte) 0);\n          c.out.writeString(fileName);\n          c.out.writeVLong(0);\n        }\n        c.out.writeByte((byte) 1);\n        c.flush();\n        c.s.shutdownOutput();\n\n        if (current != null) {\n          // Do this only at the end, after sending all requested files, so we don't deadlock due to socket buffering waiting for primary to\n          // send us this length:\n          long len = c.in.readVLong();\n          if (len != current.metaData.length) {\n            throw new IllegalStateException(\"file \" + current.name + \": meta data says length=\" + current.metaData.length + \" but c.in says \" + len);\n          }\n        }\n\n        dest.message(\"SimpleCopyJob.init: done start files count=\" + toCopy.size() + \" totBytes=\" + totBytes);\n\n      } catch (Throwable t) {\n        cancel(\"exc during start\", t);\n        throw new NodeCommunicationException(\"exc during start\", t);\n      }\n    } else {\n      throw new IllegalStateException(\"already started\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}