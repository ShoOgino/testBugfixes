{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","commits":[{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","pathOld":"/dev/null","sourceNew":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    cluster.waitForActiveCollection(COL, 1, 1);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .sendDirectUpdatesToAnyShardReplica()\n        .withParallelUpdates(true)\n        .build()) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"]},"commit2Childs":{"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}