{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","commits":[{"id":"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa","date":1349450075,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      // try next chunk\n      int bitsPerValue = readHeader();\n      if (docBase + chunkDocs <= doc) {\n        // doc is not in the next chunk, use seek to skip to the next document chunk\n        fieldsStream.seek(indexReader.getStartPointer(doc));\n        bitsPerValue = readHeader();\n      }\n      if (doc < docBase\n          || doc >= docBase + chunkDocs) {\n        throw new CorruptIndexException(\"Corrupted: docID=\" + doc\n            + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs);\n      }\n\n      // decode lengths\n      if (lengths.length < chunkDocs) {\n        lengths = new int[ArrayUtil.oversize(chunkDocs, 4)];\n      }\n      final PackedInts.ReaderIterator iterator = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 0);\n      for (int i = 0; i < chunkDocs; ++i) {\n        lengths[i] = (int) iterator.next();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eba3cb2a268b9fb6f5be011fbaaf698699dcf24c","date":1352305464,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","sourceNew":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      fieldsStream.seek(indexReader.getStartPointer(doc));\n\n      final int docBase = fieldsStream.readVInt();\n      final int chunkDocs = fieldsStream.readVInt();\n      if (docBase < this.docBase + this.chunkDocs\n          || docBase + chunkDocs > numDocs) {\n        throw new CorruptIndexException(\"Corrupted: current docBase=\" + this.docBase\n            + \", current numDocs=\" + this.chunkDocs + \", new docBase=\" + docBase\n            + \", new numDocs=\" + chunkDocs);\n      }\n      this.docBase = docBase;\n      this.chunkDocs = chunkDocs;\n\n      if (chunkDocs > numStoredFields.length) {\n        final int newLength = ArrayUtil.oversize(chunkDocs, 4);\n        numStoredFields = new int[newLength];\n        lengths = new int[newLength];\n      }\n\n      if (chunkDocs == 1) {\n        numStoredFields[0] = fieldsStream.readVInt();\n        lengths[0] = fieldsStream.readVInt();\n      } else {\n        final int bitsPerStoredFields = fieldsStream.readVInt();\n        if (bitsPerStoredFields == 0) {\n          Arrays.fill(numStoredFields, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerStoredFields > 31) {\n          throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            numStoredFields[i] = (int) it.next();\n          }\n        }\n\n        final int bitsPerLength = fieldsStream.readVInt();\n        if (bitsPerLength == 0) {\n          Arrays.fill(lengths, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerLength > 31) {\n          throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            lengths[i] = (int) it.next();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      // try next chunk\n      int bitsPerValue = readHeader();\n      if (docBase + chunkDocs <= doc) {\n        // doc is not in the next chunk, use seek to skip to the next document chunk\n        fieldsStream.seek(indexReader.getStartPointer(doc));\n        bitsPerValue = readHeader();\n      }\n      if (doc < docBase\n          || doc >= docBase + chunkDocs) {\n        throw new CorruptIndexException(\"Corrupted: docID=\" + doc\n            + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs);\n      }\n\n      // decode lengths\n      if (lengths.length < chunkDocs) {\n        lengths = new int[ArrayUtil.oversize(chunkDocs, 4)];\n      }\n      final PackedInts.ReaderIterator iterator = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 0);\n      for (int i = 0; i < chunkDocs; ++i) {\n        lengths[i] = (int) iterator.next();\n      }\n    }\n\n","bugFix":null,"bugIntro":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","date":1352818449,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","sourceNew":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      fieldsStream.seek(indexReader.getStartPointer(doc));\n\n      final int docBase = fieldsStream.readVInt();\n      final int chunkDocs = fieldsStream.readVInt();\n      if (docBase < this.docBase + this.chunkDocs\n          || docBase + chunkDocs > numDocs) {\n        throw new CorruptIndexException(\"Corrupted: current docBase=\" + this.docBase\n            + \", current numDocs=\" + this.chunkDocs + \", new docBase=\" + docBase\n            + \", new numDocs=\" + chunkDocs);\n      }\n      this.docBase = docBase;\n      this.chunkDocs = chunkDocs;\n\n      if (chunkDocs > numStoredFields.length) {\n        final int newLength = ArrayUtil.oversize(chunkDocs, 4);\n        numStoredFields = new int[newLength];\n        lengths = new int[newLength];\n      }\n\n      if (chunkDocs == 1) {\n        numStoredFields[0] = fieldsStream.readVInt();\n        lengths[0] = fieldsStream.readVInt();\n      } else {\n        final int bitsPerStoredFields = fieldsStream.readVInt();\n        if (bitsPerStoredFields == 0) {\n          Arrays.fill(numStoredFields, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerStoredFields > 31) {\n          throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            numStoredFields[i] = (int) it.next();\n          }\n        }\n\n        final int bitsPerLength = fieldsStream.readVInt();\n        if (bitsPerLength == 0) {\n          Arrays.fill(lengths, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerLength > 31) {\n          throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            lengths[i] = (int) it.next();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      fieldsStream.seek(indexReader.getStartPointer(doc));\n\n      final int docBase = fieldsStream.readVInt();\n      final int chunkDocs = fieldsStream.readVInt();\n      if (docBase < this.docBase + this.chunkDocs\n          || docBase + chunkDocs > numDocs) {\n        throw new CorruptIndexException(\"Corrupted: current docBase=\" + this.docBase\n            + \", current numDocs=\" + this.chunkDocs + \", new docBase=\" + docBase\n            + \", new numDocs=\" + chunkDocs);\n      }\n      this.docBase = docBase;\n      this.chunkDocs = chunkDocs;\n\n      if (chunkDocs > numStoredFields.length) {\n        final int newLength = ArrayUtil.oversize(chunkDocs, 4);\n        numStoredFields = new int[newLength];\n        lengths = new int[newLength];\n      }\n\n      if (chunkDocs == 1) {\n        numStoredFields[0] = fieldsStream.readVInt();\n        lengths[0] = fieldsStream.readVInt();\n      } else {\n        final int bitsPerStoredFields = fieldsStream.readVInt();\n        if (bitsPerStoredFields == 0) {\n          Arrays.fill(numStoredFields, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerStoredFields > 31) {\n          throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            numStoredFields[i] = (int) it.next();\n          }\n        }\n\n        final int bitsPerLength = fieldsStream.readVInt();\n        if (bitsPerLength == 0) {\n          Arrays.fill(lengths, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerLength > 31) {\n          throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            lengths[i] = (int) it.next();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader.ChunkIterator#next(int).mjava","sourceNew":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      fieldsStream.seek(indexReader.getStartPointer(doc));\n\n      final int docBase = fieldsStream.readVInt();\n      final int chunkDocs = fieldsStream.readVInt();\n      if (docBase < this.docBase + this.chunkDocs\n          || docBase + chunkDocs > numDocs) {\n        throw new CorruptIndexException(\"Corrupted: current docBase=\" + this.docBase\n            + \", current numDocs=\" + this.chunkDocs + \", new docBase=\" + docBase\n            + \", new numDocs=\" + chunkDocs);\n      }\n      this.docBase = docBase;\n      this.chunkDocs = chunkDocs;\n\n      if (chunkDocs > numStoredFields.length) {\n        final int newLength = ArrayUtil.oversize(chunkDocs, 4);\n        numStoredFields = new int[newLength];\n        lengths = new int[newLength];\n      }\n\n      if (chunkDocs == 1) {\n        numStoredFields[0] = fieldsStream.readVInt();\n        lengths[0] = fieldsStream.readVInt();\n      } else {\n        final int bitsPerStoredFields = fieldsStream.readVInt();\n        if (bitsPerStoredFields == 0) {\n          Arrays.fill(numStoredFields, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerStoredFields > 31) {\n          throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            numStoredFields[i] = (int) it.next();\n          }\n        }\n\n        final int bitsPerLength = fieldsStream.readVInt();\n        if (bitsPerLength == 0) {\n          Arrays.fill(lengths, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerLength > 31) {\n          throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            lengths[i] = (int) it.next();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Go to the chunk containing the provided doc ID.\n     */\n    void next(int doc) throws IOException {\n      assert doc >= docBase + chunkDocs : doc + \" \" + docBase + \" \" + chunkDocs;\n      fieldsStream.seek(indexReader.getStartPointer(doc));\n\n      final int docBase = fieldsStream.readVInt();\n      final int chunkDocs = fieldsStream.readVInt();\n      if (docBase < this.docBase + this.chunkDocs\n          || docBase + chunkDocs > numDocs) {\n        throw new CorruptIndexException(\"Corrupted: current docBase=\" + this.docBase\n            + \", current numDocs=\" + this.chunkDocs + \", new docBase=\" + docBase\n            + \", new numDocs=\" + chunkDocs);\n      }\n      this.docBase = docBase;\n      this.chunkDocs = chunkDocs;\n\n      if (chunkDocs > numStoredFields.length) {\n        final int newLength = ArrayUtil.oversize(chunkDocs, 4);\n        numStoredFields = new int[newLength];\n        lengths = new int[newLength];\n      }\n\n      if (chunkDocs == 1) {\n        numStoredFields[0] = fieldsStream.readVInt();\n        lengths[0] = fieldsStream.readVInt();\n      } else {\n        final int bitsPerStoredFields = fieldsStream.readVInt();\n        if (bitsPerStoredFields == 0) {\n          Arrays.fill(numStoredFields, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerStoredFields > 31) {\n          throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            numStoredFields[i] = (int) it.next();\n          }\n        }\n\n        final int bitsPerLength = fieldsStream.readVInt();\n        if (bitsPerLength == 0) {\n          Arrays.fill(lengths, 0, chunkDocs, fieldsStream.readVInt());\n        } else if (bitsPerLength > 31) {\n          throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n        } else {\n          final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n          for (int i = 0; i < chunkDocs; ++i) {\n            lengths[i] = (int) it.next();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["eba3cb2a268b9fb6f5be011fbaaf698699dcf24c"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["eba3cb2a268b9fb6f5be011fbaaf698699dcf24c","5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"eba3cb2a268b9fb6f5be011fbaaf698699dcf24c":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"]},"commit2Childs":{"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["eba3cb2a268b9fb6f5be011fbaaf698699dcf24c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"eba3cb2a268b9fb6f5be011fbaaf698699dcf24c":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}