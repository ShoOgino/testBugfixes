{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","commits":[{"id":"b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7","date":1482745036,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);\n      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);\n      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, splitPackedValues, leafBlockFPs, spareDocIds);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"/dev/null","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);\n      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);\n      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);\n      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);\n      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDims];\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"452aca01058c8a4e6827ff9096664dde4a1d9790","date":1543310809,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      \n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68144b3b30df82b7233727bc4fb958ce52e5b483","date":1543396715,"type":3,"author":"Christoph Bscher","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = FutureArrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = FutureArrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          for(int j=0;j<commonPrefixLengths[dim];j++) {\n            if (scratchBytesRef1.bytes[scratchBytesRef1.offset+offset+j] != scratchBytesRef2.bytes[scratchBytesRef2.offset+offset+j]) {\n              commonPrefixLengths[dim] = j;\n              break;\n            }\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = bytesPerDim;\n      for (int i = 0; i < bytesPerDim; ++i) {\n        if (minPackedValue[splitDim * bytesPerDim + i] != maxPackedValue[splitDim * bytesPerDim + i]) {\n          commonPrefixLen = i;\n          break;\n        }\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = FutureArrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = FutureArrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = FutureArrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.getPosition() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = FutureArrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = FutureArrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = FutureArrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b","date":1561536972,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7f06758793500ca773d0df1037290e6e404fb33","date":1562230223,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0f206e78bea6261260b24c406e920d05c7ca2f3","date":1570809619,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      final int splitDim;\n      // compute the split dimension and partition around it\n      if (numIndexDims == 1) {\n        splitDim = 0;\n      } else {\n        // for dimensions > 2 we recompute the bounds for the current inner node to help the algorithm choose best\n        // split dimensions. Because it is an expensive operation, the frequency we recompute the bounds is given\n        // by SPLITS_BEFORE_EXACT_BOUNDS.\n        if (nodeID > 1 && numIndexDims > 2 && Arrays.stream(parentSplits).sum() % SPLITS_BEFORE_EXACT_BOUNDS == 0) {\n          computePackedValueBounds(reader, from, to, minPackedValue, maxPackedValue, scratchBytesRef1);\n        }\n        splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      }\n\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      final int splitDim;\n      // compute the split dimension and partition around it\n      if (numIndexDims == 1) {\n        splitDim = 0;\n      } else {\n        // for dimensions > 2 we recompute the bounds for the current inner node to help the algorithm choose best\n        // split dimensions. Because it is an expensive operation, the frequency we recompute the bounds is given\n        // by SPLITS_BEFORE_EXACT_BOUNDS.\n        if (nodeID > 1 && numIndexDims > 2 && Arrays.stream(parentSplits).sum() % SPLITS_BEFORE_EXACT_BOUNDS == 0) {\n          computePackedValueBounds(reader, from, to, minPackedValue, maxPackedValue, scratchBytesRef1);\n        }\n        splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      }\n\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      // compute the split dimension and partition around it\n      final int splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7","date":1588412059,"type":5,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#build(int,int,MutablePointValues,int,int,IndexOutput,byte[],byte[],int[],byte[],long[],int[]).mjava","sourceNew":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leavesOffset, int numLeaves,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (numLeaves == 1) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[leavesOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      final int splitDim;\n      // compute the split dimension and partition around it\n      if (numIndexDims == 1) {\n        splitDim = 0;\n      } else {\n        // for dimensions > 2 we recompute the bounds for the current inner node to help the algorithm choose best\n        // split dimensions. Because it is an expensive operation, the frequency we recompute the bounds is given\n        // by SPLITS_BEFORE_EXACT_BOUNDS.\n        if (nodeID > 1 && numIndexDims > 2 && Arrays.stream(parentSplits).sum() % SPLITS_BEFORE_EXACT_BOUNDS == 0) {\n          computePackedValueBounds(reader, from, to, minPackedValue, maxPackedValue, scratchBytesRef1);\n        }\n        splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      }\n\n      // How many leaves will be in the left tree:\n      int numLeftLeafNodes = getNumLeftLeafNodes(numLeaves);\n      // How many points will be in the left tree:\n      final int mid = from + numLeftLeafNodes * maxPointsInLeafNode;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leavesOffset, numLeftLeafNodes, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leavesOffset + numLeftLeafNodes, numLeaves - numLeftLeafNodes, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","sourceOld":"  /* Recursively reorders the provided reader and writes the bkd-tree on the fly; this method is used\n   * when we are writing a new segment directly from IndexWriter's indexing buffer (MutablePointsReader). */\n  private void build(int nodeID, int leafNodeOffset,\n                     MutablePointValues reader, int from, int to,\n                     IndexOutput out,\n                     byte[] minPackedValue, byte[] maxPackedValue,\n                     int[] parentSplits,\n                     byte[] splitPackedValues,\n                     long[] leafBlockFPs,\n                     int[] spareDocIds) throws IOException {\n\n    if (nodeID >= leafNodeOffset) {\n      // leaf node\n      final int count = to - from;\n      assert count <= maxPointsInLeafNode;\n\n      // Compute common prefixes\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      reader.getValue(from, scratchBytesRef1);\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, scratchBytesRef2);\n        for (int dim=0;dim<numDataDims;dim++) {\n          final int offset = dim * bytesPerDim;\n          int dimensionPrefixLength = commonPrefixLengths[dim];\n          commonPrefixLengths[dim] = Arrays.mismatch(scratchBytesRef1.bytes, scratchBytesRef1.offset + offset,\n              scratchBytesRef1.offset + offset + dimensionPrefixLength,\n              scratchBytesRef2.bytes, scratchBytesRef2.offset + offset,\n              scratchBytesRef2.offset + offset + dimensionPrefixLength);\n          if (commonPrefixLengths[dim] == -1) {\n            commonPrefixLengths[dim] = dimensionPrefixLength;\n          }\n        }\n      }\n\n      // Find the dimension that has the least number of unique bytes at commonPrefixLengths[dim]\n      FixedBitSet[] usedBytes = new FixedBitSet[numDataDims];\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (commonPrefixLengths[dim] < bytesPerDim) {\n          usedBytes[dim] = new FixedBitSet(256);\n        }\n      }\n      for (int i = from + 1; i < to; ++i) {\n        for (int dim=0;dim<numDataDims;dim++) {\n          if (usedBytes[dim] != null) {\n            byte b = reader.getByteAt(i, dim * bytesPerDim + commonPrefixLengths[dim]);\n            usedBytes[dim].set(Byte.toUnsignedInt(b));\n          }\n        }\n      }\n      int sortedDim = 0;\n      int sortedDimCardinality = Integer.MAX_VALUE;\n      for (int dim = 0; dim < numDataDims; ++dim) {\n        if (usedBytes[dim] != null) {\n          final int cardinality = usedBytes[dim].cardinality();\n          if (cardinality < sortedDimCardinality) {\n            sortedDim = dim;\n            sortedDimCardinality = cardinality;\n          }\n        }\n      }\n\n      // sort by sortedDim\n      MutablePointsReaderUtils.sortByDim(numDataDims, numIndexDims, sortedDim, bytesPerDim, commonPrefixLengths,\n          reader, from, to, scratchBytesRef1, scratchBytesRef2);\n\n      BytesRef comparator = scratchBytesRef1;\n      BytesRef collector = scratchBytesRef2;\n      reader.getValue(from, comparator);\n      int leafCardinality = 1;\n      for (int i = from + 1; i < to; ++i) {\n        reader.getValue(i, collector);\n        for (int dim =0; dim < numDataDims; dim++) {\n          final int start = dim * bytesPerDim + commonPrefixLengths[dim];\n          final int end = dim * bytesPerDim + bytesPerDim;\n          if (Arrays.mismatch(collector.bytes, collector.offset + start, collector.offset + end,\n              comparator.bytes, comparator.offset + start, comparator.offset + end) != -1) {\n            leafCardinality++;\n            BytesRef scratch = collector;\n            collector = comparator;\n            comparator = scratch;\n            break;\n          }\n        }\n      }\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = out.getFilePointer();\n\n      assert scratchOut.size() == 0;\n\n      // Write doc IDs\n      int[] docIDs = spareDocIds;\n      for (int i = from; i < to; ++i) {\n        docIDs[i - from] = reader.getDocID(i);\n      }\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      writeLeafBlockDocs(scratchOut, docIDs, 0, count);\n\n      // Write the common prefixes:\n      reader.getValue(from, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset, scratch1, 0, packedBytesLength);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, scratch1);\n\n      // Write the full values:\n      IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          reader.getValue(from + i, scratchBytesRef1);\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(count, sortedDim, minPackedValue, maxPackedValue, packedValues,\n          docIDs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, count, sortedDim, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    } else {\n      // inner node\n\n      final int splitDim;\n      // compute the split dimension and partition around it\n      if (numIndexDims == 1) {\n        splitDim = 0;\n      } else {\n        // for dimensions > 2 we recompute the bounds for the current inner node to help the algorithm choose best\n        // split dimensions. Because it is an expensive operation, the frequency we recompute the bounds is given\n        // by SPLITS_BEFORE_EXACT_BOUNDS.\n        if (nodeID > 1 && numIndexDims > 2 && Arrays.stream(parentSplits).sum() % SPLITS_BEFORE_EXACT_BOUNDS == 0) {\n          computePackedValueBounds(reader, from, to, minPackedValue, maxPackedValue, scratchBytesRef1);\n        }\n        splitDim = split(minPackedValue, maxPackedValue, parentSplits);\n      }\n\n      final int mid = (from + to + 1) >>> 1;\n\n      int commonPrefixLen = Arrays.mismatch(minPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim, maxPackedValue, splitDim * bytesPerDim,\n          splitDim * bytesPerDim + bytesPerDim);\n      if (commonPrefixLen == -1) {\n        commonPrefixLen = bytesPerDim;\n      }\n\n      MutablePointsReaderUtils.partition(numDataDims, numIndexDims, maxDoc, splitDim, bytesPerDim, commonPrefixLen,\n          reader, from, to, mid, scratchBytesRef1, scratchBytesRef2);\n\n      // set the split value\n      final int address = nodeID * (1+bytesPerDim);\n      splitPackedValues[address] = (byte) splitDim;\n      reader.getValue(mid, scratchBytesRef1);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);\n\n      byte[] minSplitPackedValue = ArrayUtil.copyOfSubArray(minPackedValue, 0, packedIndexBytesLength);\n      byte[] maxSplitPackedValue = ArrayUtil.copyOfSubArray(maxPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n      System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,\n          maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n      // recurse\n      parentSplits[splitDim]++;\n      build(nodeID * 2, leafNodeOffset, reader, from, mid, out,\n          minPackedValue, maxSplitPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      build(nodeID * 2 + 1, leafNodeOffset, reader, mid, to, out,\n          minSplitPackedValue, maxPackedValue, parentSplits,\n          splitPackedValues, leafBlockFPs, spareDocIds);\n      parentSplits[splitDim]--;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"452aca01058c8a4e6827ff9096664dde4a1d9790":["f6652c943595e92c187ee904c382863013eae28f"],"68144b3b30df82b7233727bc4fb958ce52e5b483":["452aca01058c8a4e6827ff9096664dde4a1d9790"],"f6652c943595e92c187ee904c382863013eae28f":["9798d0818e7a880546802b509792d3f3d57babd2"],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7"],"c7f06758793500ca773d0df1037290e6e404fb33":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["68144b3b30df82b7233727bc4fb958ce52e5b483"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7","9798d0818e7a880546802b509792d3f3d57babd2"],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["d0f206e78bea6261260b24c406e920d05c7ca2f3"],"d0f206e78bea6261260b24c406e920d05c7ca2f3":["c7f06758793500ca773d0df1037290e6e404fb33"],"9798d0818e7a880546802b509792d3f3d57babd2":["b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"b0b597c65628ca9e73913a07e81691f8229bae35":["c7f06758793500ca773d0df1037290e6e404fb33","d0f206e78bea6261260b24c406e920d05c7ca2f3"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"452aca01058c8a4e6827ff9096664dde4a1d9790":["68144b3b30df82b7233727bc4fb958ce52e5b483"],"68144b3b30df82b7233727bc4fb958ce52e5b483":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"f6652c943595e92c187ee904c382863013eae28f":["452aca01058c8a4e6827ff9096664dde4a1d9790"],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["c7f06758793500ca773d0df1037290e6e404fb33"],"b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7":["f03e4bed5023ec3ef93a771b8888cae991cf448d","b70042a8a492f7054d480ccdd2be9796510d4327","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"c7f06758793500ca773d0df1037290e6e404fb33":["d0f206e78bea6261260b24c406e920d05c7ca2f3","b0b597c65628ca9e73913a07e81691f8229bae35"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b35cfd3fa0a5c9e066b0256c4818af1d2a9f22d7","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0f206e78bea6261260b24c406e920d05c7ca2f3":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7","b0b597c65628ca9e73913a07e81691f8229bae35"],"9798d0818e7a880546802b509792d3f3d57babd2":["f6652c943595e92c187ee904c382863013eae28f","b70042a8a492f7054d480ccdd2be9796510d4327","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["f03e4bed5023ec3ef93a771b8888cae991cf448d","b70042a8a492f7054d480ccdd2be9796510d4327","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}