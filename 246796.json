{"path":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleTestFacetResult,SimpleDrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      // nocommit if we add this to FR then re-enable this:\n      // assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleTestFacetResult expected,\n                    SimpleDrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      SimpleFacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      // nocommit if we add this to SimpleFR then re-enable this:\n      // assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd83550e4b0bdd36e7d9dca9273264100782440b","date":1385761753,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      // nocommit if we add this to FR then re-enable this:\n      // assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"/dev/null","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91eb857a56b1a3a6659c666f88e2398347fc1c5a","date":1483442809,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected, DrillSidewaysResult actual,\n          Map<String, Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for (int i = 0; i < expected.hits.size(); i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id, s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for (int dim = 0; dim < expected.counts.length; dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\" + dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String, Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for (LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for (int i = 0; i < topNIDs.length; i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\n                    \"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for (int i = 0; i < topNIDs.length; i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for (int i = 0; i < dimValues[dim].length; i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for (int i = 0; i < dimValues[dim].length; i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected, DrillSidewaysResult actual,\n          Map<String, Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for (int i = 0; i < expected.hits.size(); i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id, s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for (int dim = 0; dim < expected.counts.length; dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\" + dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String, Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for (LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for (int i = 0; i < topNIDs.length; i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\n                    \"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for (int i = 0; i < topNIDs.length; i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for (int i = 0; i < dimValues[dim].length; i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for (int i = 0; i < dimValues[dim].length; i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected, DrillSidewaysResult actual,\n          Map<String, Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits.value);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for (int i = 0; i < expected.hits.size(); i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id, s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for (int dim = 0; dim < expected.counts.length; dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\" + dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String, Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for (LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for (int i = 0; i < topNIDs.length; i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\n                    \"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for (int i = 0; i < topNIDs.length; i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for (int i = 0; i < dimValues[dim].length; i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for (int i = 0; i < dimValues[dim].length; i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected, DrillSidewaysResult actual,\n          Map<String, Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for (int i = 0; i < expected.hits.size(); i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id, s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for (int dim = 0; dim < expected.counts.length; dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\" + dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String, Integer> actualValues = new HashMap<>();\n\n      if (fr != null) {\n        for (LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n        assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.childCount);\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for (int i = 0; i < topNIDs.length; i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\n                    \"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for (int i = 0; i < topNIDs.length; i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for (int i = 0; i < dimValues[dim].length; i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            }\n          }\n        }\n\n        int setCount = 0;\n        for (int i = 0; i < dimValues[dim].length; i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0e7bc21595222ae4f75509300fbb7726691f387f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["21d36d0db865f7b84026b447bec653469a6e66df"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["0e7bc21595222ae4f75509300fbb7726691f387f"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fd83550e4b0bdd36e7d9dca9273264100782440b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","0e7bc21595222ae4f75509300fbb7726691f387f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","91eb857a56b1a3a6659c666f88e2398347fc1c5a"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0e7bc21595222ae4f75509300fbb7726691f387f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","3cc728b07df73b197e6d940d27f9b08b63918f13"],"0e7bc21595222ae4f75509300fbb7726691f387f":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"21d36d0db865f7b84026b447bec653469a6e66df":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6613659748fe4411a7dcf85266e55db1f95f7315"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["83788ad129a5154d5c6562c4e8ce3db48793aada","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}