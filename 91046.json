{"path":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    try {\n      if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        // this would need a reader to implement (to be able to check committed\n        // before adding.)\n        // return addNoOverwriteNoDups(cmd);\n      } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n        rc = addConditionally(cmd);\n        return rc;\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n        rc = overwriteBoth(cmd);\n        return rc;\n      } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n        rc = allowDups(cmd);\n        return rc;\n      } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n      } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n      } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n        rc = overwriteBoth(cmd);\n        return rc;\n      }\n      throw new SolrException(400,\"unsupported param combo:\" + cmd);\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c065faf385411ac4ff02bdc763de7dfd8aa1c9f","date":1163033034,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    iwAccess.lock();\n    try {\n\n      // We can't using iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.increment(1);          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    // might need to commit (wait for searcher if so)\n    checkCommit(true);\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    try {\n      if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        // this would need a reader to implement (to be able to check committed\n        // before adding.)\n        // return addNoOverwriteNoDups(cmd);\n      } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n        rc = addConditionally(cmd);\n        return rc;\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n        rc = overwriteBoth(cmd);\n        return rc;\n      } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n        rc = allowDups(cmd);\n        return rc;\n      } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n      } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n        throw new SolrException(400,\"unsupported param combo:\" + cmd);\n      } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n        rc = overwriteBoth(cmd);\n        return rc;\n      }\n      throw new SolrException(400,\"unsupported param combo:\" + cmd);\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2562fab31a7b144e6187859bfa09e363dc6de268","date":1170358826,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    iwAccess.lock();\n    try {\n\n      // We can't using iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    iwAccess.lock();\n    try {\n\n      // We can't using iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.increment(1);          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    // might need to commit (wait for searcher if so)\n    checkCommit(true);\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0fca88525a75f64dd5d66cc89ad355e9ff10ed5","date":1174335919,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't using iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    iwAccess.lock();\n    try {\n\n      // We can't using iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":["114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52bc3124a8d6a8eda16d43834db32eb20af3a056","date":1176682139,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't using iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException(400,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a16a21ce0db3df902bcea143bbf027dcbdd44437","date":1188947139,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    if (maxPendingDeletes > 0 && pset.size() > maxPendingDeletes) {\n      iwCommit.lock();\n      try {\n        // note: this may be entered multiple times since the synchro is \n        // inside the if(), but doDeletions() is a cheap no-op if it has\n        // already executed\n        doDeletions();\n      } finally {\n        iwCommit.unlock();\n      }\n    }    \n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae","date":1210454197,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        closeSearcher();\n        openWriter();\n        tracker.addedDocument();\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        if (!cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n          // this would need a reader to implement (to be able to check committed\n          // before adding.)\n          // return addNoOverwriteNoDups(cmd);\n        } else if (!cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = addConditionally(cmd);\n      } else if (!cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (!cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && !cmd.overwriteCommitted) {\n          rc = allowDups(cmd);\n        } else if (cmd.allowDups && !cmd.overwritePending && cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && !cmd.overwriteCommitted) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        } else if (cmd.allowDups && cmd.overwritePending && cmd.overwriteCommitted) {\n          rc = overwriteBoth(cmd);\n        }\n        if (rc == -1)\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"unsupported param combo:\" + cmd);\n        \n        if (rc == 1) {\n          // adding document -- prep writer\n          closeSearcher();\n          openWriter();\n          tracker.addedDocument();          \n        } else {\n          // exit prematurely\n          return rc;\n        }\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n      assert(rc == 1);\n      writer.addDocument(cmd.doc);\n      \n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n    if (maxPendingDeletes > 0 && pset.size() > maxPendingDeletes) {\n      iwCommit.lock();\n      try {\n        // note: this may be entered multiple times since the synchro is \n        // inside the if(), but doDeletions() is a cheap no-op if it has\n        // already executed\n        doDeletions();\n      } finally {\n        iwCommit.unlock();\n      }\n    }    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd0695d017a09d8819e247ede79b526a0a3bd15f","date":1222958604,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument();\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        closeSearcher();\n        openWriter();\n        tracker.addedDocument();\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e97a7d6ce275d5deea94b74ce25d8551202f9ba","date":1223943844,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument();\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1","date":1232905968,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n    \n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":["c0fca88525a75f64dd5d66cc89ad355e9ff10ed5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80c633e661becbcb6deb6ea2ef4588d230102f50","date":1234308117,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        writer.updateDocument(idTerm.createTerm(cmd.indexedId), cmd.getLuceneDocument(schema));\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c065faf385411ac4ff02bdc763de7dfd8aa1c9f":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"2e97a7d6ce275d5deea94b74ce25d8551202f9ba":["bd0695d017a09d8819e247ede79b526a0a3bd15f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"52bc3124a8d6a8eda16d43834db32eb20af3a056":["c0fca88525a75f64dd5d66cc89ad355e9ff10ed5"],"978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae":["a16a21ce0db3df902bcea143bbf027dcbdd44437"],"80c633e661becbcb6deb6ea2ef4588d230102f50":["114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1"],"bd0695d017a09d8819e247ede79b526a0a3bd15f":["978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["52bc3124a8d6a8eda16d43834db32eb20af3a056"],"c0fca88525a75f64dd5d66cc89ad355e9ff10ed5":["2562fab31a7b144e6187859bfa09e363dc6de268"],"a16a21ce0db3df902bcea143bbf027dcbdd44437":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1":["2e97a7d6ce275d5deea94b74ce25d8551202f9ba"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2562fab31a7b144e6187859bfa09e363dc6de268":["4c065faf385411ac4ff02bdc763de7dfd8aa1c9f"],"ad94625fb8d088209f46650c8097196fec67f00c":["80c633e661becbcb6deb6ea2ef4588d230102f50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"4c065faf385411ac4ff02bdc763de7dfd8aa1c9f":["2562fab31a7b144e6187859bfa09e363dc6de268"],"2e97a7d6ce275d5deea94b74ce25d8551202f9ba":["114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"52bc3124a8d6a8eda16d43834db32eb20af3a056":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae":["bd0695d017a09d8819e247ede79b526a0a3bd15f"],"80c633e661becbcb6deb6ea2ef4588d230102f50":["ad94625fb8d088209f46650c8097196fec67f00c"],"bd0695d017a09d8819e247ede79b526a0a3bd15f":["2e97a7d6ce275d5deea94b74ce25d8551202f9ba"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["a16a21ce0db3df902bcea143bbf027dcbdd44437"],"c0fca88525a75f64dd5d66cc89ad355e9ff10ed5":["52bc3124a8d6a8eda16d43834db32eb20af3a056"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["4c065faf385411ac4ff02bdc763de7dfd8aa1c9f"],"a16a21ce0db3df902bcea143bbf027dcbdd44437":["978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae"],"114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1":["80c633e661becbcb6deb6ea2ef4588d230102f50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2562fab31a7b144e6187859bfa09e363dc6de268":["c0fca88525a75f64dd5d66cc89ad355e9ff10ed5"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}