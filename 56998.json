{"path":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","commits":[{"id":"d943163030bbd7a9caf93cb5fea92257390a2a99","date":1403094254,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Filter).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n              }\n              \n            };         \n          }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          Map<Field, Object> fieldValues = new HashMap<>();\n          for (Field f : cachedInfo.referenceFields) {\n            fieldValues.put(f, f.get(ob));\n          }\n\n          totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Filter filter) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o) && filter.accept(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            if (filter.accept(f)) {\n              // Fast path to eliminate redundancies.\n              final Object o = f.get(ob);\n              if (o != null && !seen.contains(o) && filter.accept(o)) {\n                stack.add(o);\n              }\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Filter).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n              }\n              \n            };         \n          }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          Map<Field, Object> fieldValues = new HashMap<>();\n          for (Field f : cachedInfo.referenceFields) {\n            fieldValues.put(f, f.get(ob));\n          }\n\n          totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Filter filter) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o) && filter.accept(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            if (filter.accept(f)) {\n              // Fast path to eliminate redundancies.\n              final Object o = f.get(ob);\n              if (o != null && !seen.contains(o) && filter.accept(o)) {\n                stack.add(o);\n              }\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b8f3bf7eb63b67ff23cc48ab2aee7df2393f06f","date":1418292961,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n              }\n              \n            };         \n          }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          Map<Field, Object> fieldValues = new HashMap<>();\n          for (Field f : cachedInfo.referenceFields) {\n            fieldValues.put(f, f.get(ob));\n          }\n\n          totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n              }\n              \n            };         \n          }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          Map<Field, Object> fieldValues = new HashMap<>();\n          for (Field f : cachedInfo.referenceFields) {\n            fieldValues.put(f, f.get(ob));\n          }\n\n          totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"772af34227438013872590cf48fd0a96c4057704","date":1482972983,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n              }\n              \n            };         \n          }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          Map<Field, Object> fieldValues = new HashMap<>();\n          for (Field f : cachedInfo.referenceFields) {\n            fieldValues.put(f, f.get(ob));\n          }\n\n          totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":["8913cb9a44846cb65e41bee682ba0372f1636056"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b7b510d9a3cfc99c22d3602451a652ce97e4bfb","date":1483039907,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":["8913cb9a44846cb65e41bee682ba0372f1636056"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n              }\n              \n            };         \n          }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          Map<Field, Object> fieldValues = new HashMap<>();\n          for (Field f : cachedInfo.referenceFields) {\n            fieldValues.put(f, f.get(ob));\n          }\n\n          totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0509386580032996a559871d20e73d0ab67a5be","date":1547724210,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            long alignedShallowInstanceSize = RamUsageEstimator.shallowSizeOf(ob);\n\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, alignedShallowInstanceSize + func.applyAsLong(ob),\n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof ByteBuffer) {\n              // Approximate ByteBuffers with their underlying storage (ignores field overhead).\n              totalSize += byteArraySize(((ByteBuffer) ob).capacity());\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n            final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }\n          }\n\n          if (needsReflection) {\n            ClassCache cachedInfo = classCache.get(obClazz);\n            if (cachedInfo == null) {\n              classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n            }\n\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":["015fe54423e69e4d1c2fe80205f847d915d36413"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"015fe54423e69e4d1c2fe80205f847d915d36413","date":1547726736,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            long alignedShallowInstanceSize = RamUsageEstimator.shallowSizeOf(ob);\n\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, alignedShallowInstanceSize + func.applyAsLong(ob),\n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof ByteBuffer) {\n              // Approximate ByteBuffers with their underlying storage (ignores field overhead).\n              totalSize += byteArraySize(((ByteBuffer) ob).capacity());\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n            final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }\n          }\n\n          if (needsReflection) {\n            ClassCache cachedInfo = classCache.get(obClazz);\n            if (cachedInfo == null) {\n              classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n            }\n\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":["e0509386580032996a559871d20e73d0ab67a5be"],"bugIntro":["8913cb9a44846cb65e41bee682ba0372f1636056"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8913cb9a44846cb65e41bee682ba0372f1636056","date":1547808953,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Accumulator).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final long obSize;\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        obSize = handleArray(accumulator, stack, ob, obClazz);\n      } else {\n        obSize = handleOther(accumulator, classCache, stack, ob, obClazz);\n      }\n\n      totalSize += obSize;\n      // Dump size of each object for comparisons across JVMs and flags.\n      // System.out.println(\"  += \" + obClazz + \" | \" + obSize);\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Accumulator accumulator) {\n    // Objects seen so far.\n    final Set<Object> seen = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        final long shallowSize = RamUsageEstimator.shallowSizeOf(ob);\n        final int len = Array.getLength(ob);\n        final List<Object> values;\n        Class<?> componentClazz = obClazz.getComponentType();\n        if (componentClazz.isPrimitive()) {\n          values = Collections.emptyList();\n        } else {\n          values = new AbstractList<Object>() {\n\n            @Override\n            public Object get(int index) {\n              return Array.get(ob, index);\n            }\n\n            @Override\n            public int size() {\n              return len;\n            }\n            \n          };\n        }\n        totalSize += accumulator.accumulateArray(ob, shallowSize, values, stack);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n          \n          boolean needsReflection = true;\n          if (Constants.JRE_IS_MINIMUM_JAVA9 && obClazz.getName().startsWith(\"java.\")) {\n            // Java 9: Best guess for some known types, as we cannot precisely look into runtime classes:\n            final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);\n            if (func != null) { // some simple type like String where the size is easy to get from public properties\n              totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize + func.applyAsLong(ob), \n                  Collections.emptyMap(), stack);\n              needsReflection = false;\n            } else if (ob instanceof Iterable) {\n              final List<Object> values = StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              needsReflection = false;\n            }  else if (ob instanceof Map) {\n              final List<Object> values = ((Map<?,?>) ob).entrySet().stream()\n                  .flatMap(e -> Stream.of(e.getKey(), e.getValue()))\n                  .collect(Collectors.toList());\n              totalSize += accumulator.accumulateArray(ob, cachedInfo.alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER, values, stack);\n              totalSize += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n              needsReflection = false;\n            }\n          }\n          if (needsReflection) {\n            final Map<Field, Object> fieldValues = new HashMap<>();\n            for (Field f : cachedInfo.referenceFields) {\n              fieldValues.put(f, f.get(ob));\n            }\n            totalSize += accumulator.accumulateObject(ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);\n          }\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":["772af34227438013872590cf48fd0a96c4057704","10cd47aac3c4e8c583740a750335f8aab14555b3","d943163030bbd7a9caf93cb5fea92257390a2a99","6b7b510d9a3cfc99c22d3602451a652ce97e4bfb","015fe54423e69e4d1c2fe80205f847d915d36413"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8913cb9a44846cb65e41bee682ba0372f1636056":["015fe54423e69e4d1c2fe80205f847d915d36413"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d943163030bbd7a9caf93cb5fea92257390a2a99"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d943163030bbd7a9caf93cb5fea92257390a2a99":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"772af34227438013872590cf48fd0a96c4057704":["6b8f3bf7eb63b67ff23cc48ab2aee7df2393f06f"],"6b7b510d9a3cfc99c22d3602451a652ce97e4bfb":["772af34227438013872590cf48fd0a96c4057704"],"015fe54423e69e4d1c2fe80205f847d915d36413":["e0509386580032996a559871d20e73d0ab67a5be"],"e0509386580032996a559871d20e73d0ab67a5be":["6b7b510d9a3cfc99c22d3602451a652ce97e4bfb"],"6b8f3bf7eb63b67ff23cc48ab2aee7df2393f06f":["d943163030bbd7a9caf93cb5fea92257390a2a99"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8913cb9a44846cb65e41bee682ba0372f1636056"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["6b8f3bf7eb63b67ff23cc48ab2aee7df2393f06f","6b7b510d9a3cfc99c22d3602451a652ce97e4bfb"]},"commit2Childs":{"8913cb9a44846cb65e41bee682ba0372f1636056":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","d943163030bbd7a9caf93cb5fea92257390a2a99"],"d943163030bbd7a9caf93cb5fea92257390a2a99":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","6b8f3bf7eb63b67ff23cc48ab2aee7df2393f06f"],"772af34227438013872590cf48fd0a96c4057704":["6b7b510d9a3cfc99c22d3602451a652ce97e4bfb"],"6b7b510d9a3cfc99c22d3602451a652ce97e4bfb":["e0509386580032996a559871d20e73d0ab67a5be","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"015fe54423e69e4d1c2fe80205f847d915d36413":["8913cb9a44846cb65e41bee682ba0372f1636056"],"6b8f3bf7eb63b67ff23cc48ab2aee7df2393f06f":["772af34227438013872590cf48fd0a96c4057704","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"e0509386580032996a559871d20e73d0ab67a5be":["015fe54423e69e4d1c2fe80205f847d915d36413"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}