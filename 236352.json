{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#startPrimary(int).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#startPrimary(int).mjava","pathOld":"/dev/null","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    // Publish new primary, before replaying xlog.  This means other indexing ops can come in at the same time as we catch up indexing\n    // previous ops.  Effectively, we have \"forked\" the indexing ops, by rolling back in time a bit, and replaying old indexing ops (from\n    // translog) concurrently with new incoming ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    int nextMarkerUpto = markerUpto.get();\n    message(\"top: replay trans log \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n    message(\"top: done replay trans log\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#startPrimary(int).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#startPrimary(int).mjava","sourceNew":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    // Publish new primary, before replaying xlog.  This means other indexing ops can come in at the same time as we catch up indexing\n    // previous ops.  Effectively, we have \"forked\" the indexing ops, by rolling back in time a bit, and replaying old indexing ops (from\n    // translog) concurrently with new incoming ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    int nextMarkerUpto = markerUpto.get();\n    message(\"top: replay trans log \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n    message(\"top: done replay trans log\");\n  }\n\n","sourceOld":"  void startPrimary(int id) throws IOException {\n    message(id + \": top: startPrimary lastPrimaryVersion=\" + lastPrimaryVersion);\n    assert nodes[id] == null;\n\n    // Force version of new primary to advance beyond where old primary was, so we never re-use versions.  It may have\n    // already advanced beyond newVersion, e.g. if it flushed new segments while during xlog replay:\n\n    // First start node as primary (it opens an IndexWriter) but do not publish it for searching until we replay xlog:\n    NodeProcess newPrimary = startNode(id, indexPaths[id], true, lastPrimaryVersion+1);\n    if (newPrimary == null) {\n      message(\"top: newPrimary failed to start; abort\");\n      return;\n    }\n\n    // Get xlog location that this node was guaranteed to already have indexed through; this may replay some ops already indexed but it's OK\n    // because the ops are idempotent: we updateDocument (by docid) on replay even for original addDocument:\n    Long startTransLogLoc;\n    Integer markerCount;\n    if (newPrimary.initCommitVersion == 0) {\n      startTransLogLoc = 0L;\n      markerCount = 0;\n    } else {\n      startTransLogLoc = versionToTransLogLocation.get(newPrimary.initCommitVersion);\n      markerCount = versionToMarker.get(newPrimary.initCommitVersion);\n    }\n    assert startTransLogLoc != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToTransLogLocation: keys=\" + versionToTransLogLocation.keySet();\n    assert markerCount != null: \"newPrimary.initCommitVersion=\" + newPrimary.initCommitVersion + \" is missing from versionToMarker: keys=\" + versionToMarker.keySet();\n\n    // When the primary starts, the userData in its latest commit point tells us which version it had indexed up to, so we know where to\n    // replay from in the xlog.  However, we forcefuly advance the version, and then IW on init (or maybe getReader) also adds 1 to it.\n    // Since we publish the primary in this state (before xlog replay is done), a replica can start up at this point and pull this version,\n    // and possibly later be chosen as a primary, causing problems if the version is known recorded in the translog map.  So we record it\n    // here:\n\n    addTransLogLoc(newPrimary.initInfosVersion, startTransLogLoc);\n    addVersionMarker(newPrimary.initInfosVersion, markerCount);\n\n    assert newPrimary.initInfosVersion >= lastPrimaryVersion;\n    message(\"top: now change lastPrimaryVersion from \" + lastPrimaryVersion + \" to \" + newPrimary.initInfosVersion);\n    lastPrimaryVersion = newPrimary.initInfosVersion;\n\n    // Publish new primary, before replaying xlog.  This means other indexing ops can come in at the same time as we catch up indexing\n    // previous ops.  Effectively, we have \"forked\" the indexing ops, by rolling back in time a bit, and replaying old indexing ops (from\n    // translog) concurrently with new incoming ops.\n    nodes[id] = newPrimary;\n    primary = newPrimary;\n\n    sendReplicasToPrimary();\n\n    long nextTransLogLoc = transLog.getNextLocation();\n    int nextMarkerUpto = markerUpto.get();\n    message(\"top: replay trans log \" + startTransLogLoc + \" (version=\" + newPrimary.initCommitVersion + \") to \" + nextTransLogLoc + \" (translog end)\");\n    try {\n      transLog.replay(newPrimary, startTransLogLoc, nextTransLogLoc);\n    } catch (IOException ioe) {\n      message(\"top: replay xlog failed; abort\");\n      return;\n    }\n    message(\"top: done replay trans log\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}