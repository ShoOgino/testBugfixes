{"path":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","commits":[{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","pathOld":"/dev/null","sourceNew":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      Query slotQ = slotContext.apply(slot).getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our skg() function is used as a \"top level\" stat\n        // w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      final BucketData slotVal = new BucketData();\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n      slotvalues[slot] = slotVal;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f77f7d9a57c791efb2e6f8720dc5b3bf9a620f19","date":1527010911,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","sourceNew":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      Query slotQ = slotContext.apply(slot).getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      final BucketData slotVal = new BucketData();\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n      slotvalues[slot] = slotVal;\n    }\n\n","sourceOld":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      Query slotQ = slotContext.apply(slot).getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our skg() function is used as a \"top level\" stat\n        // w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      final BucketData slotVal = new BucketData();\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n      slotvalues[slot] = slotVal;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","date":1532538390,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","sourceNew":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      Query slotQ = slotContext.apply(slot).getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      final BucketData slotVal = new BucketData(agg);\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n      slotvalues[slot] = slotVal;\n    }\n\n","sourceOld":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      Query slotQ = slotContext.apply(slot).getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      final BucketData slotVal = new BucketData();\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n      slotvalues[slot] = slotVal;\n    }\n\n","bugFix":null,"bugIntro":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22d2c45da6e47ff0ada29a8f98566b76f0b278de","date":1591372739,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","sourceNew":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      final BucketData slotVal = new BucketData(agg);\n      slotvalues[slot] = slotVal;\n      \n      final SlotContext ctx = slotContext.apply(slot);\n      if (ctx.isAllBuckets()) {\n        // relatedness is meaningless for allBuckets (see SOLR-14467)\n        // our current (implied & empty) BucketData is all we need\n        //\n        // NOTE: it might be temping to use 'slotvalues[slot] = null' in this case\n        // since getValue() will also ultimately generate an implied bucket in that case,\n        // but by using a non-null bucket we let collect(int,...) know it doesn't need to keep calling\n        // processSlot over and over.\n        return;\n      }\n      \n      Query slotQ = ctx.getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n    }\n\n","sourceOld":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      Query slotQ = slotContext.apply(slot).getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      final BucketData slotVal = new BucketData(agg);\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n      slotvalues[slot] = slotVal;\n    }\n\n","bugFix":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","2c705a0d590cf911e7c942df49563ca2ea176e22"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f9e4bd10604489b5817ee29e35ac96a3148cbec","date":1594345357,"type":3,"author":"Michael Gibney","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.SKGSlotAcc#processSlot(int,IntFunction[SlotContext]).mjava","sourceNew":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      final BucketData slotVal = new BucketData(agg);\n      slotvalues[slot] = slotVal;\n      \n      final SlotContext ctx = slotContext.apply(slot);\n      if (ctx.isAllBuckets()) {\n        // relatedness is meaningless for allBuckets (see SOLR-14467)\n        // our current (implied & empty) BucketData is all we need\n        //\n        // NOTE: it might be temping to use 'slotvalues[slot] = null' in this case\n        // since getValue() will also ultimately generate an implied bucket in that case,\n        // but by using a non-null bucket we let collect(int,...) know it doesn't need to keep calling\n        // processSlot over and over.\n        return;\n      }\n      \n      Query slotQ = ctx.getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet;\n      if (null == slotQ) {\n        slotSet = fcontext.base;\n      } else {\n        slotSet = fcontext.searcher.getDocSet(slotQ);\n      }\n\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n    }\n\n","sourceOld":"    private void processSlot(int slot, IntFunction<SlotContext> slotContext) throws IOException {\n      \n      assert null != slotContext;\n      \n      final BucketData slotVal = new BucketData(agg);\n      slotvalues[slot] = slotVal;\n      \n      final SlotContext ctx = slotContext.apply(slot);\n      if (ctx.isAllBuckets()) {\n        // relatedness is meaningless for allBuckets (see SOLR-14467)\n        // our current (implied & empty) BucketData is all we need\n        //\n        // NOTE: it might be temping to use 'slotvalues[slot] = null' in this case\n        // since getValue() will also ultimately generate an implied bucket in that case,\n        // but by using a non-null bucket we let collect(int,...) know it doesn't need to keep calling\n        // processSlot over and over.\n        return;\n      }\n      \n      Query slotQ = ctx.getSlotQuery();\n      if (null == slotQ) {\n        // extremeley special edge case...\n        // the only way this should be possible is if our relatedness() function is used as a \"top level\"\n        // stat w/o being nested under any facet, in which case it should be a FacetQuery w/no parent...\n        assert fcontext.processor.freq instanceof FacetQuery : fcontext.processor.freq;\n        assert null == fcontext.parent;\n        assert null == fcontext.filter;\n      }\n      // ...and in which case we should just use the current base\n      final DocSet slotSet = null == slotQ ? fcontext.base : fcontext.searcher.getDocSet(slotQ);\n\n      slotVal.incSizes(fgSize, bgSize);\n      slotVal.incCounts(fgSet.intersectionSize(slotSet),\n                        bgSet.intersectionSize(slotSet));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c705a0d590cf911e7c942df49563ca2ea176e22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["f77f7d9a57c791efb2e6f8720dc5b3bf9a620f19"],"f77f7d9a57c791efb2e6f8720dc5b3bf9a620f19":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"]},"commit2Childs":{"2c705a0d590cf911e7c942df49563ca2ea176e22":["f77f7d9a57c791efb2e6f8720dc5b3bf9a620f19"],"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"f77f7d9a57c791efb2e6f8720dc5b3bf9a620f19":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}