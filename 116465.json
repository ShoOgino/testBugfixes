{"path":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMatchedFields().mjava","commits":[{"id":"050e6201c3a7d4c351ebc06cbe4822e26e028117","date":1382375603,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FastVectorHighlighterTest#testMatchedFields().mjava","pathOld":"/dev/null","sourceNew":"  public void testMatchedFields() throws IOException {\n    // Searching just on the stored field doesn't highlight a stopword\n    matchedFieldsTestCase( false, true, \"a match\", \"a <b>match</b>\",\n      clause( \"field\", \"a\" ), clause( \"field\", \"match\" ) );\n\n    // Even if you add an unqueried matched field that would match it\n    matchedFieldsTestCase( \"a match\", \"a <b>match</b>\",\n      clause( \"field\", \"a\" ), clause( \"field\", \"match\" ) );\n\n    // Nor if you query the field but don't add it as a matched field to the highlighter\n    matchedFieldsTestCase( false, false, \"a match\", \"a <b>match</b>\",\n      clause( \"field_exact\", \"a\" ), clause( \"field\", \"match\" ) );\n\n    // But if you query the field and add it as a matched field to the highlighter then it is highlighted\n    matchedFieldsTestCase( \"a match\", \"<b>a</b> <b>match</b>\",\n      clause( \"field_exact\", \"a\" ), clause( \"field\", \"match\" ) );\n\n    // It is also ok to match just the matched field but get highlighting from the stored field\n    matchedFieldsTestCase( \"a match\", \"<b>a</b> <b>match</b>\",\n      clause( \"field_exact\", \"a\" ), clause( \"field_exact\", \"match\" ) );\n\n    // Boosted matched fields work too\n    matchedFieldsTestCase( \"a match\", \"<b>a</b> <b>match</b>\",\n      clause( \"field_exact\", 5, \"a\" ), clause( \"field\", \"match\" ) );\n\n    // It is also ok if both the stored and the matched field match the term\n    matchedFieldsTestCase( \"a match\", \"a <b>match</b>\",\n      clause( \"field_exact\", \"match\" ), clause( \"field\", \"match\" ) );\n\n    // And the highlighter respects the boosts on matched fields when sorting fragments\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_exact\", 5, \"a\", \"cat\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> <b>cat</b> junk junk junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_exact\", \"a\", \"cat\" ) );\n\n    // The same thing works across three fields as well\n    matchedFieldsTestCase( \"cat cat CAT junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_exact\", 200, \"a\", \"cat\" ), clause( \"field_super_exact\", 5, \"CAT\" ) );\n    matchedFieldsTestCase( \"a cat cat junk junk junk junk junk junk junk a CAT junk junk\",\n      \"junk junk <b>a CAT</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_exact\", 5, \"a\", \"cat\" ), clause( \"field_super_exact\", 200, \"a\", \"CAT\" ) );\n\n    // And across fields with different tokenizers!\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field_exact\", 5, \"a\", \"cat\" ), clause( \"field_characters\", \"c\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>c</b>at <b>c</b>at junk junk junk junk\",\n      clause( \"field_exact\", \"a\", \"cat\" ), clause( \"field_characters\", \"c\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"ca<b>t</b> ca<b>t</b> junk junk junk junk\",\n      clause( \"field_exact\", \"a\", \"cat\" ), clause( \"field_characters\", \"t\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> <b>cat</b> junk junk junk junk\", // See how the phrases are joined?\n      clause( \"field\", \"cat\" ), clause( \"field_characters\", 5, \"c\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_characters\", 5, \"a\", \" \", \"c\", \"a\", \"t\" ) );\n\n    // Phrases and tokens inside one another are joined\n    matchedFieldsTestCase( \"cats wow\", \"<b>cats w</b>ow\",\n      clause( \"field\", \"cats\" ), clause( \"field_tripples\", \"s w\" ) );\n\n    // Everything works pretty well even if you don't require a field match\n    matchedFieldsTestCase( true, false, \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_characters\", 10, \"a\", \" \", \"c\", \"a\", \"t\" ) );\n\n    // Even boosts keep themselves pretty much intact\n    matchedFieldsTestCase( true, false, \"a cat cat junk junk junk junk junk junk junk a CAT junk junk\",\n      \"junk junk <b>a CAT</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_exact\", 5, \"a\", \"cat\" ), clause( \"field_super_exact\", 200, \"a\", \"CAT\" ) );\n    matchedFieldsTestCase( true, false, \"cat cat CAT junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_exact\", 200, \"a\", \"cat\" ), clause( \"field_super_exact\", 5, \"CAT\" ) );\n\n    // Except that all the matched field matches apply even if they aren't mentioned in the query\n    // which can make for some confusing scoring.  This isn't too big a deal, just something you\n    // need to think about when you don't force a field match.\n    matchedFieldsTestCase( true, false, \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> <b>cat</b> junk junk junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_characters\", 4, \"a\", \" \", \"c\", \"a\", \"t\" ) );\n\n    // It is also cool to match fields that don't have _exactly_ the same text so long as you are careful.\n    // In this case field_sliced is a prefix of field.\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> <b>cat</b> junk junk junk junk\", clause( \"field_sliced\", \"cat\" ) );\n\n    // Multiple matches add to the score of the segment\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> <b>cat</b> junk junk junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_sliced\", \"cat\" ), clause( \"field_exact\", 2, \"a\", \"cat\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"junk junk <b>a cat</b> junk junk\",\n      clause( \"field\", \"cat\" ), clause( \"field_sliced\", \"cat\" ), clause( \"field_exact\", 4, \"a\", \"cat\" ) );\n\n    // Even fields with tokens on top of one another are ok\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> cat junk junk junk junk\",\n      clause( \"field_der_red\", 2, \"der\" ), clause( \"field_exact\", \"a\", \"cat\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> cat junk junk junk junk\",\n      clause( \"field_der_red\", 2, \"red\" ), clause( \"field_exact\", \"a\", \"cat\" ) );\n    matchedFieldsTestCase( \"cat cat junk junk junk junk junk junk junk a cat junk junk\",\n      \"<b>cat</b> cat junk junk junk junk\",\n      clause( \"field_der_red\", \"red\" ), clause( \"field_der_red\", \"der\" ), clause( \"field_exact\", \"a\", \"cat\" ) );\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"050e6201c3a7d4c351ebc06cbe4822e26e028117":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["050e6201c3a7d4c351ebc06cbe4822e26e028117"]},"commit2Childs":{"050e6201c3a7d4c351ebc06cbe4822e26e028117":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["050e6201c3a7d4c351ebc06cbe4822e26e028117"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}