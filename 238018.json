{"path":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a92d88a85748af0cb6a68706f8ac3ba6bd686fa6","date":1346421325,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d1f90e969803cc84174589b5e4a39b7935fecd","date":1346584861,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.shutdown();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.shutdown();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.shutdown();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.shutdown();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"683242c67a3f6086bae8b1354748fcaa38edfbd5","date":1457575601,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a92d88a85748af0cb6a68706f8ac3ba6bd686fa6"],"770342641f7b505eaa8dccdc666158bff2419109":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a92d88a85748af0cb6a68706f8ac3ba6bd686fa6":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"683242c67a3f6086bae8b1354748fcaa38edfbd5":["770342641f7b505eaa8dccdc666158bff2419109"],"d0d1f90e969803cc84174589b5e4a39b7935fecd":["04f07771a2a7dd3a395700665ed839c3dae2def2","a92d88a85748af0cb6a68706f8ac3ba6bd686fa6"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["683242c67a3f6086bae8b1354748fcaa38edfbd5"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"770342641f7b505eaa8dccdc666158bff2419109":["683242c67a3f6086bae8b1354748fcaa38edfbd5"],"a92d88a85748af0cb6a68706f8ac3ba6bd686fa6":["6613659748fe4411a7dcf85266e55db1f95f7315","d0d1f90e969803cc84174589b5e4a39b7935fecd"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["a92d88a85748af0cb6a68706f8ac3ba6bd686fa6","d0d1f90e969803cc84174589b5e4a39b7935fecd"],"683242c67a3f6086bae8b1354748fcaa38edfbd5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0d1f90e969803cc84174589b5e4a39b7935fecd":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["770342641f7b505eaa8dccdc666158bff2419109"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d0d1f90e969803cc84174589b5e4a39b7935fecd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}