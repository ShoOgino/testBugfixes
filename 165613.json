{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","sourceNew":"  @Override\n  public Cell getCell(Point p, int level) {\n    List<Cell> cells = new ArrayList<>(1);\n    build(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n    return cells.get(0);//note cells could be longer if p on edge\n  }\n\n","sourceOld":"  @Override\n  public Cell getCell(Point p, int level) {\n    List<Cell> cells = new ArrayList<>(1);\n    build(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n    return cells.get(0);//note cells could be longer if p on edge\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","sourceNew":"  @Override\n  public Cell getCell(Point p, int level) {\n    List<Cell> cells = new ArrayList<>(1);\n    build(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n    return cells.get(0);//note cells could be longer if p on edge\n  }\n\n","sourceOld":"  @Override\n  public Cell getCell(Point p, int level) {\n    List<Cell> cells = new ArrayList<>(1);\n    build(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n    return cells.get(0);//note cells could be longer if p on edge\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e34e9db64b6fb5add5b2968e3a46342cef8363c7","date":1566335373,"type":3,"author":"nppoly","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","sourceNew":"  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","sourceOld":"  @Override\n  public Cell getCell(Point p, int level) {\n    List<Cell> cells = new ArrayList<>(1);\n    build(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n    return cells.get(0);//note cells could be longer if p on edge\n  }\n\n","bugFix":["9d3854546d75fdc5a4c3b13d0c67b6b331185945"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","sourceNew":"  @SuppressWarnings(\"deprecation\")\n  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","sourceOld":"  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","sourceNew":"  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"deprecation\")\n  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree#getCell(Point,int).mjava","sourceNew":"  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.getShapeFactory().pointXY(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","sourceOld":"  @Override\n  public Cell getCell(Point p, int level) {\n    if (!robust) { // old method\n      List<Cell> cells = new ArrayList<>(1);\n      buildNotRobustly(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(), p.getY()), level);\n      if (!cells.isEmpty()) {\n        return cells.get(0);//note cells could be longer if p on edge\n      }\n    }\n\n    double currentXmid = xmid;\n    double currentYmid = ymid;\n    double xp = p.getX();\n    double yp = p.getY();\n    long  term = 0L;\n    int levelLimit = level > maxLevels ? maxLevels : level;\n    SpatialRelation rel = SpatialRelation.CONTAINS;\n    for (int lvl = 0; lvl < levelLimit; lvl++){\n      int quad = battenberg(currentXmid, currentYmid, xp, yp);\n      double halfWidth = levelW[lvl + 1];\n      double halfHeight = levelH[lvl + 1];\n      switch(quad){\n        case 0:\n          currentXmid -= halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 1:\n          currentXmid += halfWidth;\n          currentYmid += halfHeight;\n          break;\n        case 2:\n          currentXmid -= halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        case 3:\n          currentXmid += halfWidth;\n          currentYmid -= halfHeight;\n          break;\n        default:\n      }\n      // set bits for next level\n      term |= (((long)(quad))<<(64-((lvl + 1)<<1)));\n      // increment level\n      term = ((term>>>1)+1)<<1;\n    }\n    return new PackedQuadCell(term, rel);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["e34e9db64b6fb5add5b2968e3a46342cef8363c7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"e34e9db64b6fb5add5b2968e3a46342cef8363c7":["af2638813028b254a88b418ebeafb541afb49653"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["e34e9db64b6fb5add5b2968e3a46342cef8363c7"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"e34e9db64b6fb5add5b2968e3a46342cef8363c7":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}