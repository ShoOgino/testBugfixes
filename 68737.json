{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","commits":[{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorighm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","date":1550036130,"type":3,"author":"Bruno P. Kinoshita","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","sourceNew":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorithm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorighm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6e1f11b7318d917420b640db7b796381c39c7c8","date":1578907651,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","sourceNew":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorithm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    Transition transition = new Transition();\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      transition.source = q;\n      transition.transitionUpto = -1;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.next(transition, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorithm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2509bad1fbf30792438821cc94f7a5e1a13d5473","date":1578934553,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","sourceNew":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorithm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    Transition transition = new Transition();\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      transition.source = q;\n      transition.transitionUpto = -1;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.next(transition, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorithm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d6e1f11b7318d917420b640db7b796381c39c7c8":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d6e1f11b7318d917420b640db7b796381c39c7c8"],"2509bad1fbf30792438821cc94f7a5e1a13d5473":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","d6e1f11b7318d917420b640db7b796381c39c7c8"]},"commit2Childs":{"d6e1f11b7318d917420b640db7b796381c39c7c8":["cd5edd1f2b162a5cfa08efd17851a07373a96817","2509bad1fbf30792438821cc94f7a5e1a13d5473"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["d6e1f11b7318d917420b640db7b796381c39c7c8","2509bad1fbf30792438821cc94f7a5e1a13d5473"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2509bad1fbf30792438821cc94f7a5e1a13d5473":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","2509bad1fbf30792438821cc94f7a5e1a13d5473"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}