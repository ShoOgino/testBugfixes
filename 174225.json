{"path":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","commits":[{"id":"4708e7bf7695781d702d204d178627b4faddc03f","date":1326982060,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"/dev/null","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f04dea8ce9675dc75eb2483feb840a86f765fb82","date":1328049049,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        FST.Arc<Long> prevArc = null;\n\n        // TODO: we could do binary search here if node arcs\n        // are array'd:\n        while(true) {\n          //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n          // This is the min output we'd hit if we follow\n          // this arc:\n          final long minArcOutput = output + arc.output;\n\n          if (minArcOutput == targetOutput) {\n            // Recurse on this arc:\n            //System.out.println(\"  match!  break\");\n            output = minArcOutput;\n            result.ints[upto++] = arc.label;\n            break;\n          } else if (minArcOutput > targetOutput) {\n            if (prevArc == null) {\n              // Output doesn't exist\n              return null;\n            } else {\n              // Recurse on previous arc:\n              arc.copyFrom(prevArc);\n              result.ints[upto++] = arc.label;\n              output += arc.output;\n              //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n              break;\n            }\n          } else if (arc.isLast()) {\n            // Recurse on this arc:\n            output = minArcOutput;\n            //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n            result.ints[upto++] = arc.label;\n            break;\n          } else {\n            // Read next arc in this node:\n            prevArc = scratchArc;\n            prevArc.copyFrom(arc);\n            //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n            fst.readNextRealArc(arc, in);\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["4708e7bf7695781d702d204d178627b4faddc03f"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["4708e7bf7695781d702d204d178627b4faddc03f","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f04dea8ce9675dc75eb2483feb840a86f765fb82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["4708e7bf7695781d702d204d178627b4faddc03f","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f04dea8ce9675dc75eb2483feb840a86f765fb82":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"4708e7bf7695781d702d204d178627b4faddc03f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","f04dea8ce9675dc75eb2483feb840a86f765fb82"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4708e7bf7695781d702d204d178627b4faddc03f"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"4708e7bf7695781d702d204d178627b4faddc03f":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"f04dea8ce9675dc75eb2483feb840a86f765fb82":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}