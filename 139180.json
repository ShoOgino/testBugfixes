{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final Iterator<ThreadState> allActiveThreads = perThreadPool.getActivePerThreadsIterator();\n    while (allActiveThreads.hasNext()) {\n      final ThreadState next = allActiveThreads.next();\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.perThread.deleteQueue == flushingQueue\n            || next.perThread.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.perThread.deleteQueue\n            + \" numDocsInRam: \" + next.perThread.getNumDocsInRAM();\n        if (next.perThread.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      stallControl.updateStalled(this);\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final Iterator<ThreadState> allActiveThreads = perThreadPool.getActivePerThreadsIterator();\n    while (allActiveThreads.hasNext()) {\n      final ThreadState next = allActiveThreads.next();\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.perThread.deleteQueue == flushingQueue\n            || next.perThread.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.perThread.deleteQueue\n            + \" numDocsInRam: \" + next.perThread.getNumDocsInRAM();\n        if (next.perThread.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      stallControl.updateStalled(this);\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600","date":1329061481,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      stallControl.updateStalled(this);\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final Iterator<ThreadState> allActiveThreads = perThreadPool.getActivePerThreadsIterator();\n    while (allActiveThreads.hasNext()) {\n      final ThreadState next = allActiveThreads.next();\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.perThread.deleteQueue == flushingQueue\n            || next.perThread.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.perThread.deleteQueue\n            + \" numDocsInRam: \" + next.perThread.getNumDocsInRAM();\n        if (next.perThread.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      stallControl.updateStalled(this);\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e38f40562eb7c165ae08ab2367a031883138354","date":1340287338,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      stallControl.updateStalled(this);\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      stallControl.updateStalled(this);\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          if (closed && next.isActive()) {\n            perThreadPool.deactivateThreadState(next);\n          }\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          if (closed && next.isActive()) {\n            perThreadPool.deactivateThreadState(next);\n          }\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          if (closed && next.isActive()) {\n            perThreadPool.deactivateThreadState(next);\n          }\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isActive()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          if (closed && next.isActive()) {\n            perThreadPool.deactivateThreadState(next);\n          }\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadState();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          if (closed && next.isActive()) {\n            perThreadPool.deactivateThreadState(next);\n          }\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5898ca35059bc3a89ba6a275ec92a5c32057aedc","date":1436893905,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          if (closed && next.isActive()) {\n            perThreadPool.deactivateThreadState(next);\n          }\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f492fe129985750df09c8dac738aecc503158bb3","date":1464099630,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      // nocommit is this (active thread state count) always enough of a gap?  what if new indexing thread sneaks in just now?  it would\n      // have to get this next delete queue?\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f6df47cbfd656ea50ca2996361f7954531ee18b","date":1464133540,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // jump over any possible in flight ops:\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      // nocommit is this (active thread state count) always enough of a gap?  what if new indexing thread sneaks in just now?  it would\n      // have to get this next delete queue?\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      // nocommit is this (active thread state count) always enough of a gap?  what if new indexing thread sneaks in just now?  it would\n      // have to get this next delete queue?\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9972d96003bc59c07a44e73de3cdd505dc08fd17","date":1464216081,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // jump over any possible in flight ops:\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      // Insert a gap in seqNo of current active thread count, in the worst case those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // jump over any possible in flight ops:\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      // nocommit is this (active thread state count) always enough of a gap?  what if new indexing thread sneaks in just now?  it would\n      // have to get this next delete queue?\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45dff8b66beddcf029a596db311fa4b626aa938e","date":1464291699,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // Insert a gap in seqNo of current active thread count, in the worst case those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // jump over any possible in flight ops:\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      // Insert a gap in seqNo of current active thread count, in the worst case those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // Insert a gap in seqNo of current active thread count, in the worst case those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.seqNo.get() + perThreadPool.getActiveThreadStateCount();\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"122251c49e5a9fa95f056ea257ae3ab452099fc7","date":1464820065,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      //System.out.println(\"DWFC: fullFLush old seqNo=\" + documentsWriter.deleteQueue.seqNo.get() + \" activeThreadCount=\" + perThreadPool.getActiveThreadStateCount());\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  void markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1);\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee67a99e7e36da49a4b68758a01d1ac09ff5472c","date":1547653069,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      perThreadPool.lockNewThreadStates(); // no new thread-states while we do a flush otherwise the seqNo accounting might be off\n      try {\n        // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n        // if we have some sequence numbers that were never assigned:\n        seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n        flushingQueue.maxSeqNo = seqNo + 1;\n        DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation + 1, seqNo + 1);\n        documentsWriter.deleteQueue = newQueue;\n\n      } finally {\n        perThreadPool.unlockNewThreadStates();\n      }\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n      // if we have some sequence numbers that were never assigned:\n      seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n      flushingQueue.maxSeqNo = seqNo+1;\n\n      DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation+1, seqNo+1);\n\n      documentsWriter.deleteQueue = newQueue;\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert fullFlush == false: \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushMarkDone == false : \"full flush collection marker is still set to true\";\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      perThreadPool.lockNewWriters(); // no new thread-states while we do a flush otherwise the seqNo accounting might be off\n      try {\n        // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n        // if we have some sequence numbers that were never assigned:\n        seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.size() + 2;\n        flushingQueue.maxSeqNo = seqNo + 1;\n        DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation + 1, seqNo + 1);\n        documentsWriter.deleteQueue = newQueue;\n      } finally {\n        perThreadPool.unlockNewWriters();\n      }\n    }\n    final List<DocumentsWriterPerThread> fullFlushBuffer = new ArrayList<>();\n    for (final DocumentsWriterPerThread next : perThreadPool.filterAndLock(dwpt -> dwpt.deleteQueue == flushingQueue)) {\n        try {\n          assert next.deleteQueue == flushingQueue\n              || next.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n              + flushingQueue\n              + \" currentqueue: \"\n              + documentsWriter.deleteQueue\n              + \" perThread queue: \"\n              + next.deleteQueue\n              + \" numDocsInRam: \" + next.getNumDocsInRAM();\n\n          if (next.getNumDocsInRAM() > 0) {\n            final DocumentsWriterPerThread flushingDWPT;\n            synchronized(this) {\n              if (next.isFlushPending() == false) {\n                setFlushPending(next);\n              }\n              flushingDWPT = checkOutForFlush(next);\n            }\n            assert flushingDWPT != null : \"DWPT must never be null here since we hold the lock and it holds documents\";\n            assert next == flushingDWPT : \"flushControl returned different DWPT\";\n            fullFlushBuffer.add(flushingDWPT);\n          } else {\n            // it's possible that we get a DWPT with 0 docs if we flush concurrently to\n            // threads getting DWPTs from the pool. In this case we simply remove it from\n            // the pool and drop it on the floor.\n            boolean checkout = perThreadPool.checkout(next);\n            assert checkout;\n          }\n        } finally {\n          next.unlock();\n        }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      updateStallState();\n      fullFlushMarkDone = true; // at this point we must have collected all DWPTs that belong to the old delete queue\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert !fullFlush : \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushBuffer.isEmpty() : \"full flush buffer should be empty: \"+ fullFlushBuffer;\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n\n      perThreadPool.lockNewThreadStates(); // no new thread-states while we do a flush otherwise the seqNo accounting might be off\n      try {\n        // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n        // if we have some sequence numbers that were never assigned:\n        seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.getActiveThreadStateCount() + 2;\n        flushingQueue.maxSeqNo = seqNo + 1;\n        DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation + 1, seqNo + 1);\n        documentsWriter.deleteQueue = newQueue;\n\n      } finally {\n        perThreadPool.unlockNewThreadStates();\n      }\n    }\n    final int limit = perThreadPool.getActiveThreadStateCount();\n    for (int i = 0; i < limit; i++) {\n      final ThreadState next = perThreadPool.getThreadState(i);\n      next.lock();\n      try {\n        if (!next.isInitialized()) {\n          continue; \n        }\n        assert next.dwpt.deleteQueue == flushingQueue\n            || next.dwpt.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n            + flushingQueue\n            + \" currentqueue: \"\n            + documentsWriter.deleteQueue\n            + \" perThread queue: \"\n            + next.dwpt.deleteQueue\n            + \" numDocsInRam: \" + next.dwpt.getNumDocsInRAM();\n        if (next.dwpt.deleteQueue != flushingQueue) {\n          // this one is already a new DWPT\n          continue;\n        }\n        addFlushableState(next);\n      } finally {\n        next.unlock();\n      }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      fullFlushBuffer.clear();\n      updateStallState();\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07024a7318c25225dc4d070cf6d047315b73aaf","date":1586885963,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#markForFullFlush().mjava","sourceNew":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert fullFlush == false: \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushMarkDone == false : \"full flush collection marker is still set to true\";\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      perThreadPool.lockNewWriters(); // no new thread-states while we do a flush otherwise the seqNo accounting might be off\n      try {\n        // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n        // if we have some sequence numbers that were never assigned:\n        DocumentsWriterDeleteQueue newQueue = documentsWriter.deleteQueue.advanceQueue(perThreadPool.size());\n        seqNo = documentsWriter.deleteQueue.getMaxSeqNo();\n        documentsWriter.resetDeleteQueue(newQueue);\n      } finally {\n        perThreadPool.unlockNewWriters();\n      }\n    }\n    final List<DocumentsWriterPerThread> fullFlushBuffer = new ArrayList<>();\n    for (final DocumentsWriterPerThread next : perThreadPool.filterAndLock(dwpt -> dwpt.deleteQueue == flushingQueue)) {\n        try {\n          assert next.deleteQueue == flushingQueue\n              || next.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n              + flushingQueue\n              + \" currentqueue: \"\n              + documentsWriter.deleteQueue\n              + \" perThread queue: \"\n              + next.deleteQueue\n              + \" numDocsInRam: \" + next.getNumDocsInRAM();\n\n          if (next.getNumDocsInRAM() > 0) {\n            final DocumentsWriterPerThread flushingDWPT;\n            synchronized(this) {\n              if (next.isFlushPending() == false) {\n                setFlushPending(next);\n              }\n              flushingDWPT = checkOutForFlush(next);\n            }\n            assert flushingDWPT != null : \"DWPT must never be null here since we hold the lock and it holds documents\";\n            assert next == flushingDWPT : \"flushControl returned different DWPT\";\n            fullFlushBuffer.add(flushingDWPT);\n          } else {\n            // it's possible that we get a DWPT with 0 docs if we flush concurrently to\n            // threads getting DWPTs from the pool. In this case we simply remove it from\n            // the pool and drop it on the floor.\n            boolean checkout = perThreadPool.checkout(next);\n            assert checkout;\n          }\n        } finally {\n          next.unlock();\n        }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      updateStallState();\n      fullFlushMarkDone = true; // at this point we must have collected all DWPTs that belong to the old delete queue\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    assert flushingQueue.getLastSequenceNumber() <= flushingQueue.getMaxSeqNo();\n    return seqNo;\n  }\n\n","sourceOld":"  long markForFullFlush() {\n    final DocumentsWriterDeleteQueue flushingQueue;\n    long seqNo;\n    synchronized (this) {\n      assert fullFlush == false: \"called DWFC#markForFullFlush() while full flush is still running\";\n      assert fullFlushMarkDone == false : \"full flush collection marker is still set to true\";\n      fullFlush = true;\n      flushingQueue = documentsWriter.deleteQueue;\n      // Set a new delete queue - all subsequent DWPT will use this queue until\n      // we do another full flush\n      perThreadPool.lockNewWriters(); // no new thread-states while we do a flush otherwise the seqNo accounting might be off\n      try {\n        // Insert a gap in seqNo of current active thread count, in the worst case each of those threads now have one operation in flight.  It's fine\n        // if we have some sequence numbers that were never assigned:\n        seqNo = documentsWriter.deleteQueue.getLastSequenceNumber() + perThreadPool.size() + 2;\n        flushingQueue.maxSeqNo = seqNo + 1;\n        DocumentsWriterDeleteQueue newQueue = new DocumentsWriterDeleteQueue(infoStream, flushingQueue.generation + 1, seqNo + 1);\n        documentsWriter.deleteQueue = newQueue;\n      } finally {\n        perThreadPool.unlockNewWriters();\n      }\n    }\n    final List<DocumentsWriterPerThread> fullFlushBuffer = new ArrayList<>();\n    for (final DocumentsWriterPerThread next : perThreadPool.filterAndLock(dwpt -> dwpt.deleteQueue == flushingQueue)) {\n        try {\n          assert next.deleteQueue == flushingQueue\n              || next.deleteQueue == documentsWriter.deleteQueue : \" flushingQueue: \"\n              + flushingQueue\n              + \" currentqueue: \"\n              + documentsWriter.deleteQueue\n              + \" perThread queue: \"\n              + next.deleteQueue\n              + \" numDocsInRam: \" + next.getNumDocsInRAM();\n\n          if (next.getNumDocsInRAM() > 0) {\n            final DocumentsWriterPerThread flushingDWPT;\n            synchronized(this) {\n              if (next.isFlushPending() == false) {\n                setFlushPending(next);\n              }\n              flushingDWPT = checkOutForFlush(next);\n            }\n            assert flushingDWPT != null : \"DWPT must never be null here since we hold the lock and it holds documents\";\n            assert next == flushingDWPT : \"flushControl returned different DWPT\";\n            fullFlushBuffer.add(flushingDWPT);\n          } else {\n            // it's possible that we get a DWPT with 0 docs if we flush concurrently to\n            // threads getting DWPTs from the pool. In this case we simply remove it from\n            // the pool and drop it on the floor.\n            boolean checkout = perThreadPool.checkout(next);\n            assert checkout;\n          }\n        } finally {\n          next.unlock();\n        }\n    }\n    synchronized (this) {\n      /* make sure we move all DWPT that are where concurrently marked as\n       * pending and moved to blocked are moved over to the flushQueue. There is\n       * a chance that this happens since we marking DWPT for full flush without\n       * blocking indexing.*/\n      pruneBlockedQueue(flushingQueue);   \n      assert assertBlockedFlushes(documentsWriter.deleteQueue);\n      flushQueue.addAll(fullFlushBuffer);\n      updateStallState();\n      fullFlushMarkDone = true; // at this point we must have collected all DWPTs that belong to the old delete queue\n    }\n    assert assertActiveDeleteQueue(documentsWriter.deleteQueue);\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7af110b00ea8df9429309d83e38e0533d82e144f":["5e38f40562eb7c165ae08ab2367a031883138354"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["5898ca35059bc3a89ba6a275ec92a5c32057aedc","6483e4260c08168709c02238ae083a51519a28dd"],"45dff8b66beddcf029a596db311fa4b626aa938e":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["0f6df47cbfd656ea50ca2996361f7954531ee18b"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"5898ca35059bc3a89ba6a275ec92a5c32057aedc":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"264935965977b4a9e2f3920420647072c9c49176":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"5e38f40562eb7c165ae08ab2367a031883138354":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["5e38f40562eb7c165ae08ab2367a031883138354","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["5e38f40562eb7c165ae08ab2367a031883138354","7af110b00ea8df9429309d83e38e0533d82e144f"],"6483e4260c08168709c02238ae083a51519a28dd":["5898ca35059bc3a89ba6a275ec92a5c32057aedc","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["45dff8b66beddcf029a596db311fa4b626aa938e"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["191128ac5b85671b1671e2c857437694283b6ebf","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["16ebfabc294f23b88b6a39722a02c9d39b353195","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"28288370235ed02234a64753cdbf0c6ec096304a":["191128ac5b85671b1671e2c857437694283b6ebf","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5898ca35059bc3a89ba6a275ec92a5c32057aedc","191128ac5b85671b1671e2c857437694283b6ebf"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["7af110b00ea8df9429309d83e38e0533d82e144f"],"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b07024a7318c25225dc4d070cf6d047315b73aaf":["264935965977b4a9e2f3920420647072c9c49176"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600","5e38f40562eb7c165ae08ab2367a031883138354"],"f492fe129985750df09c8dac738aecc503158bb3":["5898ca35059bc3a89ba6a275ec92a5c32057aedc"],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["28288370235ed02234a64753cdbf0c6ec096304a"],"0f6df47cbfd656ea50ca2996361f7954531ee18b":["f492fe129985750df09c8dac738aecc503158bb3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b07024a7318c25225dc4d070cf6d047315b73aaf"]},"commit2Childs":{"7af110b00ea8df9429309d83e38e0533d82e144f":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","c02b804ab16489b95429791a2d8fb0e0728354d4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"191128ac5b85671b1671e2c857437694283b6ebf":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"45dff8b66beddcf029a596db311fa4b626aa938e":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["45dff8b66beddcf029a596db311fa4b626aa938e"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"5898ca35059bc3a89ba6a275ec92a5c32057aedc":["191128ac5b85671b1671e2c857437694283b6ebf","6483e4260c08168709c02238ae083a51519a28dd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f492fe129985750df09c8dac738aecc503158bb3"],"264935965977b4a9e2f3920420647072c9c49176":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"5e38f40562eb7c165ae08ab2367a031883138354":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["122251c49e5a9fa95f056ea257ae3ab452099fc7","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["6483e4260c08168709c02238ae083a51519a28dd"],"28288370235ed02234a64753cdbf0c6ec096304a":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c02b804ab16489b95429791a2d8fb0e0728354d4":["5898ca35059bc3a89ba6a275ec92a5c32057aedc"],"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600":["5e38f40562eb7c165ae08ab2367a031883138354","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"b07024a7318c25225dc4d070cf6d047315b73aaf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"f492fe129985750df09c8dac738aecc503158bb3":["0f6df47cbfd656ea50ca2996361f7954531ee18b"],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["264935965977b4a9e2f3920420647072c9c49176"],"0f6df47cbfd656ea50ca2996361f7954531ee18b":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}