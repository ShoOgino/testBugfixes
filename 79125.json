{"path":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3859e567816d5987602f2a7ae2469fcdf17f745e","date":1329895924,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = ParseUtils.parsePoint(null, part1, dimension);\n      p2 = ParseUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e47768b261c28e7e6032060e8331475c81057953","date":1331681297,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = ParseUtils.parsePoint(null, part1, dimension);\n      p2 = ParseUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = DistanceUtils.parsePoint(null, part1, dimension);\n      p2 = DistanceUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = ParseUtils.parsePoint(null, part1, dimension);\n      p2 = ParseUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i, parser.getReq().getSchema());\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = ParseUtils.parsePoint(null, part1, dimension);\n      p2 = ParseUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i);\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003","date":1390592414,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery result = new BooleanQuery(true);\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    int dimension = 2;\n\n    String[] p1;\n    String[] p2;\n    try {\n      p1 = ParseUtils.parsePoint(null, part1, dimension);\n      p2 = ParseUtils.parsePoint(null, part2, dimension);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    BooleanQuery result = new BooleanQuery(true);\n    for (int i = 0; i < dimension; i++) {\n      SchemaField subSF = subField(field, i, parser.getReq().getSchema());\n      // points must currently be ordered... should we support specifying any two opposite corner points?\n      result.add(subSF.getType().getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    result.setDisableCoord(true);\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery result = new BooleanQuery(true);\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    result.setDisableCoord(true);\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    result.setDisableCoord(true);\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c81907bd971f786e378654d32b80da32b0e950d","date":1578330742,"type":5,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8381df1a98f2a399bf06d747fc8cea1b2a17ae38","date":1578526395,"type":1,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da93834e39ce341a13e42b611d0a83bd3114bba","date":1578567362,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ba457c7f2595139254fab54362be336c5c355","date":1579734055,"type":5,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    Point p1 = SpatialUtils.parsePointSolrException(part1, SpatialContext.GEO);\n    Point p2 = SpatialUtils.parsePointSolrException(part2, SpatialContext.GEO);\n\n    SchemaField latSF = subField(field, LAT, parser.getReq().getSchema());\n    SchemaField lonSF = subField(field, LON, parser.getReq().getSchema());\n    BooleanQuery.Builder result = new BooleanQuery.Builder();\n    // points must currently be ordered... should we support specifying any two opposite corner points?\n    result.add(latSF.getType().getRangeQuery(parser, latSF,\n        Double.toString(p1.getY()), Double.toString(p2.getY()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    result.add(lonSF.getType().getRangeQuery(parser, lonSF,\n        Double.toString(p1.getX()), Double.toString(p2.getX()), minInclusive, maxInclusive), BooleanClause.Occur.MUST);\n    return result.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["0c81907bd971f786e378654d32b80da32b0e950d"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1da93834e39ce341a13e42b611d0a83bd3114bba":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["c8a0e442f7b61f811680273b25da95994a724466","0c81907bd971f786e378654d32b80da32b0e950d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","c8a0e442f7b61f811680273b25da95994a724466"],"08970e5b8411182a29412c177eff67ec1110095b":["e47768b261c28e7e6032060e8331475c81057953"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"0c81907bd971f786e378654d32b80da32b0e950d":["c8a0e442f7b61f811680273b25da95994a724466"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["08970e5b8411182a29412c177eff67ec1110095b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c7ba457c7f2595139254fab54362be336c5c355":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"c8a0e442f7b61f811680273b25da95994a724466":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e47768b261c28e7e6032060e8331475c81057953":["c26f00b574427b55127e869b935845554afde1fa","3859e567816d5987602f2a7ae2469fcdf17f745e"],"3859e567816d5987602f2a7ae2469fcdf17f745e":["c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c7ba457c7f2595139254fab54362be336c5c355"]},"commit2Childs":{"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["1da93834e39ce341a13e42b611d0a83bd3114bba","5c7ba457c7f2595139254fab54362be336c5c355"],"c26f00b574427b55127e869b935845554afde1fa":["e47768b261c28e7e6032060e8331475c81057953","3859e567816d5987602f2a7ae2469fcdf17f745e"],"1da93834e39ce341a13e42b611d0a83bd3114bba":[],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["1da93834e39ce341a13e42b611d0a83bd3114bba"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"08970e5b8411182a29412c177eff67ec1110095b":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"0c81907bd971f786e378654d32b80da32b0e950d":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"5c7ba457c7f2595139254fab54362be336c5c355":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c8a0e442f7b61f811680273b25da95994a724466":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0c81907bd971f786e378654d32b80da32b0e950d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"e47768b261c28e7e6032060e8331475c81057953":["08970e5b8411182a29412c177eff67ec1110095b"],"3859e567816d5987602f2a7ae2469fcdf17f745e":["e47768b261c28e7e6032060e8331475c81057953"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1da93834e39ce341a13e42b611d0a83bd3114bba","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}