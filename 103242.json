{"path":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","commits":[{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9c5c0e8e826d8fd169840564bcf8606cf81d15b","date":1473715404,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiTerms.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e99d92de6748e3bbd2dd7b72695cdb952b2d835","date":1579100291,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n\n    Terms terms = MultiTerms.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, term, editDistance, Math.max(minPrefix, editDistance - 1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = e.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      e.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiTerms.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      // For FuzzyQuery, boost is the score:\n      float score = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && score <= stQueue.peek().boost) {\n        continue;\n      }\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm)) {\n        continue;\n      }\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq) {\n        continue;\n      }\n      \n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy) {\n        continue;\n      }\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = score;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3e99d92de6748e3bbd2dd7b72695cdb952b2d835":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","89424def13674ea17829b41c5883c54ecc31a132"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b9c5c0e8e826d8fd169840564bcf8606cf81d15b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3e99d92de6748e3bbd2dd7b72695cdb952b2d835"],"89424def13674ea17829b41c5883c54ecc31a132":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","b9c5c0e8e826d8fd169840564bcf8606cf81d15b"]},"commit2Childs":{"3e99d92de6748e3bbd2dd7b72695cdb952b2d835":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["04e775de416dd2d8067b10db1c8af975a1d5017e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["3e99d92de6748e3bbd2dd7b72695cdb952b2d835"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","b9c5c0e8e826d8fd169840564bcf8606cf81d15b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132"],"b9c5c0e8e826d8fd169840564bcf8606cf81d15b":["89424def13674ea17829b41c5883c54ecc31a132"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}