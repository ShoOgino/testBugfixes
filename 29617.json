{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],Set[String],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[Replica]).mjava","commits":[{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],Set[String],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[Replica]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],Set[String],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","sourceNew":"  private void calculateColdOps(List<TriggerEvent.Op> ops,\n                                Set<String> violations,\n                                ClusterState clusterState,\n                                Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                                Map<String, Double> coldNodes,\n                                Map<String, Double> coldCollections,\n                                Map<String, Map<String, Double>> coldShards,\n                                List<Replica> coldReplicas) {\n    // COLD COLLECTIONS\n    // Probably can't do anything reasonable about whole cold collections\n    // because they may be needed even if not used.\n\n    // COLD SHARDS & COLD REPLICAS:\n    // We remove cold replicas only from cold shards, otherwise we are susceptible to uneven\n    // replica routing (which is beyond our control).\n    // If we removed replicas from non-cold shards we could accidentally bring that shard into\n    // the hot range, which would result in adding replica, and that replica could again stay cold due to\n    // the same routing issue, which then would lead to removing that replica, etc, etc...\n\n    // Remove cold replicas but only when there's at least a minimum number of searchable\n    // replicas still available (additional non-searchable replicas may exist, too)\n    // NOTE: do this before adding ops for DELETENODE because we don't want to attempt\n    // deleting replicas that have been already moved elsewhere\n    Map<String, Map<String, List<Replica>>> byCollectionByShard = new HashMap<>();\n    coldReplicas.forEach(ri -> {\n      byCollectionByShard.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n          .computeIfAbsent(ri.getShard(), s -> new ArrayList<>())\n          .add(ri);\n    });\n    coldShards.forEach((coll, perShard) -> {\n      perShard.forEach((shard, rate) -> {\n        List<Replica> replicas = byCollectionByShard\n            .getOrDefault(coll, Collections.emptyMap())\n            .getOrDefault(shard, Collections.emptyList());\n        if (replicas.isEmpty()) {\n          return;\n        }\n        // only delete if there's at least minRF searchable replicas left\n        int rf = searchableReplicationFactors.get(coll).get(shard).get();\n        // assume first that we only really need a leader and we may be\n        // allowed to remove other replicas\n        int minRF = 1;\n        // but check the official RF and don't go below that\n        Integer RF = clusterState.getCollection(coll).getReplicationFactor();\n        if (RF != null) {\n          minRF = RF;\n        }\n        // unless minReplicas is set explicitly\n        if (minReplicas != null) {\n          minRF = minReplicas;\n        }\n        if (minRF < 1) {\n          minRF = 1;\n        }\n        if (rf > minRF) {\n          // delete at most maxOps replicas at a time\n          AtomicInteger limit = new AtomicInteger(Math.min(maxOps, rf - minRF));\n          replicas.forEach(ri -> {\n            if (limit.get() == 0) {\n              return;\n            }\n            // don't delete a leader\n            if (ri.getBool(ZkStateReader.LEADER_PROP, false)) {\n              return;\n            }\n            TriggerEvent.Op op = new TriggerEvent.Op(belowOp,\n                Suggester.Hint.COLL_SHARD, new Pair<>(ri.getCollection(), ri.getShard()));\n            op.addHint(Suggester.Hint.REPLICA, ri.getName());\n            ops.add(op);\n            violations.add(COLD_SHARDS);\n            limit.decrementAndGet();\n          });\n        }\n      });\n    });\n\n    // COLD NODES:\n    // Unlike the case of hot nodes, if a node is cold then any monitored\n    // collections / shards / replicas located on that node are cold, too.\n    // HOWEVER, we check only replicas from selected collections / shards,\n    // so deleting a cold node is dangerous because it may interfere with these\n    // non-monitored resources - this is the reason the default belowNodeOp is null / ignored.\n    //\n    // Also, note that due to the way activity is measured only nodes that contain any\n    // monitored resources are considered - there may be cold nodes in the cluster that don't\n    // belong to the monitored collections and they will be ignored.\n    if (belowNodeOp != null) {\n      coldNodes.forEach((node, rate) -> {\n        ops.add(new TriggerEvent.Op(belowNodeOp, Suggester.Hint.SRC_NODE, node));\n        violations.add(COLD_NODES);\n      });\n    }\n\n\n  }\n\n","sourceOld":"  private void calculateColdOps(List<TriggerEvent.Op> ops,\n                                Set<String> violations,\n                                ClusterState clusterState,\n                                Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                                Map<String, Double> coldNodes,\n                                Map<String, Double> coldCollections,\n                                Map<String, Map<String, Double>> coldShards,\n                                List<ReplicaInfo> coldReplicas) {\n    // COLD COLLECTIONS\n    // Probably can't do anything reasonable about whole cold collections\n    // because they may be needed even if not used.\n\n    // COLD SHARDS & COLD REPLICAS:\n    // We remove cold replicas only from cold shards, otherwise we are susceptible to uneven\n    // replica routing (which is beyond our control).\n    // If we removed replicas from non-cold shards we could accidentally bring that shard into\n    // the hot range, which would result in adding replica, and that replica could again stay cold due to\n    // the same routing issue, which then would lead to removing that replica, etc, etc...\n\n    // Remove cold replicas but only when there's at least a minimum number of searchable\n    // replicas still available (additional non-searchable replicas may exist, too)\n    // NOTE: do this before adding ops for DELETENODE because we don't want to attempt\n    // deleting replicas that have been already moved elsewhere\n    Map<String, Map<String, List<ReplicaInfo>>> byCollectionByShard = new HashMap<>();\n    coldReplicas.forEach(ri -> {\n      byCollectionByShard.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n          .computeIfAbsent(ri.getShard(), s -> new ArrayList<>())\n          .add(ri);\n    });\n    coldShards.forEach((coll, perShard) -> {\n      perShard.forEach((shard, rate) -> {\n        List<ReplicaInfo> replicas = byCollectionByShard\n            .getOrDefault(coll, Collections.emptyMap())\n            .getOrDefault(shard, Collections.emptyList());\n        if (replicas.isEmpty()) {\n          return;\n        }\n        // only delete if there's at least minRF searchable replicas left\n        int rf = searchableReplicationFactors.get(coll).get(shard).get();\n        // assume first that we only really need a leader and we may be\n        // allowed to remove other replicas\n        int minRF = 1;\n        // but check the official RF and don't go below that\n        Integer RF = clusterState.getCollection(coll).getReplicationFactor();\n        if (RF != null) {\n          minRF = RF;\n        }\n        // unless minReplicas is set explicitly\n        if (minReplicas != null) {\n          minRF = minReplicas;\n        }\n        if (minRF < 1) {\n          minRF = 1;\n        }\n        if (rf > minRF) {\n          // delete at most maxOps replicas at a time\n          AtomicInteger limit = new AtomicInteger(Math.min(maxOps, rf - minRF));\n          replicas.forEach(ri -> {\n            if (limit.get() == 0) {\n              return;\n            }\n            // don't delete a leader\n            if (ri.getBool(ZkStateReader.LEADER_PROP, false)) {\n              return;\n            }\n            TriggerEvent.Op op = new TriggerEvent.Op(belowOp,\n                Suggester.Hint.COLL_SHARD, new Pair<>(ri.getCollection(), ri.getShard()));\n            op.addHint(Suggester.Hint.REPLICA, ri.getName());\n            ops.add(op);\n            violations.add(COLD_SHARDS);\n            limit.decrementAndGet();\n          });\n        }\n      });\n    });\n\n    // COLD NODES:\n    // Unlike the case of hot nodes, if a node is cold then any monitored\n    // collections / shards / replicas located on that node are cold, too.\n    // HOWEVER, we check only replicas from selected collections / shards,\n    // so deleting a cold node is dangerous because it may interfere with these\n    // non-monitored resources - this is the reason the default belowNodeOp is null / ignored.\n    //\n    // Also, note that due to the way activity is measured only nodes that contain any\n    // monitored resources are considered - there may be cold nodes in the cluster that don't\n    // belong to the monitored collections and they will be ignored.\n    if (belowNodeOp != null) {\n      coldNodes.forEach((node, rate) -> {\n        ops.add(new TriggerEvent.Op(belowNodeOp, Suggester.Hint.SRC_NODE, node));\n        violations.add(COLD_NODES);\n      });\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],Set[String],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[Replica]).mjava","sourceNew":null,"sourceOld":"  private void calculateColdOps(List<TriggerEvent.Op> ops,\n                                Set<String> violations,\n                                ClusterState clusterState,\n                                Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                                Map<String, Double> coldNodes,\n                                Map<String, Double> coldCollections,\n                                Map<String, Map<String, Double>> coldShards,\n                                List<Replica> coldReplicas) {\n    // COLD COLLECTIONS\n    // Probably can't do anything reasonable about whole cold collections\n    // because they may be needed even if not used.\n\n    // COLD SHARDS & COLD REPLICAS:\n    // We remove cold replicas only from cold shards, otherwise we are susceptible to uneven\n    // replica routing (which is beyond our control).\n    // If we removed replicas from non-cold shards we could accidentally bring that shard into\n    // the hot range, which would result in adding replica, and that replica could again stay cold due to\n    // the same routing issue, which then would lead to removing that replica, etc, etc...\n\n    // Remove cold replicas but only when there's at least a minimum number of searchable\n    // replicas still available (additional non-searchable replicas may exist, too)\n    // NOTE: do this before adding ops for DELETENODE because we don't want to attempt\n    // deleting replicas that have been already moved elsewhere\n    Map<String, Map<String, List<Replica>>> byCollectionByShard = new HashMap<>();\n    coldReplicas.forEach(ri -> {\n      byCollectionByShard.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n          .computeIfAbsent(ri.getShard(), s -> new ArrayList<>())\n          .add(ri);\n    });\n    coldShards.forEach((coll, perShard) -> {\n      perShard.forEach((shard, rate) -> {\n        List<Replica> replicas = byCollectionByShard\n            .getOrDefault(coll, Collections.emptyMap())\n            .getOrDefault(shard, Collections.emptyList());\n        if (replicas.isEmpty()) {\n          return;\n        }\n        // only delete if there's at least minRF searchable replicas left\n        int rf = searchableReplicationFactors.get(coll).get(shard).get();\n        // assume first that we only really need a leader and we may be\n        // allowed to remove other replicas\n        int minRF = 1;\n        // but check the official RF and don't go below that\n        Integer RF = clusterState.getCollection(coll).getReplicationFactor();\n        if (RF != null) {\n          minRF = RF;\n        }\n        // unless minReplicas is set explicitly\n        if (minReplicas != null) {\n          minRF = minReplicas;\n        }\n        if (minRF < 1) {\n          minRF = 1;\n        }\n        if (rf > minRF) {\n          // delete at most maxOps replicas at a time\n          AtomicInteger limit = new AtomicInteger(Math.min(maxOps, rf - minRF));\n          replicas.forEach(ri -> {\n            if (limit.get() == 0) {\n              return;\n            }\n            // don't delete a leader\n            if (ri.getBool(ZkStateReader.LEADER_PROP, false)) {\n              return;\n            }\n            TriggerEvent.Op op = new TriggerEvent.Op(belowOp,\n                Suggester.Hint.COLL_SHARD, new Pair<>(ri.getCollection(), ri.getShard()));\n            op.addHint(Suggester.Hint.REPLICA, ri.getName());\n            ops.add(op);\n            violations.add(COLD_SHARDS);\n            limit.decrementAndGet();\n          });\n        }\n      });\n    });\n\n    // COLD NODES:\n    // Unlike the case of hot nodes, if a node is cold then any monitored\n    // collections / shards / replicas located on that node are cold, too.\n    // HOWEVER, we check only replicas from selected collections / shards,\n    // so deleting a cold node is dangerous because it may interfere with these\n    // non-monitored resources - this is the reason the default belowNodeOp is null / ignored.\n    //\n    // Also, note that due to the way activity is measured only nodes that contain any\n    // monitored resources are considered - there may be cold nodes in the cluster that don't\n    // belong to the monitored collections and they will be ignored.\n    if (belowNodeOp != null) {\n      coldNodes.forEach((node, rate) -> {\n        ops.add(new TriggerEvent.Op(belowNodeOp, Suggester.Hint.SRC_NODE, node));\n        violations.add(COLD_NODES);\n      });\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}