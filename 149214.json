{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","commits":[{"id":"c5ce7c704ca874aa623a99f2669737b52ec71cfc","date":1528728510,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> blockDocs = cmd.getLuceneDocsIfNested();\n      boolean isBlock = blockDocs != null; // AKA nested child docs\n      Term idTerm = new Term(isBlock ? IndexSchema.ROOT_FIELD_NAME : idField.getName(), cmd.getIndexedId());\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isBlock) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, blockDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> blockDocs = cmd.getLuceneDocsIfNested();\n      boolean isBlock = blockDocs != null; // AKA nested child docs\n      Term idTerm = new Term(isBlock ? IndexSchema.ROOT_FIELD_NAME : idField.getName(), cmd.getIndexedId());\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isBlock) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, blockDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> blockDocs = cmd.getLuceneDocsIfNested();\n      boolean isBlock = blockDocs != null; // AKA nested child docs\n      Term idTerm = new Term(isBlock ? IndexSchema.ROOT_FIELD_NAME : idField.getName(), cmd.getIndexedId());\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isBlock) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, blockDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa4f44656c8081bbc63325a83abdb025eafd5a2b","date":1543200469,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> nestedDocs = cmd.getLuceneDocsIfNested();\n      boolean isNested = nestedDocs != null; // AKA nested child docs\n      Term idTerm = getIdTerm(cmd.getIndexedId(), isNested);\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isNested) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, nestedDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> blockDocs = cmd.getLuceneDocsIfNested();\n      boolean isBlock = blockDocs != null; // AKA nested child docs\n      Term idTerm = new Term(isBlock ? IndexSchema.ROOT_FIELD_NAME : idField.getName(), cmd.getIndexedId());\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isBlock) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, blockDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> nestedDocs = cmd.getLuceneDocsIfNested();\n      boolean isNested = nestedDocs != null; // AKA nested child docs\n      Term idTerm = getIdTerm(isNested? new BytesRef(cmd.getRootIdUsingRouteParam()): cmd.getIndexedId(), isNested);\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isNested) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, nestedDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> nestedDocs = cmd.getLuceneDocsIfNested();\n      boolean isNested = nestedDocs != null; // AKA nested child docs\n      Term idTerm = getIdTerm(cmd.getIndexedId(), isNested);\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isNested) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, nestedDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","date":1571411704,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or <code>IndexWriter#updateDocument</code>(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> nestedDocs = cmd.getLuceneDocsIfNested();\n      boolean isNested = nestedDocs != null; // AKA nested child docs\n      Term idTerm = getIdTerm(isNested? new BytesRef(cmd.getRootIdUsingRouteParam()): cmd.getIndexedId(), isNested);\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isNested) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, nestedDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> nestedDocs = cmd.getLuceneDocsIfNested();\n      boolean isNested = nestedDocs != null; // AKA nested child docs\n      Term idTerm = getIdTerm(isNested? new BytesRef(cmd.getRootIdUsingRouteParam()): cmd.getIndexedId(), isNested);\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isNested) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, nestedDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa4f44656c8081bbc63325a83abdb025eafd5a2b":["c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["07749612bed4eb54dd05255c1434c301133310c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07749612bed4eb54dd05255c1434c301133310c1":["aa4f44656c8081bbc63325a83abdb025eafd5a2b"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5ce7c704ca874aa623a99f2669737b52ec71cfc"]},"commit2Childs":{"aa4f44656c8081bbc63325a83abdb025eafd5a2b":["07749612bed4eb54dd05255c1434c301133310c1"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c5ce7c704ca874aa623a99f2669737b52ec71cfc","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"07749612bed4eb54dd05255c1434c301133310c1":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["aa4f44656c8081bbc63325a83abdb025eafd5a2b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}