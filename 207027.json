{"path":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","commits":[{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    reset();\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    reset();\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6e408502500aa10cb479d224850a7deebf3f0e9","date":1523604873,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","sourceNew":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    dropChanges();\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    reset();\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c6453827f947004a68ad9db7418781e9df2f660","date":1523626811,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","sourceNew":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    dropChanges();\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    reset();\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d","date":1525873214,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#writeLiveDocs(Directory).mjava","sourceNew":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs(liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    dropChanges();\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Writes the live docs to disk and returns <code>true</code> if any new docs were written.\n   */\n  boolean writeLiveDocs(Directory dir) throws IOException {\n    if (pendingDeleteCount == 0) {\n      return false;\n    }\n\n    Bits liveDocs = this.liveDocs;\n    assert liveDocs != null;\n    // We have new deletes\n    assert liveDocs.length() == info.info.maxDoc();\n\n    // Do this so we can delete any created files on\n    // exception; this saves all codecs from having to do\n    // it:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    // We can write directly to the actual name (vs to a\n    // .tmp & renaming it) because the file is not live\n    // until segments file is written:\n    boolean success = false;\n    try {\n      Codec codec = info.info.getCodec();\n      codec.liveDocsFormat().writeLiveDocs((MutableBits)liveDocs, trackingDir, info, pendingDeleteCount, IOContext.DEFAULT);\n      success = true;\n    } finally {\n      if (!success) {\n        // Advance only the nextWriteDelGen so that a 2nd\n        // attempt to write will write to a new file\n        info.advanceNextWriteDelGen();\n\n        // Delete any partially created file(s):\n        for (String fileName : trackingDir.getCreatedFiles()) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, fileName);\n        }\n      }\n    }\n\n    // If we hit an exc in the line above (eg disk full)\n    // then info's delGen remains pointing to the previous\n    // (successfully written) del docs:\n    info.advanceDelGen();\n    info.setDelCount(info.getDelCount() + pendingDeleteCount);\n    dropChanges();\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f6e408502500aa10cb479d224850a7deebf3f0e9":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d":["5c6453827f947004a68ad9db7418781e9df2f660"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d"],"5c6453827f947004a68ad9db7418781e9df2f660":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","f6e408502500aa10cb479d224850a7deebf3f0e9"]},"commit2Childs":{"f6e408502500aa10cb479d224850a7deebf3f0e9":["5c6453827f947004a68ad9db7418781e9df2f660"],"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["f6e408502500aa10cb479d224850a7deebf3f0e9","5c6453827f947004a68ad9db7418781e9df2f660"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"5c6453827f947004a68ad9db7418781e9df2f660":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}