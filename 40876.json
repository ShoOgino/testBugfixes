{"path":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","commits":[{"id":"307cff5af2b00f126fdf9d3435b75d5ed4d0f402","date":1305370109,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable[]> sortedGroupFields = new ArrayList<Comparable[]>();\n\n    int totalHitCount = 0;\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c12f3f9ad631aa7d2e93e90bf877662f0df0cdc4","date":1305515875,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable[]> sortedGroupFields = new ArrayList<Comparable[]>();\n\n    int totalHitCount = 0;\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5f61d6a2927b52517a31a8bf022549d33b1dfec","date":1305652854,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n  }\n\n","bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5f61d6a2927b52517a31a8bf022549d33b1dfec":["c12f3f9ad631aa7d2e93e90bf877662f0df0cdc4"],"c12f3f9ad631aa7d2e93e90bf877662f0df0cdc4":["307cff5af2b00f126fdf9d3435b75d5ed4d0f402"],"307cff5af2b00f126fdf9d3435b75d5ed4d0f402":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c5f61d6a2927b52517a31a8bf022549d33b1dfec"]},"commit2Childs":{"c5f61d6a2927b52517a31a8bf022549d33b1dfec":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c12f3f9ad631aa7d2e93e90bf877662f0df0cdc4":["c5f61d6a2927b52517a31a8bf022549d33b1dfec"],"307cff5af2b00f126fdf9d3435b75d5ed4d0f402":["c12f3f9ad631aa7d2e93e90bf877662f0df0cdc4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["307cff5af2b00f126fdf9d3435b75d5ed4d0f402"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}