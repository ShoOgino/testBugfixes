{"path":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","commits":[{"id":"e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b","date":1406573123,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n      \n      HttpSolrServer server = new HttpSolrServer(req.node.getUrl(),\n          servers.getHttpClient());\n      try {\n        server.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      } finally {\n        server.shutdown();\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(Req req) {\n    if (req.synchronous) {\n      servers.blockUntilFinished();\n      doRetriesIfNeeded();\n      \n      HttpSolrServer server = new HttpSolrServer(req.node.getUrl(),\n          servers.getHttpClient());\n      try {\n        server.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      } finally {\n        server.shutdown();\n      }\n      \n      return;\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    try {\n      SolrServer solrServer = servers.getSolrServer(req);\n      solrServer.request(req.uReq);\n    } catch (Exception e) {\n      SolrException.log(log, e);\n      Error error = new Error();\n      error.e = e;\n      error.req = req;\n      if (e instanceof SolrException) {\n        error.statusCode = ((SolrException) e).code();\n      }\n      errors.add(error);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n      \n      HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient());\n      try {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      } finally {\n        client.shutdown();\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n      \n      HttpSolrServer server = new HttpSolrServer(req.node.getUrl(),\n          servers.getHttpClient());\n      try {\n        server.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      } finally {\n        server.shutdown();\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n      \n      HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient());\n      try {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      } finally {\n        client.shutdown();\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmdString + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(new Callable<Object>() {\n        \n        @Override\n        public Object call() throws Exception {\n          doRequest(req);\n          return null;\n        }\n\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient(req.node.getUrl(), clients.getHttpClient())) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d60283faa58f2df8b2f669b4452d4a0d7ffd25c6","date":1518278934,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        try {\n          // if false, then the node is probably not \"live\" anymore\n          // and we do not need to send a recovery message\n          Throwable rootCause = SolrException.getRootCause(e);\n          log.error(\"Setting up to try to start recovery on replica {}\", req.node.getUrl(), rootCause);\n          req.cmd.getReq().getCore().getCoreContainer().getZkController().ensureReplicaInLeaderInitiatedRecovery(\n              req.cmd.getReq().getCore().getCoreContainer(),\n              req.node.getCollection(),\n              req.node.getShardId(),\n              req.node.getNodeProps(),\n              req.cmd.getReq().getCore().getCoreDescriptor(),\n              false /* forcePublishState */\n          );\n        } catch (Exception exc) {\n          Throwable setLirZnodeFailedCause = SolrException.getRootCause(exc);\n          log.error(\"Leader failed to set replica \" +\n              req.node.getUrl() + \" state to DOWN due to: \" + setLirZnodeFailedCause, setLirZnodeFailedCause);\n        }\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":["e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfcdec9fcf0409223f35c5ec3bc14094314941b4","date":1518533599,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        try {\n          // if false, then the node is probably not \"live\" anymore\n          // and we do not need to send a recovery message\n          Throwable rootCause = SolrException.getRootCause(e);\n          log.error(\"Setting up to try to start recovery on replica {}\", req.node.getUrl(), rootCause);\n          req.cmd.getReq().getCore().getCoreContainer().getZkController().ensureReplicaInLeaderInitiatedRecovery(\n              req.cmd.getReq().getCore().getCoreContainer(),\n              req.node.getCollection(),\n              req.node.getShardId(),\n              req.node.getNodeProps(),\n              req.cmd.getReq().getCore().getCoreDescriptor(),\n              false /* forcePublishState */\n          );\n        } catch (Exception exc) {\n          Throwable setLirZnodeFailedCause = SolrException.getRootCause(exc);\n          log.error(\"Leader failed to set replica \" +\n              req.node.getUrl() + \" state to DOWN due to: \" + setLirZnodeFailedCause, setLirZnodeFailedCause);\n        }\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed synchronous update on shard \" + req.node + \" update: \" + req.uReq , e);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b82b38f6df64b40b9ae76575b234a8ddd4238cd4","date":1519975758,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        try {\n          // if false, then the node is probably not \"live\" anymore\n          // and we do not need to send a recovery message\n          Throwable rootCause = SolrException.getRootCause(e);\n          log.error(\"Setting up to try to start recovery on replica {}\", req.node.getUrl(), rootCause);\n          req.cmd.getReq().getCore().getCoreContainer().getZkController().ensureReplicaInLeaderInitiatedRecovery(\n              req.cmd.getReq().getCore().getCoreContainer(),\n              req.node.getCollection(),\n              req.node.getShardId(),\n              req.node.getNodeProps(),\n              req.cmd.getReq().getCore().getCoreDescriptor(),\n              false /* forcePublishState */\n          );\n        } catch (Exception exc) {\n          Throwable setLirZnodeFailedCause = SolrException.getRootCause(exc);\n          log.error(\"Leader failed to set replica \" +\n              req.node.getUrl() + \" state to DOWN due to: \" + setLirZnodeFailedCause, setLirZnodeFailedCause);\n        }\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4bb519c79b76e52145e37b6681a7012525ed5f4b","date":1544694716,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {\n        client.request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbaf96cfda5422c42955ce34344f0e01839894ea","date":1559675051,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) throws IOException {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":["e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) throws IOException {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#submit(Req,boolean).mjava","sourceNew":"  private void submit(final Req req, boolean isCommit) throws IOException {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to {} retry: {} {} params {}\"\n          , req.node.getUrl(), req.retries, req.cmd, req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","sourceOld":"  private void submit(final Req req, boolean isCommit) throws IOException {\n    // Copy user principal from the original request to the new update request, for later authentication interceptor use\n    if (SolrRequestInfo.getRequestInfo() != null) {\n      req.uReq.setUserPrincipal(SolrRequestInfo.getRequestInfo().getReq().getUserPrincipal());\n    }\n\n    Tracer tracer = GlobalTracer.getTracer();\n    Span parentSpan = tracer.activeSpan();\n    if (parentSpan != null) {\n      tracer.inject(parentSpan.context(), Format.Builtin.HTTP_HEADERS,\n          new SolrRequestCarrier(req.uReq));\n    }\n\n    if (req.synchronous) {\n      blockAndDoRetries();\n\n      try {\n        req.uReq.setBasePath(req.node.getUrl());\n        clients.getHttpClient().request(req.uReq);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n        Error error = new Error();\n        error.e = e;\n        error.req = req;\n        if (e instanceof SolrException) {\n          error.statusCode = ((SolrException) e).code();\n        }\n        errors.add(error);\n      }\n      \n      return;\n    }\n    \n    if (log.isDebugEnabled()) {\n      log.debug(\"sending update to \"\n          + req.node.getUrl() + \" retry:\"\n          + req.retries + \" \" + req.cmd + \" params:\" + req.uReq.getParams());\n    }\n    \n    if (isCommit) {\n      // a commit using ConncurrentUpdateSolrServer is not async,\n      // so we make it async to prevent commits from happening\n      // serially across multiple nodes\n      pending.add(completionService.submit(() -> {\n        doRequest(req);\n        return null;\n      }));\n    } else {\n      doRequest(req);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4bb519c79b76e52145e37b6681a7012525ed5f4b":["b82b38f6df64b40b9ae76575b234a8ddd4238cd4"],"043df2e9a841864922c32756a44c939ed768cb89":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"d60283faa58f2df8b2f669b4452d4a0d7ffd25c6":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["b6284684320a9808c41a5e43de958b2da22f89bd"],"e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"575e66bd4b2349209027f6801184da7fc3cba13f":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"bafca15d8e408346a67f4282ad1143b88023893b":["e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","d60283faa58f2df8b2f669b4452d4a0d7ffd25c6"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["4bb519c79b76e52145e37b6681a7012525ed5f4b"],"a229cb50768e988c50a2106bdae3a92154f428bf":["cbaf96cfda5422c42955ce34344f0e01839894ea","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"b6284684320a9808c41a5e43de958b2da22f89bd":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","043df2e9a841864922c32756a44c939ed768cb89"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["b6284684320a9808c41a5e43de958b2da22f89bd","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"b82b38f6df64b40b9ae76575b234a8ddd4238cd4":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"4bb519c79b76e52145e37b6681a7012525ed5f4b":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["575e66bd4b2349209027f6801184da7fc3cba13f","a229cb50768e988c50a2106bdae3a92154f428bf"],"d60283faa58f2df8b2f669b4452d4a0d7ffd25c6":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b":["bafca15d8e408346a67f4282ad1143b88023893b"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["b82b38f6df64b40b9ae76575b234a8ddd4238cd4"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"b6284684320a9808c41a5e43de958b2da22f89bd":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["482ca6c86d7073e3c19096bdc74fe0e73da4554a","a229cb50768e988c50a2106bdae3a92154f428bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e483b96a4c951399b8188cbf6a2e8c0d6b95ba6b"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["d60283faa58f2df8b2f669b4452d4a0d7ffd25c6","bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"b82b38f6df64b40b9ae76575b234a8ddd4238cd4":["4bb519c79b76e52145e37b6681a7012525ed5f4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}