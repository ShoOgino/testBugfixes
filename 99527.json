{"path":"solr/core/src/java/org/apache/solr/handler/SnapShooter#getAndSaveIndexCommit().mjava","commits":[{"id":"19f02bb04467ed179738a398a7da80bbbe161c16","date":1573660732,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapShooter#getAndSaveIndexCommit().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * If {@link #commitName} is non-null, then fetches the generation from the \n   * {@link SolrSnapshotMetaDataManager} and then returns \n   * {@link IndexDeletionPolicyWrapper#getAndSaveCommitPoint}, otherwise it returns \n   * {@link IndexDeletionPolicyWrapper#getAndSaveLatestCommit}.\n   * <p>\n   * Either way:\n   * <ul>\n   *  <li>This method does error handling for all cases where the commit can't be found \n   *       and wraps them in {@link SolrException}\n   *  </li>\n   *  <li>If this method returns, the result will be non null, and the caller <em>MUST</em> \n   *      call {@link IndexDeletionPolicyWrapper#releaseCommitPoint} when finished\n   *  </li>\n   * </ul>\n   */\n  private IndexCommit getAndSaveIndexCommit() throws IOException {\n    final IndexDeletionPolicyWrapper delPolicy = solrCore.getDeletionPolicy();\n    if (null != commitName) {\n      final SolrSnapshotMetaDataManager snapshotMgr = solrCore.getSnapshotMetaDataManager();\n      // We're going to tell the delPolicy to \"save\" this commit -- even though it's a named snapshot\n      // that will already be protected -- just in case another thread deletes the name.\n      // Because of this, we want to sync on the delPolicy to ensure there is no window of time after\n      // snapshotMgr confirms commitName exists, but before we have a chance to 'save' it, when\n      // the commitName might be deleted *and* the IndexWriter might call onCommit()\n      synchronized (delPolicy) { \n        final Optional<IndexCommit> namedCommit = snapshotMgr.getIndexCommitByName(commitName);\n        if (namedCommit.isPresent()) {\n          final IndexCommit commit = namedCommit.get();\n          log.debug(\"Using named commit: name={}, generation={}\", commitName, commit.getGeneration());\n          delPolicy.saveCommitPoint(commit.getGeneration());\n          return commit;\n        }\n      } // else...\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to find an index commit with name \" +\n                                commitName + \" for core \" + solrCore.getName());\n    }\n    // else: not a named commit...\n    final IndexCommit commit = delPolicy.getAndSaveLatestCommit();\n    if (null == commit) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Index does not yet have any commits for core \" +\n                              solrCore.getName());\n    }\n    log.debug(\"Using latest commit: generation={}\", commit.getGeneration());\n    return commit;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapShooter#getAndSaveIndexCommit().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapShooter#getAndSaveIndexCommit().mjava","sourceNew":"  /**\n   * If {@link #commitName} is non-null, then fetches the generation from the \n   * {@link SolrSnapshotMetaDataManager} and then returns \n   * {@link IndexDeletionPolicyWrapper#getAndSaveCommitPoint}, otherwise it returns \n   * {@link IndexDeletionPolicyWrapper#getAndSaveLatestCommit}.\n   * <p>\n   * Either way:\n   * <ul>\n   *  <li>This method does error handling for all cases where the commit can't be found \n   *       and wraps them in {@link SolrException}\n   *  </li>\n   *  <li>If this method returns, the result will be non null, and the caller <em>MUST</em> \n   *      call {@link IndexDeletionPolicyWrapper#releaseCommitPoint} when finished\n   *  </li>\n   * </ul>\n   */\n  private IndexCommit getAndSaveIndexCommit() throws IOException {\n    final IndexDeletionPolicyWrapper delPolicy = solrCore.getDeletionPolicy();\n    if (null != commitName) {\n      final SolrSnapshotMetaDataManager snapshotMgr = solrCore.getSnapshotMetaDataManager();\n      // We're going to tell the delPolicy to \"save\" this commit -- even though it's a named snapshot\n      // that will already be protected -- just in case another thread deletes the name.\n      // Because of this, we want to sync on the delPolicy to ensure there is no window of time after\n      // snapshotMgr confirms commitName exists, but before we have a chance to 'save' it, when\n      // the commitName might be deleted *and* the IndexWriter might call onCommit()\n      synchronized (delPolicy) { \n        final Optional<IndexCommit> namedCommit = snapshotMgr.getIndexCommitByName(commitName);\n        if (namedCommit.isPresent()) {\n          final IndexCommit commit = namedCommit.get();\n          if (log.isDebugEnabled()) {\n            log.debug(\"Using named commit: name={}, generation={}\", commitName, commit.getGeneration());\n          }\n          delPolicy.saveCommitPoint(commit.getGeneration());\n          return commit;\n        }\n      } // else...\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to find an index commit with name \" +\n                                commitName + \" for core \" + solrCore.getName());\n    }\n    // else: not a named commit...\n    final IndexCommit commit = delPolicy.getAndSaveLatestCommit();\n    if (null == commit) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Index does not yet have any commits for core \" +\n                              solrCore.getName());\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Using latest commit: generation={}\", commit.getGeneration());\n    }\n    return commit;\n  }\n\n","sourceOld":"  /**\n   * If {@link #commitName} is non-null, then fetches the generation from the \n   * {@link SolrSnapshotMetaDataManager} and then returns \n   * {@link IndexDeletionPolicyWrapper#getAndSaveCommitPoint}, otherwise it returns \n   * {@link IndexDeletionPolicyWrapper#getAndSaveLatestCommit}.\n   * <p>\n   * Either way:\n   * <ul>\n   *  <li>This method does error handling for all cases where the commit can't be found \n   *       and wraps them in {@link SolrException}\n   *  </li>\n   *  <li>If this method returns, the result will be non null, and the caller <em>MUST</em> \n   *      call {@link IndexDeletionPolicyWrapper#releaseCommitPoint} when finished\n   *  </li>\n   * </ul>\n   */\n  private IndexCommit getAndSaveIndexCommit() throws IOException {\n    final IndexDeletionPolicyWrapper delPolicy = solrCore.getDeletionPolicy();\n    if (null != commitName) {\n      final SolrSnapshotMetaDataManager snapshotMgr = solrCore.getSnapshotMetaDataManager();\n      // We're going to tell the delPolicy to \"save\" this commit -- even though it's a named snapshot\n      // that will already be protected -- just in case another thread deletes the name.\n      // Because of this, we want to sync on the delPolicy to ensure there is no window of time after\n      // snapshotMgr confirms commitName exists, but before we have a chance to 'save' it, when\n      // the commitName might be deleted *and* the IndexWriter might call onCommit()\n      synchronized (delPolicy) { \n        final Optional<IndexCommit> namedCommit = snapshotMgr.getIndexCommitByName(commitName);\n        if (namedCommit.isPresent()) {\n          final IndexCommit commit = namedCommit.get();\n          log.debug(\"Using named commit: name={}, generation={}\", commitName, commit.getGeneration());\n          delPolicy.saveCommitPoint(commit.getGeneration());\n          return commit;\n        }\n      } // else...\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to find an index commit with name \" +\n                                commitName + \" for core \" + solrCore.getName());\n    }\n    // else: not a named commit...\n    final IndexCommit commit = delPolicy.getAndSaveLatestCommit();\n    if (null == commit) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Index does not yet have any commits for core \" +\n                              solrCore.getName());\n    }\n    log.debug(\"Using latest commit: generation={}\", commit.getGeneration());\n    return commit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"19f02bb04467ed179738a398a7da80bbbe161c16":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["19f02bb04467ed179738a398a7da80bbbe161c16"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"]},"commit2Childs":{"19f02bb04467ed179738a398a7da80bbbe161c16":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["19f02bb04467ed179738a398a7da80bbbe161c16"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}