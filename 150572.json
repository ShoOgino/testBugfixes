{"path":"lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonScorer#countMatches().mjava","commits":[{"id":"06a4493f0c732d2928d1a4f773f15d19434aa8ba","date":1405856163,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonScorer#countMatches().mjava","pathOld":"/dev/null","sourceNew":"  private void countMatches() throws IOException {\n    freq = 0;\n    for(int i=0;i<numSubsOnDoc;i++) {\n      posQueue.add(subsOnDoc[i]);\n    }\n    // System.out.println(\"\\ncountMatches: \" + numSubsOnDoc + \" terms in doc=\" + docID + \" anyTermID=\" + anyTermID + \" id=\" + reader.document(docID).get(\"id\"));\n    // System.out.println(\"\\ncountMatches: \" + numSubsOnDoc + \" terms in doc=\" + docID + \" anyTermID=\" + anyTermID);\n\n    int lastPos = -1;\n\n    posShift = -1;\n\n    while (posQueue.size() != 0) {\n      EnumAndScorer sub = posQueue.pop();\n\n      // This is a graph intersection, and pos is the state this token\n      // leaves from.  Until index stores posLength (which we could\n      // stuff into a payload using a simple TokenFilter), this token\n      // always transitions from state=pos to state=pos+1:\n      final int pos = sub.pos;\n\n      if (posShift == -1) {\n        posShift = pos;\n      }\n\n      if (pos+1-posShift >= positions.length) {\n        PosState[] newPositions = new PosState[ArrayUtil.oversize(pos+1-posShift, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n        System.arraycopy(positions, 0, newPositions, 0, positions.length);\n        for(int i=positions.length;i<newPositions.length;i++) {\n          newPositions[i] = new PosState();\n        }\n        positions = newPositions;\n      }\n\n      // System.out.println(\"  term=\" + idToTerm.get(sub.termID).utf8ToString() + \" pos=\" + pos + \" (count=\" + getPosition(pos).count + \" lastPos=\" + lastPos + \") posQueue.size=\" + posQueue.size() + \" posShift=\" + posShift);\n\n      PosState posState;\n      PosState nextPosState;\n\n      // Maybe advance ANY matches:\n      if (lastPos != -1) {\n        if (anyTermID != -1) {\n          int startLastPos = lastPos;\n          while (lastPos < pos) {\n            posState = getPosition(lastPos);\n            if (posState.count == 0 && lastPos > startLastPos) {\n              // Petered out...\n              lastPos = pos;\n              break;\n            }\n            // System.out.println(\"  iter lastPos=\" + lastPos + \" count=\" + posState.count);\n\n            nextPosState = getPosition(lastPos+1);\n\n            // Advance all states from lastPos -> pos, if they had an any arc:\n            for(int i=0;i<posState.count;i++) {\n              int state = runAutomaton.step(posState.states[i], anyTermID);\n              if (state != -1) {\n                // System.out.println(\"    add pos=\" + (lastPos+1) + \" state=\" + state);\n                nextPosState.add(state);\n              }\n            }\n\n            lastPos++;\n          }\n        }\n      }\n\n      posState = getPosition(pos);\n      nextPosState = getPosition(pos+1);\n\n      // If there are no pending matches at neither this position or the\n      // next position, then it's safe to shift back to positions[0]:\n      if (posState.count == 0 && nextPosState.count == 0) {\n        shift(pos);\n        posState = getPosition(pos);\n        nextPosState = getPosition(pos+1);\n      }\n\n      // Match current token:\n      for(int i=0;i<posState.count;i++) {\n        // System.out.println(\"    check cur state=\" + posState.states[i]);\n        int state = runAutomaton.step(posState.states[i], sub.termID);\n        if (state != -1) {\n          // System.out.println(\"      --> \" + state);\n          nextPosState.add(state);\n          if (runAutomaton.isAccept(state)) {\n            // System.out.println(\"      *** (1)\");\n            freq++;\n          }\n        }\n      }\n\n      // Also consider starting a new match from this position:\n      int state = runAutomaton.step(0, sub.termID);\n      if (state != -1) {\n        // System.out.println(\"  add init state=\" + state);\n        nextPosState.add(state);\n        if (runAutomaton.isAccept(state)) {\n          // System.out.println(\"      *** (2)\");\n          freq++;\n        }\n      }\n\n      if (sub.posLeft > 0) {\n        // Put this sub back into the posQueue:\n        sub.pos = sub.posEnum.nextPosition();\n        sub.posLeft--;\n        posQueue.add(sub);\n      }\n\n      lastPos = pos;\n    }\n\n    int limit = lastPos+1-posShift;\n    // reset\n    for(int i=0;i<=limit;i++) {\n      positions[i].count = 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a4493f0c732d2928d1a4f773f15d19434aa8ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a4493f0c732d2928d1a4f773f15d19434aa8ba"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06a4493f0c732d2928d1a4f773f15d19434aa8ba"],"06a4493f0c732d2928d1a4f773f15d19434aa8ba":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}