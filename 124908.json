{"path":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","commits":[{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    while (iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Term term = (Term) entry.getKey();\n\n      TermDocs docs = reader.termDocs(term);\n      if (docs != null) {\n        int limit = ((DocumentsWriter.Num) entry.getValue()).getNum();\n        try {\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        } finally {\n          docs.close();\n        }\n      }\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(scorer.next()) {\n        final int docID = scorer.doc();\n        if (docIDStart + docID >= limit)\n          break;\n        reader.deleteDocument(docID);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    while (iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Term term = (Term) entry.getKey();\n\n      TermDocs docs = reader.termDocs(term);\n      if (docs != null) {\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        try {\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        } finally {\n          docs.close();\n        }\n      }\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(scorer.next()) {\n        final int docID = scorer.doc();\n        if (docIDStart + docID >= limit)\n          break;\n        reader.deleteDocument(docID);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    while (iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Term term = (Term) entry.getKey();\n\n      TermDocs docs = reader.termDocs(term);\n      if (docs != null) {\n        int limit = ((DocumentsWriter.Num) entry.getValue()).getNum();\n        try {\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        } finally {\n          docs.close();\n        }\n      }\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(scorer.next()) {\n        final int docID = scorer.doc();\n        if (docIDStart + docID >= limit)\n          break;\n        reader.deleteDocument(docID);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c059e076171565333fbe1e2e788a879401c01638","date":1238610318,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(scorer.next()) {\n        final int docID = scorer.doc();\n        if (docIDStart + docID >= limit)\n          break;\n        reader.deleteDocument(docID);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    while (iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Term term = (Term) entry.getKey();\n\n      TermDocs docs = reader.termDocs(term);\n      if (docs != null) {\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        try {\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        } finally {\n          docs.close();\n        }\n      }\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(scorer.next()) {\n        final int docID = scorer.doc();\n        if (docIDStart + docID >= limit)\n          break;\n        reader.deleteDocument(docID);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(true)  {\n        int doc = scorer.nextDoc();\n        if (((long) docIDStart) + doc >= limit)\n          break;\n        reader.deleteDocument(doc);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(scorer.next()) {\n        final int docID = scorer.doc();\n        if (docIDStart + docID >= limit)\n          break;\n        reader.deleteDocument(docID);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      QueryWeight weight = query.queryWeight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      while(true)  {\n        int doc = scorer.nextDoc();\n        if (((long) docIDStart) + doc >= limit)\n          break;\n        reader.deleteDocument(doc);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader);\n      while(true)  {\n        int doc = scorer.nextDoc();\n        if (((long) docIDStart) + doc >= limit)\n          break;\n        reader.deleteDocument(doc);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d6c98c690b593cea727f68742684c979ead1a0a","date":1248688202,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      QueryWeight weight = query.queryWeight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      QueryWeight weight = query.queryWeight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      while(true)  {\n        int doc = scorer.nextDoc();\n        if (((long) docIDStart) + doc >= limit)\n          break;\n        reader.deleteDocument(doc);\n        any = true;\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe941135bdfc28c81e20b4d21422f8726af34925","date":1250040150,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      QueryWeight weight = query.queryWeight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc","date":1255773182,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    Iterator iter = deletesFlushed.terms.entrySet().iterator();\n    TermDocs docs = reader.termDocs();\n    try {\n      while (iter.hasNext()) {\n        Entry entry = (Entry) iter.next();\n        Term term = (Term) entry.getKey();\n\n        docs.seek(term);\n        int limit = ((BufferedDeletes.Num) entry.getValue()).getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    iter = deletesFlushed.docIDs.iterator();\n    while(iter.hasNext()) {\n      int docID = ((Integer) iter.next()).intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    iter = deletesFlushed.queries.entrySet().iterator();\n    while(iter.hasNext()) {\n      Entry entry = (Entry) iter.next();\n      Query query = (Query) entry.getKey();\n      int limit = ((Integer) entry.getValue()).intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a08a1e02b87db52ce330fbc9d8ff26b65bd52be5","date":1258742262,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51cbb637a6a31831662ea126685d8f9d4cfa3c84","date":1259068665,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    assert checkDeleteTerm(null);\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n        // LUCENE-2086: we should be iterating a TreeMap,\n        // here, so terms better be in order:\n        assert checkDeleteTerm(term);\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"289ce46591c91edc14a0a068d1990324daf047a5","date":1266859706,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    assert checkDeleteTerm(null);\n\n    // Delete by term\n    if (deletesFlushed.terms.size() > 0) {\n      TermDocs docs = reader.termDocs();\n      try {\n        for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n          Term term = entry.getKey();\n          // LUCENE-2086: we should be iterating a TreeMap,\n          // here, so terms better be in order:\n          assert checkDeleteTerm(term);\n          docs.seek(term);\n          int limit = entry.getValue().getNum();\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        }\n      } finally {\n        docs.close();\n      }\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    if (deletesFlushed.queries.size() > 0) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      try {\n        for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n          Query query = entry.getKey();\n          int limit = entry.getValue().intValue();\n          Weight weight = query.weight(searcher);\n          Scorer scorer = weight.scorer(reader, true, false);\n          if (scorer != null) {\n            while(true)  {\n              int doc = scorer.nextDoc();\n              if (((long) docIDStart) + doc >= limit)\n                break;\n              reader.deleteDocument(doc);\n              any = true;\n            }\n          }\n        }\n      } finally {\n        searcher.close();\n      }\n    }\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    assert checkDeleteTerm(null);\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n        // LUCENE-2086: we should be iterating a TreeMap,\n        // here, so terms better be in order:\n        assert checkDeleteTerm(term);\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    assert checkDeleteTerm(null);\n\n    // Delete by term\n    if (deletesFlushed.terms.size() > 0) {\n      TermDocs docs = reader.termDocs();\n      try {\n        for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n          Term term = entry.getKey();\n          // LUCENE-2086: we should be iterating a TreeMap,\n          // here, so terms better be in order:\n          assert checkDeleteTerm(term);\n          docs.seek(term);\n          int limit = entry.getValue().getNum();\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        }\n      } finally {\n        docs.close();\n      }\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    if (deletesFlushed.queries.size() > 0) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      try {\n        for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n          Query query = entry.getKey();\n          int limit = entry.getValue().intValue();\n          Weight weight = query.weight(searcher);\n          Scorer scorer = weight.scorer(reader, true, false);\n          if (scorer != null) {\n            while(true)  {\n              int doc = scorer.nextDoc();\n              if (((long) docIDStart) + doc >= limit)\n                break;\n              reader.deleteDocument(doc);\n              any = true;\n            }\n          }\n        }\n      } finally {\n        searcher.close();\n      }\n    }\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    assert checkDeleteTerm(null);\n\n    // Delete by term\n    if (deletesFlushed.terms.size() > 0) {\n      TermDocs docs = reader.termDocs();\n      try {\n        for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n          Term term = entry.getKey();\n          // LUCENE-2086: we should be iterating a TreeMap,\n          // here, so terms better be in order:\n          assert checkDeleteTerm(term);\n          docs.seek(term);\n          int limit = entry.getValue().getNum();\n          while (docs.next()) {\n            int docID = docs.doc();\n            if (docIDStart+docID >= limit)\n              break;\n            reader.deleteDocument(docID);\n            any = true;\n          }\n        }\n      } finally {\n        docs.close();\n      }\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    if (deletesFlushed.queries.size() > 0) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      try {\n        for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n          Query query = entry.getKey();\n          int limit = entry.getValue().intValue();\n          Weight weight = query.weight(searcher);\n          Scorer scorer = weight.scorer(reader, true, false);\n          if (scorer != null) {\n            while(true)  {\n              int doc = scorer.nextDoc();\n              if (((long) docIDStart) + doc >= limit)\n                break;\n              reader.deleteDocument(doc);\n              any = true;\n            }\n          }\n        }\n      } finally {\n        searcher.close();\n      }\n    }\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"51cbb637a6a31831662ea126685d8f9d4cfa3c84":["a08a1e02b87db52ce330fbc9d8ff26b65bd52be5"],"a08a1e02b87db52ce330fbc9d8ff26b65bd52be5":["b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc"],"b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc":["fe941135bdfc28c81e20b4d21422f8726af34925"],"fe941135bdfc28c81e20b4d21422f8726af34925":["8d6c98c690b593cea727f68742684c979ead1a0a"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c059e076171565333fbe1e2e788a879401c01638":["5a0af3a442be522899177e5e11384a45a6784a3f"],"30a558487f2298c2c19ceca9103c1b6865d64708":["c059e076171565333fbe1e2e788a879401c01638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8d6c98c690b593cea727f68742684c979ead1a0a":["052fac7830290bd38a04cddee1a121ee07656b56"],"5a0af3a442be522899177e5e11384a45a6784a3f":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"289ce46591c91edc14a0a068d1990324daf047a5":["51cbb637a6a31831662ea126685d8f9d4cfa3c84"],"052fac7830290bd38a04cddee1a121ee07656b56":["30a558487f2298c2c19ceca9103c1b6865d64708"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["289ce46591c91edc14a0a068d1990324daf047a5"]},"commit2Childs":{"51cbb637a6a31831662ea126685d8f9d4cfa3c84":["289ce46591c91edc14a0a068d1990324daf047a5"],"a08a1e02b87db52ce330fbc9d8ff26b65bd52be5":["51cbb637a6a31831662ea126685d8f9d4cfa3c84"],"b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc":["a08a1e02b87db52ce330fbc9d8ff26b65bd52be5"],"fe941135bdfc28c81e20b4d21422f8726af34925":["b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["5a0af3a442be522899177e5e11384a45a6784a3f"],"c059e076171565333fbe1e2e788a879401c01638":["30a558487f2298c2c19ceca9103c1b6865d64708"],"30a558487f2298c2c19ceca9103c1b6865d64708":["052fac7830290bd38a04cddee1a121ee07656b56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"8d6c98c690b593cea727f68742684c979ead1a0a":["fe941135bdfc28c81e20b4d21422f8726af34925"],"5a0af3a442be522899177e5e11384a45a6784a3f":["c059e076171565333fbe1e2e788a879401c01638"],"052fac7830290bd38a04cddee1a121ee07656b56":["8d6c98c690b593cea727f68742684c979ead1a0a"],"289ce46591c91edc14a0a068d1990324daf047a5":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}