{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","commits":[{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer).mjava","sourceNew":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","sourceOld":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","sourceNew":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long startTimeNS = System.nanoTime();\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestStressNRTReplication.message(line, startTimeNS);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","sourceOld":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","sourceNew":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long startTimeNS = System.nanoTime();\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestStressNRTReplication.message(line, startTimeNS);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","sourceOld":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","pathOld":"/dev/null","sourceNew":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long startTimeNS = System.nanoTime();\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestStressNRTReplication.message(line, startTimeNS);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","13ea66b549e25413e4e3057bf3492ab828899110"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","13ea66b549e25413e4e3057bf3492ab828899110"],"13ea66b549e25413e4e3057bf3492ab828899110":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"]},"commit2Childs":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1b0febf62c2d9baeee7db38998d9197700ccbab9","13ea66b549e25413e4e3057bf3492ab828899110"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9","68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1b0febf62c2d9baeee7db38998d9197700ccbab9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}