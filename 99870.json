{"path":"solr/core/src/test/org/apache/solr/cloud/ConcurrentCreateRoutedAliasTest#testConcurrentCreateRoutedAliasMinimal().mjava","commits":[{"id":"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691","date":1516909549,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentCreateRoutedAliasTest#testConcurrentCreateRoutedAliasMinimal().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testConcurrentCreateRoutedAliasMinimal() throws IOException, KeeperException.NoNodeException {\n    // this is the test where be blow out a bunch of create commands all out at once.\n    // other tests are more functionality based, and just use a single thread.\n\n    // Failure of this test very occasionally due to overseer overload would not be worrisome (just bothersome).\n    // Any use case creating large numbers of time routed aliases concurrently would be an EXTREMELY odd\n    // if not fundamentally broken use case. This test method is just here to guard against any race\n    // conditions in the code that could crop up rarely in lower volume usage.\n\n    // That said any failures involving about NPE's or missing parameters or oddities other than overwhelming\n    // the overseer queue with retry races emanating from this test should be investigated. Also if it fails\n    // frequently that needs to be investigated of course.\n\n\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n\n    // Note: this number of threads seems to work regularly with the up-tweaked number of retries (50) in\n    // org.apache.solr.common.cloud.ZkStateReader.AliasesManager.applyModificationAndExportToZk()\n    // with the original 5 retries this wouldn't reliably pass with 10 threads, but with 50 retries it seems\n    // to handle 50 threads about a dozen times without any failure (on a 32 thread processor)\n    // it also passed 3/3 at 150 threads and 2/3 with 250 threads on both 1 node and 4 nodes...\n    // the failure mode seems to be overseer tasks that are not found. I suspect this happens when enough\n    // threads get into retry races and the spam overwhelms the overseer. (that this can happen might imply\n    // an issue over there, but I'm not sure, since there is an intentional hard limit on the overseer queue\n    // and I haven't tried to count the retries up and figure out if the requests are actually exceeding that\n    // limit or not, but the speed of retries might indicate an effectively hot loop, but again, a separate issue.\n\n    // The hope is that the level of concurrency supported by create routed alias and the code it uses is such\n    // that this test wouldn't spuriously fail more than once a year. If that's true users should never see\n    // an issue in the wild unless they are doing something we probably don't want to support anyway\n\n    final CreateRoutedAliasThread[] threads = new CreateRoutedAliasThread[50];\n    int numStart = num;\n    for (; num < threads.length + numStart; num++) {\n      final String aliasName = \"testAlias\" + num;\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n\n\n      int i = num - numStart;\n      threads[i] = new CreateRoutedAliasThread(\"create-delete-search-\" + i, aliasName, \"NOW/HOUR\",\n          solrClient, failure, false);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent alias creation failed \" + failure.get(), failure.get());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a52f96952b632d1c00d42827d71067185198ca4","date":1517504813,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentCreateRoutedAliasTest#testConcurrentCreateRoutedAliasMinimal().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentCreateRoutedAliasTest#testConcurrentCreateRoutedAliasMinimal().mjava","sourceNew":"  @Test\n  public void testConcurrentCreateRoutedAliasMinimal() throws IOException, KeeperException.NoNodeException {\n    // this is the test where be blow out a bunch of create commands all out at once.\n    // other tests are more functionality based, and just use a single thread.\n\n    // Failure of this test very occasionally due to overseer overload would not be worrisome (just bothersome).\n    // Any use case creating large numbers of time routed aliases concurrently would be an EXTREMELY odd\n    // if not fundamentally broken use case. This test method is just here to guard against any race\n    // conditions in the code that could crop up rarely in lower volume usage.\n\n    // That said any failures involving about NPE's or missing parameters or oddities other than overwhelming\n    // the overseer queue with retry races emanating from this test should be investigated. Also if it fails\n    // frequently that needs to be investigated of course.\n\n\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n\n    // Note: this number of threads seems to work regularly with the up-tweaked number of retries (50) in\n    // org.apache.solr.common.cloud.ZkStateReader.AliasesManager.applyModificationAndExportToZk()\n    // with the original 5 retries this wouldn't reliably pass with 10 threads, but with 50 retries it seems\n    // to handle 50 threads about a dozen times without any failure (on a 32 thread processor)\n    // it also passed 3/3 at 150 threads and 2/3 with 250 threads on both 1 node and 4 nodes...\n    // the failure mode seems to be overseer tasks that are not found. I suspect this happens when enough\n    // threads get into retry races and the spam overwhelms the overseer. (that this can happen might imply\n    // an issue over there, but I'm not sure, since there is an intentional hard limit on the overseer queue\n    // and I haven't tried to count the retries up and figure out if the requests are actually exceeding that\n    // limit or not, but the speed of retries might indicate an effectively hot loop, but again, a separate issue.\n\n    // The hope is that the level of concurrency supported by create routed alias and the code it uses is such\n    // that this test wouldn't spuriously fail more than once a year. If that's true users should never see\n    // an issue in the wild unless they are doing something we probably don't want to support anyway\n\n    final CreateRoutedAliasThread[] threads = new CreateRoutedAliasThread[4];\n    int numStart = num;\n    for (; num < threads.length + numStart; num++) {\n      final String aliasName = \"testAlias\" + num;\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n\n\n      int i = num - numStart;\n      threads[i] = new CreateRoutedAliasThread(\"create-delete-search-\" + i, aliasName, \"NOW/HOUR\",\n          solrClient, failure, false);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent alias creation failed \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  @Test\n  public void testConcurrentCreateRoutedAliasMinimal() throws IOException, KeeperException.NoNodeException {\n    // this is the test where be blow out a bunch of create commands all out at once.\n    // other tests are more functionality based, and just use a single thread.\n\n    // Failure of this test very occasionally due to overseer overload would not be worrisome (just bothersome).\n    // Any use case creating large numbers of time routed aliases concurrently would be an EXTREMELY odd\n    // if not fundamentally broken use case. This test method is just here to guard against any race\n    // conditions in the code that could crop up rarely in lower volume usage.\n\n    // That said any failures involving about NPE's or missing parameters or oddities other than overwhelming\n    // the overseer queue with retry races emanating from this test should be investigated. Also if it fails\n    // frequently that needs to be investigated of course.\n\n\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n\n    // Note: this number of threads seems to work regularly with the up-tweaked number of retries (50) in\n    // org.apache.solr.common.cloud.ZkStateReader.AliasesManager.applyModificationAndExportToZk()\n    // with the original 5 retries this wouldn't reliably pass with 10 threads, but with 50 retries it seems\n    // to handle 50 threads about a dozen times without any failure (on a 32 thread processor)\n    // it also passed 3/3 at 150 threads and 2/3 with 250 threads on both 1 node and 4 nodes...\n    // the failure mode seems to be overseer tasks that are not found. I suspect this happens when enough\n    // threads get into retry races and the spam overwhelms the overseer. (that this can happen might imply\n    // an issue over there, but I'm not sure, since there is an intentional hard limit on the overseer queue\n    // and I haven't tried to count the retries up and figure out if the requests are actually exceeding that\n    // limit or not, but the speed of retries might indicate an effectively hot loop, but again, a separate issue.\n\n    // The hope is that the level of concurrency supported by create routed alias and the code it uses is such\n    // that this test wouldn't spuriously fail more than once a year. If that's true users should never see\n    // an issue in the wild unless they are doing something we probably don't want to support anyway\n\n    final CreateRoutedAliasThread[] threads = new CreateRoutedAliasThread[50];\n    int numStart = num;\n    for (; num < threads.length + numStart; num++) {\n      final String aliasName = \"testAlias\" + num;\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n\n\n      int i = num - numStart;\n      threads[i] = new CreateRoutedAliasThread(\"create-delete-search-\" + i, aliasName, \"NOW/HOUR\",\n          solrClient, failure, false);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent alias creation failed \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6a52f96952b632d1c00d42827d71067185198ca4":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691"],"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6a52f96952b632d1c00d42827d71067185198ca4"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691"],"6a52f96952b632d1c00d42827d71067185198ca4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691":["6a52f96952b632d1c00d42827d71067185198ca4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}