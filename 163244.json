{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","commits":[{"id":"a78b813d9350cc28625598f6dbbb49b586a40618","date":1412073147,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @param segmentSuffix The expected auxiliary segment suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         or <code>segmentSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID, String segmentSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    int suffixLength = in.readByte() & 0xFF;\n    byte suffixBytes[] = new byte[suffixLength];\n    in.readBytes(suffixBytes, 0, suffixBytes.length);\n    String suffix = new String(suffixBytes, 0, suffixBytes.length, StandardCharsets.UTF_8);\n    if (!suffix.equals(segmentSuffix)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment suffix=\" + segmentSuffix\n                                                                     + \", got=\" + suffix, in);\n    }\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @param segmentSuffix The expected auxiliary segment suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         or <code>segmentSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID, String segmentSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    int suffixLength = in.readByte() & 0xFF;\n    byte suffixBytes[] = new byte[suffixLength];\n    in.readBytes(suffixBytes, 0, suffixBytes.length);\n    String suffix = new String(suffixBytes, 0, suffixBytes.length, StandardCharsets.UTF_8);\n    if (!suffix.equals(segmentSuffix)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment suffix=\" + segmentSuffix\n                                                                     + \", got=\" + suffix, in);\n    }\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkIndexHeader(DataInput,String,int,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeIndexHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and object ID and suffix.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param expectedID The expected object identifier for this file.\n   * @param expectedSuffix The expected auxiliary suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>expectedID</code> and <code>expectedSuffix</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>expectedID</code>\n   *         or <code>expectedSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeIndexHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    checkIndexHeaderID(in, expectedID);\n    checkIndexHeaderSuffix(in, expectedSuffix);\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @param segmentSuffix The expected auxiliary segment suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         or <code>segmentSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID, String segmentSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    int suffixLength = in.readByte() & 0xFF;\n    byte suffixBytes[] = new byte[suffixLength];\n    in.readBytes(suffixBytes, 0, suffixBytes.length);\n    String suffix = new String(suffixBytes, 0, suffixBytes.length, StandardCharsets.UTF_8);\n    if (!suffix.equals(segmentSuffix)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment suffix=\" + segmentSuffix\n                                                                     + \", got=\" + suffix, in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkIndexHeader(DataInput,String,int,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeIndexHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and object ID and suffix.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param expectedID The expected object identifier for this file.\n   * @param expectedSuffix The expected auxiliary suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>expectedID</code> and <code>expectedSuffix</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>expectedID</code>\n   *         or <code>expectedSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeIndexHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkIndexHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] expectedID, String expectedSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    checkIndexHeaderID(in, expectedID);\n    checkIndexHeaderSuffix(in, expectedSuffix);\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @param segmentSuffix The expected auxiliary segment suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         or <code>segmentSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID, String segmentSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    int suffixLength = in.readByte() & 0xFF;\n    byte suffixBytes[] = new byte[suffixLength];\n    in.readBytes(suffixBytes, 0, suffixBytes.length);\n    String suffix = new String(suffixBytes, 0, suffixBytes.length, StandardCharsets.UTF_8);\n    if (!suffix.equals(segmentSuffix)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment suffix=\" + segmentSuffix\n                                                                     + \", got=\" + suffix, in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a78b813d9350cc28625598f6dbbb49b586a40618":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9bb9a29a5e71a90295f175df8919802993142c9a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a78b813d9350cc28625598f6dbbb49b586a40618"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3384e6013a93e4d11b7d75388693f8d0388602bf":["a78b813d9350cc28625598f6dbbb49b586a40618"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["9bb9a29a5e71a90295f175df8919802993142c9a","3384e6013a93e4d11b7d75388693f8d0388602bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"]},"commit2Childs":{"a78b813d9350cc28625598f6dbbb49b586a40618":["9bb9a29a5e71a90295f175df8919802993142c9a","3384e6013a93e4d11b7d75388693f8d0388602bf"],"9bb9a29a5e71a90295f175df8919802993142c9a":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a78b813d9350cc28625598f6dbbb49b586a40618","9bb9a29a5e71a90295f175df8919802993142c9a"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}