{"path":"solr/core/src/java/org/apache/solr/cluster/placement/impl/PlacementPluginConfigImpl#getPlacementPlugin(SolrCloudManager).mjava","commits":[{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/impl/PlacementPluginConfigImpl#getPlacementPlugin(SolrCloudManager).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>This is where the plugin configuration is being read (from wherever in Solr it lives, and this will likely change with time),\n   * a {@link org.apache.solr.cluster.placement.PlacementPluginFactory} (as configured) instantiated and a plugin instance\n   * created from this factory.</p>\n   *\n   * <p>The initial implementation you see here is crude! the configuration is read anew each time and the factory class\n   * as well as the plugin class instantiated each time.\n   * This has to be changed once the code is accepted overall, to register a listener that is notified when the configuration\n   * changes (see {@link org.apache.solr.common.cloud.ZkStateReader#registerClusterPropertiesListener})\n   * and that will either create a new instance of the plugin with new configuration using the existing factory (if the factory\n   * class has not changed - we need to keep track of this one) of create a new factory altogether (then a new plugin instance).</p>\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public static PlacementPlugin getPlacementPlugin(SolrCloudManager solrCloudManager) {\n    Map<String, Object> props = solrCloudManager.getClusterStateProvider().getClusterProperties();\n    Map<String, Object> pluginConfigMap = (Map<String, Object>) props.get(PLACEMENT_PLUGIN_CONFIG_KEY);\n\n    if (pluginConfigMap == null) {\n      return null;\n    }\n\n    String pluginFactoryClassName = (String) pluginConfigMap.get(CONFIG_CLASS);\n\n    // Get the configured plugin factory class. Is there a way to load a resource in Solr without being in the context of\n    // CoreContainer? Here the placement code is unrelated to the presence of cores (and one can imagine it running on\n    // specialized nodes not having a CoreContainer). I guess the loading code below is not totally satisfying (although\n    // it's not the only place in Solr doing it that way), but I didn't find more satisfying alternatives. Open to suggestions.\n    PlacementPluginFactory placementPluginFactory;\n    try {\n      Class<? extends PlacementPluginFactory> factoryClazz =\n              Class.forName(pluginFactoryClassName, true, PlacementPluginConfigImpl.class.getClassLoader())\n                      .asSubclass(PlacementPluginFactory.class);\n\n      placementPluginFactory = factoryClazz.getConstructor().newInstance(); // no args constructor - that's why we introduced a factory...\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unable to instantiate placement-plugin factory: \" +\n              Utils.toJSONString(pluginConfigMap) + \" please review /clusterprops.json config for \" + PLACEMENT_PLUGIN_CONFIG_KEY, e);\n    }\n\n    // Translate the config from the properties where they are defined into the abstraction seen by the plugin\n    PlacementPluginConfig pluginConfig = createConfigFromProperties(pluginConfigMap);\n\n    return placementPluginFactory.createPluginInstance(pluginConfig);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":0,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/impl/PlacementPluginConfigImpl#getPlacementPlugin(SolrCloudManager).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>This is where the plugin configuration is being read (from wherever in Solr it lives, and this will likely change with time),\n   * a {@link org.apache.solr.cluster.placement.PlacementPluginFactory} (as configured) instantiated and a plugin instance\n   * created from this factory.</p>\n   *\n   * <p>The initial implementation you see here is crude! the configuration is read anew each time and the factory class\n   * as well as the plugin class instantiated each time.\n   * This has to be changed once the code is accepted overall, to register a listener that is notified when the configuration\n   * changes (see {@link org.apache.solr.common.cloud.ZkStateReader#registerClusterPropertiesListener})\n   * and that will either create a new instance of the plugin with new configuration using the existing factory (if the factory\n   * class has not changed - we need to keep track of this one) of create a new factory altogether (then a new plugin instance).</p>\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public static PlacementPlugin getPlacementPlugin(SolrCloudManager solrCloudManager) {\n    Map<String, Object> props = solrCloudManager.getClusterStateProvider().getClusterProperties();\n    Map<String, Object> pluginConfigMap = (Map<String, Object>) props.get(PLACEMENT_PLUGIN_CONFIG_KEY);\n\n    if (pluginConfigMap == null) {\n      return null;\n    }\n\n    String pluginFactoryClassName = (String) pluginConfigMap.get(CONFIG_CLASS);\n\n    // Get the configured plugin factory class. Is there a way to load a resource in Solr without being in the context of\n    // CoreContainer? Here the placement code is unrelated to the presence of cores (and one can imagine it running on\n    // specialized nodes not having a CoreContainer). I guess the loading code below is not totally satisfying (although\n    // it's not the only place in Solr doing it that way), but I didn't find more satisfying alternatives. Open to suggestions.\n    PlacementPluginFactory placementPluginFactory;\n    try {\n      Class<? extends PlacementPluginFactory> factoryClazz =\n              Class.forName(pluginFactoryClassName, true, PlacementPluginConfigImpl.class.getClassLoader())\n                      .asSubclass(PlacementPluginFactory.class);\n\n      placementPluginFactory = factoryClazz.getConstructor().newInstance(); // no args constructor - that's why we introduced a factory...\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unable to instantiate placement-plugin factory: \" +\n              Utils.toJSONString(pluginConfigMap) + \" please review /clusterprops.json config for \" + PLACEMENT_PLUGIN_CONFIG_KEY, e);\n    }\n\n    // Translate the config from the properties where they are defined into the abstraction seen by the plugin\n    PlacementPluginConfig pluginConfig = createConfigFromProperties(pluginConfigMap);\n\n    return placementPluginFactory.createPluginInstance(pluginConfig);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65352f844eb9e9a677ec4eb2abced4404f08181d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}