{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","commits":[{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a5f1ef908c2725f453ffce58878db70cc0947a44"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5f1ef908c2725f453ffce58878db70cc0947a44","date":1397658288,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":null,"sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":null,"sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["403b6d8b3e6cec80048e9cfc481bbffdd57517bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"403b6d8b3e6cec80048e9cfc481bbffdd57517bb","date":1410598299,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["9279b175e5e66258442d2123a50f052219a9cc1b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"471d806b28fa8f148222eb0c300dcab1047a391d","date":1413210204,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["e6c86133b70c1a2f86eca01da72b4357774d2b5c","275019a81d0883a1db4560391b072d1fbe272ec4","4c2f5223cebd58879933670af3e599b10d7e8f1a"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"403b6d8b3e6cec80048e9cfc481bbffdd57517bb":["9279b175e5e66258442d2123a50f052219a9cc1b"],"55980207f1977bd1463465de1659b821347e2fa8":["403b6d8b3e6cec80048e9cfc481bbffdd57517bb","471d806b28fa8f148222eb0c300dcab1047a391d"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"a5f1ef908c2725f453ffce58878db70cc0947a44":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a5f1ef908c2725f453ffce58878db70cc0947a44"],"bafca15d8e408346a67f4282ad1143b88023893b":["471d806b28fa8f148222eb0c300dcab1047a391d"],"471d806b28fa8f148222eb0c300dcab1047a391d":["403b6d8b3e6cec80048e9cfc481bbffdd57517bb"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"]},"commit2Childs":{"403b6d8b3e6cec80048e9cfc481bbffdd57517bb":["55980207f1977bd1463465de1659b821347e2fa8","471d806b28fa8f148222eb0c300dcab1047a391d"],"55980207f1977bd1463465de1659b821347e2fa8":[],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"a5f1ef908c2725f453ffce58878db70cc0947a44":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"471d806b28fa8f148222eb0c300dcab1047a391d":["55980207f1977bd1463465de1659b821347e2fa8","bafca15d8e408346a67f4282ad1143b88023893b"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5f1ef908c2725f453ffce58878db70cc0947a44"],"9279b175e5e66258442d2123a50f052219a9cc1b":["403b6d8b3e6cec80048e9cfc481bbffdd57517bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}