{"path":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","commits":[{"id":"66ab3886c1d845c59c9e5b23b2fb247b927db498","date":1193060587,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        FieldType ft = req.getSchema().getFieldType(field);\r\n        if (!(ft instanceof TextField)) {\r\n          String internal = ft.toInternal(queryText);\r\n          return new TermQuery(new Term(field, internal));\r\n        }\r\n\r\n        int phraseSlop = 0;\r\n        Analyzer analyzer = req.getSchema().getQueryAnalyzer();\r\n\r\n        // most of the following code is taken from the Lucene QueryParser\r\n\r\n        // Use the analyzer to get all the tokens, and then build a TermQuery,\r\n        // PhraseQuery, or nothing based on the term count\r\n\r\n        TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\r\n        ArrayList<Token> lst = new ArrayList<Token>();\r\n        Token t;\r\n        int positionCount = 0;\r\n        boolean severalTokensAtSamePosition = false;\r\n\r\n        while (true) {\r\n          try {\r\n            t = source.next();\r\n          }\r\n          catch (IOException e) {\r\n            t = null;\r\n          }\r\n          if (t == null)\r\n            break;\r\n          lst.add(t);\r\n          if (t.getPositionIncrement() != 0)\r\n            positionCount += t.getPositionIncrement();\r\n          else\r\n            severalTokensAtSamePosition = true;\r\n        }\r\n        try {\r\n          source.close();\r\n        }\r\n        catch (IOException e) {\r\n          // ignore\r\n        }\r\n\r\n        if (lst.size() == 0)\r\n          return null;\r\n        else if (lst.size() == 1) {\r\n          t = lst.get(0);\r\n          return new TermQuery(new Term(field, t.termText()));\r\n        } else {\r\n          if (severalTokensAtSamePosition) {\r\n            if (positionCount == 1) {\r\n              // no phrase query:\r\n              BooleanQuery q = new BooleanQuery(true);\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                TermQuery currentQuery = new TermQuery(\r\n                        new Term(field, t.termText()));\r\n                q.add(currentQuery, BooleanClause.Occur.SHOULD);\r\n              }\r\n              return q;\r\n            }\r\n            else {\r\n              // phrase query:\r\n              MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n              mpq.setSlop(phraseSlop);\r\n              ArrayList multiTerms = new ArrayList();\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\r\n                  mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n                  multiTerms.clear();\r\n                }\r\n                multiTerms.add(new Term(field, t.termText()));\r\n              }\r\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n              return mpq;\r\n            }\r\n          }\r\n          else {\r\n            PhraseQuery q = new PhraseQuery();\r\n            q.setSlop(phraseSlop);\r\n            for (int i = 0; i < lst.size(); i++) {\r\n              q.add(new Term(field, lst.get(i).termText()));\r\n            }\r\n            return q;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":["be29e0e2cef1fd569147732e48caf8538790339b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c90f01e1c0f11ee52212ab38c6d4393b3be8a646","date":1223059437,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        FieldType ft = req.getSchema().getFieldType(field);\r\n        if (!(ft instanceof TextField)) {\r\n          String internal = ft.toInternal(queryText);\r\n          return new TermQuery(new Term(field, internal));\r\n        }\r\n\r\n        int phraseSlop = 0;\r\n        Analyzer analyzer = req.getSchema().getQueryAnalyzer();\r\n\r\n        // most of the following code is taken from the Lucene QueryParser\r\n\r\n        // Use the analyzer to get all the tokens, and then build a TermQuery,\r\n        // PhraseQuery, or nothing based on the term count\r\n\r\n        TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\r\n        ArrayList<Token> lst = new ArrayList<Token>();\r\n        Token t;\r\n        int positionCount = 0;\r\n        boolean severalTokensAtSamePosition = false;\r\n\r\n        while (true) {\r\n          try {\r\n            t = source.next();\r\n          }\r\n          catch (IOException e) {\r\n            t = null;\r\n          }\r\n          if (t == null)\r\n            break;\r\n          lst.add(t);\r\n          if (t.getPositionIncrement() != 0)\r\n            positionCount += t.getPositionIncrement();\r\n          else\r\n            severalTokensAtSamePosition = true;\r\n        }\r\n        try {\r\n          source.close();\r\n        }\r\n        catch (IOException e) {\r\n          // ignore\r\n        }\r\n\r\n        if (lst.size() == 0)\r\n          return null;\r\n        else if (lst.size() == 1) {\r\n          t = lst.get(0);\r\n          return new TermQuery(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n        } else {\r\n          if (severalTokensAtSamePosition) {\r\n            if (positionCount == 1) {\r\n              // no phrase query:\r\n              BooleanQuery q = new BooleanQuery(true);\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                TermQuery currentQuery = new TermQuery(\r\n                        new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n                q.add(currentQuery, BooleanClause.Occur.SHOULD);\r\n              }\r\n              return q;\r\n            }\r\n            else {\r\n              // phrase query:\r\n              MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n              mpq.setSlop(phraseSlop);\r\n              ArrayList multiTerms = new ArrayList();\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\r\n                  mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n                  multiTerms.clear();\r\n                }\r\n                multiTerms.add(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n              }\r\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n              return mpq;\r\n            }\r\n          }\r\n          else {\r\n            PhraseQuery q = new PhraseQuery();\r\n            q.setSlop(phraseSlop);\r\n            for (int i = 0; i < lst.size(); i++) {\r\n              Token token = lst.get(i);\r\n              q.add(new Term(field, new String(token.termBuffer(), 0, token.termLength())));\r\n            }\r\n            return q;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\n","sourceOld":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        FieldType ft = req.getSchema().getFieldType(field);\r\n        if (!(ft instanceof TextField)) {\r\n          String internal = ft.toInternal(queryText);\r\n          return new TermQuery(new Term(field, internal));\r\n        }\r\n\r\n        int phraseSlop = 0;\r\n        Analyzer analyzer = req.getSchema().getQueryAnalyzer();\r\n\r\n        // most of the following code is taken from the Lucene QueryParser\r\n\r\n        // Use the analyzer to get all the tokens, and then build a TermQuery,\r\n        // PhraseQuery, or nothing based on the term count\r\n\r\n        TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\r\n        ArrayList<Token> lst = new ArrayList<Token>();\r\n        Token t;\r\n        int positionCount = 0;\r\n        boolean severalTokensAtSamePosition = false;\r\n\r\n        while (true) {\r\n          try {\r\n            t = source.next();\r\n          }\r\n          catch (IOException e) {\r\n            t = null;\r\n          }\r\n          if (t == null)\r\n            break;\r\n          lst.add(t);\r\n          if (t.getPositionIncrement() != 0)\r\n            positionCount += t.getPositionIncrement();\r\n          else\r\n            severalTokensAtSamePosition = true;\r\n        }\r\n        try {\r\n          source.close();\r\n        }\r\n        catch (IOException e) {\r\n          // ignore\r\n        }\r\n\r\n        if (lst.size() == 0)\r\n          return null;\r\n        else if (lst.size() == 1) {\r\n          t = lst.get(0);\r\n          return new TermQuery(new Term(field, t.termText()));\r\n        } else {\r\n          if (severalTokensAtSamePosition) {\r\n            if (positionCount == 1) {\r\n              // no phrase query:\r\n              BooleanQuery q = new BooleanQuery(true);\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                TermQuery currentQuery = new TermQuery(\r\n                        new Term(field, t.termText()));\r\n                q.add(currentQuery, BooleanClause.Occur.SHOULD);\r\n              }\r\n              return q;\r\n            }\r\n            else {\r\n              // phrase query:\r\n              MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n              mpq.setSlop(phraseSlop);\r\n              ArrayList multiTerms = new ArrayList();\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\r\n                  mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n                  multiTerms.clear();\r\n                }\r\n                multiTerms.add(new Term(field, t.termText()));\r\n              }\r\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n              return mpq;\r\n            }\r\n          }\r\n          else {\r\n            PhraseQuery q = new PhraseQuery();\r\n            q.setSlop(phraseSlop);\r\n            for (int i = 0; i < lst.size(); i++) {\r\n              q.add(new Term(field, lst.get(i).termText()));\r\n            }\r\n            return q;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be29e0e2cef1fd569147732e48caf8538790339b","date":1250443738,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        FieldType ft = req.getSchema().getFieldType(field);\r\n        if (!(ft instanceof TextField)) {\r\n          String internal = ft.toInternal(queryText);\r\n          return new TermQuery(new Term(field, internal));\r\n        }\r\n\r\n        int phraseSlop = 0;\r\n        Analyzer analyzer = req.getSchema().getQueryAnalyzer();\r\n\r\n        // most of the following code is taken from the Lucene QueryParser\r\n\r\n        // Use the analyzer to get all the tokens, and then build a TermQuery,\r\n        // PhraseQuery, or nothing based on the term count\r\n\r\n        TokenStream source = null;\r\n        try {\r\n          source = analyzer.reusableTokenStream(field, new StringReader(queryText));\r\n          source.reset();\r\n        } catch (IOException e) {\r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);  \r\n        }\r\n        ArrayList<Token> lst = new ArrayList<Token>();\r\n        Token t;\r\n        int positionCount = 0;\r\n        boolean severalTokensAtSamePosition = false;\r\n\r\n        while (true) {\r\n          try {\r\n            t = source.next();\r\n          }\r\n          catch (IOException e) {\r\n            t = null;\r\n          }\r\n          if (t == null)\r\n            break;\r\n          lst.add(t);\r\n          if (t.getPositionIncrement() != 0)\r\n            positionCount += t.getPositionIncrement();\r\n          else\r\n            severalTokensAtSamePosition = true;\r\n        }\r\n        try {\r\n          source.close();\r\n        }\r\n        catch (IOException e) {\r\n          // ignore\r\n        }\r\n\r\n        if (lst.size() == 0)\r\n          return null;\r\n        else if (lst.size() == 1) {\r\n          t = lst.get(0);\r\n          return new TermQuery(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n        } else {\r\n          if (severalTokensAtSamePosition) {\r\n            if (positionCount == 1) {\r\n              // no phrase query:\r\n              BooleanQuery q = new BooleanQuery(true);\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                TermQuery currentQuery = new TermQuery(\r\n                        new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n                q.add(currentQuery, BooleanClause.Occur.SHOULD);\r\n              }\r\n              return q;\r\n            }\r\n            else {\r\n              // phrase query:\r\n              MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n              mpq.setSlop(phraseSlop);\r\n              ArrayList multiTerms = new ArrayList();\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\r\n                  mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n                  multiTerms.clear();\r\n                }\r\n                multiTerms.add(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n              }\r\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n              return mpq;\r\n            }\r\n          }\r\n          else {\r\n            PhraseQuery q = new PhraseQuery();\r\n            q.setSlop(phraseSlop);\r\n            for (int i = 0; i < lst.size(); i++) {\r\n              Token token = lst.get(i);\r\n              q.add(new Term(field, new String(token.termBuffer(), 0, token.termLength())));\r\n            }\r\n            return q;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\n","sourceOld":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        FieldType ft = req.getSchema().getFieldType(field);\r\n        if (!(ft instanceof TextField)) {\r\n          String internal = ft.toInternal(queryText);\r\n          return new TermQuery(new Term(field, internal));\r\n        }\r\n\r\n        int phraseSlop = 0;\r\n        Analyzer analyzer = req.getSchema().getQueryAnalyzer();\r\n\r\n        // most of the following code is taken from the Lucene QueryParser\r\n\r\n        // Use the analyzer to get all the tokens, and then build a TermQuery,\r\n        // PhraseQuery, or nothing based on the term count\r\n\r\n        TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\r\n        ArrayList<Token> lst = new ArrayList<Token>();\r\n        Token t;\r\n        int positionCount = 0;\r\n        boolean severalTokensAtSamePosition = false;\r\n\r\n        while (true) {\r\n          try {\r\n            t = source.next();\r\n          }\r\n          catch (IOException e) {\r\n            t = null;\r\n          }\r\n          if (t == null)\r\n            break;\r\n          lst.add(t);\r\n          if (t.getPositionIncrement() != 0)\r\n            positionCount += t.getPositionIncrement();\r\n          else\r\n            severalTokensAtSamePosition = true;\r\n        }\r\n        try {\r\n          source.close();\r\n        }\r\n        catch (IOException e) {\r\n          // ignore\r\n        }\r\n\r\n        if (lst.size() == 0)\r\n          return null;\r\n        else if (lst.size() == 1) {\r\n          t = lst.get(0);\r\n          return new TermQuery(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n        } else {\r\n          if (severalTokensAtSamePosition) {\r\n            if (positionCount == 1) {\r\n              // no phrase query:\r\n              BooleanQuery q = new BooleanQuery(true);\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                TermQuery currentQuery = new TermQuery(\r\n                        new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n                q.add(currentQuery, BooleanClause.Occur.SHOULD);\r\n              }\r\n              return q;\r\n            }\r\n            else {\r\n              // phrase query:\r\n              MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n              mpq.setSlop(phraseSlop);\r\n              ArrayList multiTerms = new ArrayList();\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\r\n                  mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n                  multiTerms.clear();\r\n                }\r\n                multiTerms.add(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n              }\r\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n              return mpq;\r\n            }\r\n          }\r\n          else {\r\n            PhraseQuery q = new PhraseQuery();\r\n            q.setSlop(phraseSlop);\r\n            for (int i = 0; i < lst.size(); i++) {\r\n              Token token = lst.get(i);\r\n              q.add(new Term(field, new String(token.termBuffer(), 0, token.termLength())));\r\n            }\r\n            return q;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\n","bugFix":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abec2fd822be07fc74ef5ba3609b9c5625a87d6d","date":1261659802,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        SchemaField sf = req.getSchema().getField(field);\r\n        FieldType ft = sf.getType();\r\n        return ft.getFieldQuery(this, sf, queryText);\r\n      }\r\n    };\r\n  }\r\n\n","sourceOld":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        FieldType ft = req.getSchema().getFieldType(field);\r\n        if (!(ft instanceof TextField)) {\r\n          String internal = ft.toInternal(queryText);\r\n          return new TermQuery(new Term(field, internal));\r\n        }\r\n\r\n        int phraseSlop = 0;\r\n        Analyzer analyzer = req.getSchema().getQueryAnalyzer();\r\n\r\n        // most of the following code is taken from the Lucene QueryParser\r\n\r\n        // Use the analyzer to get all the tokens, and then build a TermQuery,\r\n        // PhraseQuery, or nothing based on the term count\r\n\r\n        TokenStream source = null;\r\n        try {\r\n          source = analyzer.reusableTokenStream(field, new StringReader(queryText));\r\n          source.reset();\r\n        } catch (IOException e) {\r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);  \r\n        }\r\n        ArrayList<Token> lst = new ArrayList<Token>();\r\n        Token t;\r\n        int positionCount = 0;\r\n        boolean severalTokensAtSamePosition = false;\r\n\r\n        while (true) {\r\n          try {\r\n            t = source.next();\r\n          }\r\n          catch (IOException e) {\r\n            t = null;\r\n          }\r\n          if (t == null)\r\n            break;\r\n          lst.add(t);\r\n          if (t.getPositionIncrement() != 0)\r\n            positionCount += t.getPositionIncrement();\r\n          else\r\n            severalTokensAtSamePosition = true;\r\n        }\r\n        try {\r\n          source.close();\r\n        }\r\n        catch (IOException e) {\r\n          // ignore\r\n        }\r\n\r\n        if (lst.size() == 0)\r\n          return null;\r\n        else if (lst.size() == 1) {\r\n          t = lst.get(0);\r\n          return new TermQuery(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n        } else {\r\n          if (severalTokensAtSamePosition) {\r\n            if (positionCount == 1) {\r\n              // no phrase query:\r\n              BooleanQuery q = new BooleanQuery(true);\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                TermQuery currentQuery = new TermQuery(\r\n                        new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n                q.add(currentQuery, BooleanClause.Occur.SHOULD);\r\n              }\r\n              return q;\r\n            }\r\n            else {\r\n              // phrase query:\r\n              MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n              mpq.setSlop(phraseSlop);\r\n              ArrayList multiTerms = new ArrayList();\r\n              for (int i = 0; i < lst.size(); i++) {\r\n                t = (org.apache.lucene.analysis.Token) lst.get(i);\r\n                if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\r\n                  mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n                  multiTerms.clear();\r\n                }\r\n                multiTerms.add(new Term(field, new String(t.termBuffer(), 0, t.termLength())));\r\n              }\r\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\r\n              return mpq;\r\n            }\r\n          }\r\n          else {\r\n            PhraseQuery q = new PhraseQuery();\r\n            q.setSlop(phraseSlop);\r\n            for (int i = 0; i < lst.size(); i++) {\r\n              Token token = lst.get(i);\r\n              q.add(new Term(field, new String(token.termBuffer(), 0, token.termLength())));\r\n            }\r\n            return q;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"src/java/org/apache/solr/search/FieldQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        SchemaField sf = req.getSchema().getField(field);\r\n        FieldType ft = sf.getType();\r\n        return ft.getFieldQuery(this, sf, queryText);\r\n      }\r\n    };\r\n  }\r\n\n","sourceOld":"  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\r\n    return new QParser(qstr, localParams, params, req) {\r\n      public Query parse() throws ParseException {\r\n        String field = localParams.get(QueryParsing.F);\r\n        String queryText = localParams.get(QueryParsing.V);\r\n        SchemaField sf = req.getSchema().getField(field);\r\n        FieldType ft = sf.getType();\r\n        return ft.getFieldQuery(this, sf, queryText);\r\n      }\r\n    };\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["be29e0e2cef1fd569147732e48caf8538790339b"],"c90f01e1c0f11ee52212ab38c6d4393b3be8a646":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"be29e0e2cef1fd569147732e48caf8538790339b":["c90f01e1c0f11ee52212ab38c6d4393b3be8a646"],"ad94625fb8d088209f46650c8097196fec67f00c":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["ad94625fb8d088209f46650c8097196fec67f00c"],"c90f01e1c0f11ee52212ab38c6d4393b3be8a646":["be29e0e2cef1fd569147732e48caf8538790339b"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["c90f01e1c0f11ee52212ab38c6d4393b3be8a646"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"be29e0e2cef1fd569147732e48caf8538790339b":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}