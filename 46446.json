{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","commits":[{"id":"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","date":1346834651,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"038e2a9b07e2f8ae58336613cea227bf8b973484","date":1346850972,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["038e2a9b07e2f8ae58336613cea227bf8b973484"],"038e2a9b07e2f8ae58336613cea227bf8b973484":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"]},"commit2Childs":{"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["038e2a9b07e2f8ae58336613cea227bf8b973484"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"038e2a9b07e2f8ae58336613cea227bf8b973484":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}