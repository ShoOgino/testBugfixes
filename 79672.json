{"path":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,boolean,HLLType).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,boolean,HLLType).mjava","pathOld":"/dev/null","sourceNew":"    // ========================================================================\n    /**\n     * NOTE: Arguments here are named and structured identically to those in the\n     *       PostgreSQL implementation, which can be found\n     *       <a href=\"https://github.com/aggregateknowledge/postgresql-hll/blob/master/README.markdown#explanation-of-parameters-and-tuning\">here</a>.\n     *\n     * @param log2m log-base-2 of the number of registers used in the HyperLogLog\n     *        algorithm. Must be at least 4 and at most 30.\n     * @param regwidth number of bits used per register in the HyperLogLog\n     *        algorithm. Must be at least 1 and at most 8.\n     * @param expthresh tunes when the {@link HLLType#EXPLICIT} to\n     *        {@link HLLType#SPARSE} promotion occurs,\n     *        based on the set's cardinality. Must be at least -1 and at most 18.\n     *        <table>\n     *        <thead><tr><th><code>expthresh</code> value</th><th>Meaning</th></tr></thead>\n     *        <tbody>\n     *        <tr>\n     *            <td>-1</td>\n     *            <td>Promote at whatever cutoff makes sense for optimal memory usage. ('auto' mode)</td>\n     *        </tr>\n     *        <tr>\n     *            <td>0</td>\n     *            <td>Skip <code>EXPLICIT</code> representation in hierarchy.</td>\n     *        </tr>\n     *        <tr>\n     *            <td>1-18</td>\n     *            <td>Promote at 2<sup>expthresh - 1</sup> cardinality</td>\n     *        </tr>\n     *        </tbody>\n     *        </table>\n     * @param sparseon Flag indicating if the {@link HLLType#SPARSE}\n     *        representation should be used.\n     * @param type the type in the promotion hierarchy which this instance should\n     *        start at. This cannot be <code>null</code>.\n     */\n    public HLL(final int log2m, final int regwidth, final int expthresh, final boolean sparseon, final HLLType type) {\n        this.log2m = log2m;\n        if((log2m < MINIMUM_LOG2M_PARAM) || (log2m > MAXIMUM_LOG2M_PARAM)) {\n            throw new IllegalArgumentException(\"'log2m' must be at least \" + MINIMUM_LOG2M_PARAM + \" and at most \" + MAXIMUM_LOG2M_PARAM + \" (was: \" + log2m + \")\");\n        }\n\n        this.regwidth = regwidth;\n        if((regwidth < MINIMUM_REGWIDTH_PARAM) || (regwidth > MAXIMUM_REGWIDTH_PARAM)) {\n            throw new IllegalArgumentException(\"'regwidth' must be at least \" + MINIMUM_REGWIDTH_PARAM + \" and at most \" + MAXIMUM_REGWIDTH_PARAM + \" (was: \" + regwidth + \")\");\n        }\n\n        this.m = (1 << log2m);\n        this.mBitsMask = m - 1;\n        this.valueMask = (1 << regwidth) - 1;\n        this.pwMaxMask = HLLUtil.pwMaxMask(regwidth);\n        this.alphaMSquared = HLLUtil.alphaMSquared(m);\n        this.smallEstimatorCutoff = HLLUtil.smallEstimatorCutoff(m);\n        this.largeEstimatorCutoff = HLLUtil.largeEstimatorCutoff(log2m, regwidth);\n\n        if(expthresh == -1) {\n            this.explicitAuto = true;\n            this.explicitOff = false;\n\n            // NOTE:  This math matches the size calculation in the PostgreSQL impl.\n            final long fullRepresentationSize = (this.regwidth * (long)this.m + 7/*round up to next whole byte*/)/Byte.SIZE;\n            final int numLongs = (int)(fullRepresentationSize / 8/*integer division to round down*/);\n\n            if(numLongs > MAXIMUM_EXPLICIT_THRESHOLD) {\n                this.explicitThreshold = MAXIMUM_EXPLICIT_THRESHOLD;\n            } else {\n                this.explicitThreshold = numLongs;\n            }\n        } else if(expthresh == 0) {\n            this.explicitAuto = false;\n            this.explicitOff = true;\n            this.explicitThreshold = 0;\n        } else if((expthresh > 0) && (expthresh <= MAXIMUM_EXPTHRESH_PARAM)){\n            this.explicitAuto = false;\n            this.explicitOff = false;\n            this.explicitThreshold = (1 << (expthresh - 1));\n        } else {\n            throw new IllegalArgumentException(\"'expthresh' must be at least \" + MINIMUM_EXPTHRESH_PARAM + \" and at most \" + MAXIMUM_EXPTHRESH_PARAM + \" (was: \" + expthresh + \")\");\n        }\n\n        this.shortWordLength = (regwidth + log2m);\n        this.sparseOff = !sparseon;\n        if(this.sparseOff) {\n            this.sparseThreshold = 0;\n        } else {\n            // TODO improve this cutoff to include the cost overhead of Java\n            //      members/objects\n            final int largestPow2LessThanCutoff =\n                    (int)NumberUtil.log2((this.m * this.regwidth) / this.shortWordLength);\n            this.sparseThreshold = (1 << largestPow2LessThanCutoff);\n        }\n\n        initializeStorage(type);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cee04f63da2b1e4185495f96d22b98fa63a4fa8","date":1437045299,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,boolean,HLLType).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,boolean,HLLType).mjava","sourceNew":"    // ========================================================================\n    /**\n     * NOTE: Arguments here are named and structured identically to those in the\n     *       PostgreSQL implementation, which can be found\n     *       <a href=\"https://github.com/aggregateknowledge/postgresql-hll/blob/master/README.markdown#explanation-of-parameters-and-tuning\">here</a>.\n     *\n     * @param log2m log-base-2 of the number of registers used in the HyperLogLog\n     *        algorithm. Must be at least 4 and at most 30.\n     * @param regwidth number of bits used per register in the HyperLogLog\n     *        algorithm. Must be at least 1 and at most 8.\n     * @param expthresh tunes when the {@link HLLType#EXPLICIT} to\n     *        {@link HLLType#SPARSE} promotion occurs,\n     *        based on the set's cardinality. Must be at least -1 and at most 18.\n     * @param sparseon Flag indicating if the {@link HLLType#SPARSE}\n     *        representation should be used.\n     * @param type the type in the promotion hierarchy which this instance should\n     *        start at. This cannot be <code>null</code>.\n     */\n    public HLL(final int log2m, final int regwidth, final int expthresh, final boolean sparseon, final HLLType type) {\n        this.log2m = log2m;\n        if((log2m < MINIMUM_LOG2M_PARAM) || (log2m > MAXIMUM_LOG2M_PARAM)) {\n            throw new IllegalArgumentException(\"'log2m' must be at least \" + MINIMUM_LOG2M_PARAM + \" and at most \" + MAXIMUM_LOG2M_PARAM + \" (was: \" + log2m + \")\");\n        }\n\n        this.regwidth = regwidth;\n        if((regwidth < MINIMUM_REGWIDTH_PARAM) || (regwidth > MAXIMUM_REGWIDTH_PARAM)) {\n            throw new IllegalArgumentException(\"'regwidth' must be at least \" + MINIMUM_REGWIDTH_PARAM + \" and at most \" + MAXIMUM_REGWIDTH_PARAM + \" (was: \" + regwidth + \")\");\n        }\n\n        this.m = (1 << log2m);\n        this.mBitsMask = m - 1;\n        this.valueMask = (1 << regwidth) - 1;\n        this.pwMaxMask = HLLUtil.pwMaxMask(regwidth);\n        this.alphaMSquared = HLLUtil.alphaMSquared(m);\n        this.smallEstimatorCutoff = HLLUtil.smallEstimatorCutoff(m);\n        this.largeEstimatorCutoff = HLLUtil.largeEstimatorCutoff(log2m, regwidth);\n\n        if(expthresh == -1) {\n            this.explicitAuto = true;\n            this.explicitOff = false;\n\n            // NOTE:  This math matches the size calculation in the PostgreSQL impl.\n            final long fullRepresentationSize = (this.regwidth * (long)this.m + 7/*round up to next whole byte*/)/Byte.SIZE;\n            final int numLongs = (int)(fullRepresentationSize / 8/*integer division to round down*/);\n\n            if(numLongs > MAXIMUM_EXPLICIT_THRESHOLD) {\n                this.explicitThreshold = MAXIMUM_EXPLICIT_THRESHOLD;\n            } else {\n                this.explicitThreshold = numLongs;\n            }\n        } else if(expthresh == 0) {\n            this.explicitAuto = false;\n            this.explicitOff = true;\n            this.explicitThreshold = 0;\n        } else if((expthresh > 0) && (expthresh <= MAXIMUM_EXPTHRESH_PARAM)){\n            this.explicitAuto = false;\n            this.explicitOff = false;\n            this.explicitThreshold = (1 << (expthresh - 1));\n        } else {\n            throw new IllegalArgumentException(\"'expthresh' must be at least \" + MINIMUM_EXPTHRESH_PARAM + \" and at most \" + MAXIMUM_EXPTHRESH_PARAM + \" (was: \" + expthresh + \")\");\n        }\n\n        this.shortWordLength = (regwidth + log2m);\n        this.sparseOff = !sparseon;\n        if(this.sparseOff) {\n            this.sparseThreshold = 0;\n        } else {\n            // TODO improve this cutoff to include the cost overhead of Java\n            //      members/objects\n            final int largestPow2LessThanCutoff =\n                    (int)NumberUtil.log2((this.m * this.regwidth) / this.shortWordLength);\n            this.sparseThreshold = (1 << largestPow2LessThanCutoff);\n        }\n\n        initializeStorage(type);\n    }\n\n","sourceOld":"    // ========================================================================\n    /**\n     * NOTE: Arguments here are named and structured identically to those in the\n     *       PostgreSQL implementation, which can be found\n     *       <a href=\"https://github.com/aggregateknowledge/postgresql-hll/blob/master/README.markdown#explanation-of-parameters-and-tuning\">here</a>.\n     *\n     * @param log2m log-base-2 of the number of registers used in the HyperLogLog\n     *        algorithm. Must be at least 4 and at most 30.\n     * @param regwidth number of bits used per register in the HyperLogLog\n     *        algorithm. Must be at least 1 and at most 8.\n     * @param expthresh tunes when the {@link HLLType#EXPLICIT} to\n     *        {@link HLLType#SPARSE} promotion occurs,\n     *        based on the set's cardinality. Must be at least -1 and at most 18.\n     *        <table>\n     *        <thead><tr><th><code>expthresh</code> value</th><th>Meaning</th></tr></thead>\n     *        <tbody>\n     *        <tr>\n     *            <td>-1</td>\n     *            <td>Promote at whatever cutoff makes sense for optimal memory usage. ('auto' mode)</td>\n     *        </tr>\n     *        <tr>\n     *            <td>0</td>\n     *            <td>Skip <code>EXPLICIT</code> representation in hierarchy.</td>\n     *        </tr>\n     *        <tr>\n     *            <td>1-18</td>\n     *            <td>Promote at 2<sup>expthresh - 1</sup> cardinality</td>\n     *        </tr>\n     *        </tbody>\n     *        </table>\n     * @param sparseon Flag indicating if the {@link HLLType#SPARSE}\n     *        representation should be used.\n     * @param type the type in the promotion hierarchy which this instance should\n     *        start at. This cannot be <code>null</code>.\n     */\n    public HLL(final int log2m, final int regwidth, final int expthresh, final boolean sparseon, final HLLType type) {\n        this.log2m = log2m;\n        if((log2m < MINIMUM_LOG2M_PARAM) || (log2m > MAXIMUM_LOG2M_PARAM)) {\n            throw new IllegalArgumentException(\"'log2m' must be at least \" + MINIMUM_LOG2M_PARAM + \" and at most \" + MAXIMUM_LOG2M_PARAM + \" (was: \" + log2m + \")\");\n        }\n\n        this.regwidth = regwidth;\n        if((regwidth < MINIMUM_REGWIDTH_PARAM) || (regwidth > MAXIMUM_REGWIDTH_PARAM)) {\n            throw new IllegalArgumentException(\"'regwidth' must be at least \" + MINIMUM_REGWIDTH_PARAM + \" and at most \" + MAXIMUM_REGWIDTH_PARAM + \" (was: \" + regwidth + \")\");\n        }\n\n        this.m = (1 << log2m);\n        this.mBitsMask = m - 1;\n        this.valueMask = (1 << regwidth) - 1;\n        this.pwMaxMask = HLLUtil.pwMaxMask(regwidth);\n        this.alphaMSquared = HLLUtil.alphaMSquared(m);\n        this.smallEstimatorCutoff = HLLUtil.smallEstimatorCutoff(m);\n        this.largeEstimatorCutoff = HLLUtil.largeEstimatorCutoff(log2m, regwidth);\n\n        if(expthresh == -1) {\n            this.explicitAuto = true;\n            this.explicitOff = false;\n\n            // NOTE:  This math matches the size calculation in the PostgreSQL impl.\n            final long fullRepresentationSize = (this.regwidth * (long)this.m + 7/*round up to next whole byte*/)/Byte.SIZE;\n            final int numLongs = (int)(fullRepresentationSize / 8/*integer division to round down*/);\n\n            if(numLongs > MAXIMUM_EXPLICIT_THRESHOLD) {\n                this.explicitThreshold = MAXIMUM_EXPLICIT_THRESHOLD;\n            } else {\n                this.explicitThreshold = numLongs;\n            }\n        } else if(expthresh == 0) {\n            this.explicitAuto = false;\n            this.explicitOff = true;\n            this.explicitThreshold = 0;\n        } else if((expthresh > 0) && (expthresh <= MAXIMUM_EXPTHRESH_PARAM)){\n            this.explicitAuto = false;\n            this.explicitOff = false;\n            this.explicitThreshold = (1 << (expthresh - 1));\n        } else {\n            throw new IllegalArgumentException(\"'expthresh' must be at least \" + MINIMUM_EXPTHRESH_PARAM + \" and at most \" + MAXIMUM_EXPTHRESH_PARAM + \" (was: \" + expthresh + \")\");\n        }\n\n        this.shortWordLength = (regwidth + log2m);\n        this.sparseOff = !sparseon;\n        if(this.sparseOff) {\n            this.sparseThreshold = 0;\n        } else {\n            // TODO improve this cutoff to include the cost overhead of Java\n            //      members/objects\n            final int largestPow2LessThanCutoff =\n                    (int)NumberUtil.log2((this.m * this.regwidth) / this.shortWordLength);\n            this.sparseThreshold = (1 << largestPow2LessThanCutoff);\n        }\n\n        initializeStorage(type);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,boolean,HLLType).mjava","pathOld":"/dev/null","sourceNew":"    // ========================================================================\n    /**\n     * NOTE: Arguments here are named and structured identically to those in the\n     *       PostgreSQL implementation, which can be found\n     *       <a href=\"https://github.com/aggregateknowledge/postgresql-hll/blob/master/README.markdown#explanation-of-parameters-and-tuning\">here</a>.\n     *\n     * @param log2m log-base-2 of the number of registers used in the HyperLogLog\n     *        algorithm. Must be at least 4 and at most 30.\n     * @param regwidth number of bits used per register in the HyperLogLog\n     *        algorithm. Must be at least 1 and at most 8.\n     * @param expthresh tunes when the {@link HLLType#EXPLICIT} to\n     *        {@link HLLType#SPARSE} promotion occurs,\n     *        based on the set's cardinality. Must be at least -1 and at most 18.\n     * @param sparseon Flag indicating if the {@link HLLType#SPARSE}\n     *        representation should be used.\n     * @param type the type in the promotion hierarchy which this instance should\n     *        start at. This cannot be <code>null</code>.\n     */\n    public HLL(final int log2m, final int regwidth, final int expthresh, final boolean sparseon, final HLLType type) {\n        this.log2m = log2m;\n        if((log2m < MINIMUM_LOG2M_PARAM) || (log2m > MAXIMUM_LOG2M_PARAM)) {\n            throw new IllegalArgumentException(\"'log2m' must be at least \" + MINIMUM_LOG2M_PARAM + \" and at most \" + MAXIMUM_LOG2M_PARAM + \" (was: \" + log2m + \")\");\n        }\n\n        this.regwidth = regwidth;\n        if((regwidth < MINIMUM_REGWIDTH_PARAM) || (regwidth > MAXIMUM_REGWIDTH_PARAM)) {\n            throw new IllegalArgumentException(\"'regwidth' must be at least \" + MINIMUM_REGWIDTH_PARAM + \" and at most \" + MAXIMUM_REGWIDTH_PARAM + \" (was: \" + regwidth + \")\");\n        }\n\n        this.m = (1 << log2m);\n        this.mBitsMask = m - 1;\n        this.valueMask = (1 << regwidth) - 1;\n        this.pwMaxMask = HLLUtil.pwMaxMask(regwidth);\n        this.alphaMSquared = HLLUtil.alphaMSquared(m);\n        this.smallEstimatorCutoff = HLLUtil.smallEstimatorCutoff(m);\n        this.largeEstimatorCutoff = HLLUtil.largeEstimatorCutoff(log2m, regwidth);\n\n        if(expthresh == -1) {\n            this.explicitAuto = true;\n            this.explicitOff = false;\n\n            // NOTE:  This math matches the size calculation in the PostgreSQL impl.\n            final long fullRepresentationSize = (this.regwidth * (long)this.m + 7/*round up to next whole byte*/)/Byte.SIZE;\n            final int numLongs = (int)(fullRepresentationSize / 8/*integer division to round down*/);\n\n            if(numLongs > MAXIMUM_EXPLICIT_THRESHOLD) {\n                this.explicitThreshold = MAXIMUM_EXPLICIT_THRESHOLD;\n            } else {\n                this.explicitThreshold = numLongs;\n            }\n        } else if(expthresh == 0) {\n            this.explicitAuto = false;\n            this.explicitOff = true;\n            this.explicitThreshold = 0;\n        } else if((expthresh > 0) && (expthresh <= MAXIMUM_EXPTHRESH_PARAM)){\n            this.explicitAuto = false;\n            this.explicitOff = false;\n            this.explicitThreshold = (1 << (expthresh - 1));\n        } else {\n            throw new IllegalArgumentException(\"'expthresh' must be at least \" + MINIMUM_EXPTHRESH_PARAM + \" and at most \" + MAXIMUM_EXPTHRESH_PARAM + \" (was: \" + expthresh + \")\");\n        }\n\n        this.shortWordLength = (regwidth + log2m);\n        this.sparseOff = !sparseon;\n        if(this.sparseOff) {\n            this.sparseThreshold = 0;\n        } else {\n            // TODO improve this cutoff to include the cost overhead of Java\n            //      members/objects\n            final int largestPow2LessThanCutoff =\n                    (int)NumberUtil.log2((this.m * this.regwidth) / this.shortWordLength);\n            this.sparseThreshold = (1 << largestPow2LessThanCutoff);\n        }\n\n        initializeStorage(type);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cee04f63da2b1e4185495f96d22b98fa63a4fa8"],"3cee04f63da2b1e4185495f96d22b98fa63a4fa8":["6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cee04f63da2b1e4185495f96d22b98fa63a4fa8":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3cee04f63da2b1e4185495f96d22b98fa63a4fa8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}