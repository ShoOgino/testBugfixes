{"path":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest#testReadOnlyCollection().mjava","commits":[{"id":"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e","date":1551802585,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest#testReadOnlyCollection().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testReadOnlyCollection() throws Exception {\n    final String collectionName = \"readOnlyTest\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(solrClient);\n\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    // verify that indexing works\n    List<SolrInputDocument> docs = new ArrayList<>();\n    for (int i = 0; i < NUM_DOCS; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n    // verify the docs exist\n    QueryResponse rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"initial num docs\", NUM_DOCS, rsp.getResults().getNumFound());\n\n    // index more but don't commit\n    docs.clear();\n    for (int i = NUM_DOCS; i < NUM_DOCS * 2; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n\n    Replica leader\n        = solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    final AtomicReference<Long> coreStartTime = new AtomicReference<>(getCoreStatus(leader).getCoreStartTime().getTime());\n\n    // Check for value change\n    CollectionAdminRequest.modifyCollection(collectionName,\n        Collections.singletonMap(ZkStateReader.READ_ONLY, \"true\"))\n        .process(solrClient);\n\n    DocCollection coll = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertNotNull(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY));\n    assertEquals(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY).toString(), \"true\");\n\n    // wait for the expected collection reload\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime.get();\n    });\n\n    coreStartTime.set(getCoreStatus(leader).getCoreStartTime().getTime());\n\n    // check for docs - reloading should have committed the new docs\n    // this also verifies that searching works in read-only mode\n    rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"num docs after turning on read-only\", NUM_DOCS * 2, rsp.getResults().getNumFound());\n\n    // try sending updates\n    try {\n      solrClient.add(new SolrInputDocument(\"id\", \"shouldFail\"));\n      fail(\"add() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.deleteById(\"shouldFail\");\n      fail(\"deleteById() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.deleteByQuery(\"id:shouldFail\");\n      fail(\"deleteByQuery() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.commit();\n      fail(\"commit() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.optimize();\n      fail(\"optimize() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.rollback();\n      fail(\"rollback() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n\n    // Check for removing value\n    // setting to empty string is equivalent to removing the property, see SOLR-12507\n    CollectionAdminRequest.modifyCollection(collectionName,\n        Collections.singletonMap(ZkStateReader.READ_ONLY, \"\"))\n        .process(cluster.getSolrClient());\n    coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(collectionName);\n    assertNull(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY));\n\n    // wait for the expected collection reload\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime.get();\n    });\n\n    // check that updates are working now\n    docs.clear();\n    for (int i = NUM_DOCS * 2; i < NUM_DOCS * 3; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n    rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"num docs after turning off read-only\", NUM_DOCS * 3, rsp.getResults().getNumFound());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest#testReadOnlyCollection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest#testReadOnlyCollection().mjava","sourceNew":"  @Test\n  public void testReadOnlyCollection() throws Exception {\n    final String collectionName = \"readOnlyTest\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(solrClient);\n\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    // verify that indexing works\n    List<SolrInputDocument> docs = new ArrayList<>();\n    for (int i = 0; i < NUM_DOCS; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n    // verify the docs exist\n    QueryResponse rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"initial num docs\", NUM_DOCS, rsp.getResults().getNumFound());\n\n    // index more but don't commit\n    docs.clear();\n    for (int i = NUM_DOCS; i < NUM_DOCS * 2; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n\n    Replica leader\n        = solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    final AtomicReference<Long> coreStartTime = new AtomicReference<>(getCoreStatus(leader).getCoreStartTime().getTime());\n\n    // Check for value change\n    CollectionAdminRequest.modifyCollection(collectionName,\n        Collections.singletonMap(ZkStateReader.READ_ONLY, \"true\"))\n        .process(solrClient);\n\n    DocCollection coll = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertNotNull(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY));\n    assertEquals(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY).toString(), \"true\");\n\n    // wait for the expected collection reload\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: \", e);\n        return false;\n      }\n      return restartTime > coreStartTime.get();\n    });\n\n    coreStartTime.set(getCoreStatus(leader).getCoreStartTime().getTime());\n\n    // check for docs - reloading should have committed the new docs\n    // this also verifies that searching works in read-only mode\n    rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"num docs after turning on read-only\", NUM_DOCS * 2, rsp.getResults().getNumFound());\n\n    // try sending updates\n    try {\n      solrClient.add(new SolrInputDocument(\"id\", \"shouldFail\"));\n      fail(\"add() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.deleteById(\"shouldFail\");\n      fail(\"deleteById() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.deleteByQuery(\"id:shouldFail\");\n      fail(\"deleteByQuery() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.commit();\n      fail(\"commit() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.optimize();\n      fail(\"optimize() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.rollback();\n      fail(\"rollback() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n\n    // Check for removing value\n    // setting to empty string is equivalent to removing the property, see SOLR-12507\n    CollectionAdminRequest.modifyCollection(collectionName,\n        Collections.singletonMap(ZkStateReader.READ_ONLY, \"\"))\n        .process(cluster.getSolrClient());\n    coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(collectionName);\n    assertNull(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY));\n\n    // wait for the expected collection reload\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: \", e);\n        return false;\n      }\n      return restartTime > coreStartTime.get();\n    });\n\n    // check that updates are working now\n    docs.clear();\n    for (int i = NUM_DOCS * 2; i < NUM_DOCS * 3; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n    rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"num docs after turning off read-only\", NUM_DOCS * 3, rsp.getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void testReadOnlyCollection() throws Exception {\n    final String collectionName = \"readOnlyTest\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 2)\n        .process(solrClient);\n\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    // verify that indexing works\n    List<SolrInputDocument> docs = new ArrayList<>();\n    for (int i = 0; i < NUM_DOCS; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n    // verify the docs exist\n    QueryResponse rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"initial num docs\", NUM_DOCS, rsp.getResults().getNumFound());\n\n    // index more but don't commit\n    docs.clear();\n    for (int i = NUM_DOCS; i < NUM_DOCS * 2; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n\n    Replica leader\n        = solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    final AtomicReference<Long> coreStartTime = new AtomicReference<>(getCoreStatus(leader).getCoreStartTime().getTime());\n\n    // Check for value change\n    CollectionAdminRequest.modifyCollection(collectionName,\n        Collections.singletonMap(ZkStateReader.READ_ONLY, \"true\"))\n        .process(solrClient);\n\n    DocCollection coll = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertNotNull(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY));\n    assertEquals(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY).toString(), \"true\");\n\n    // wait for the expected collection reload\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime.get();\n    });\n\n    coreStartTime.set(getCoreStatus(leader).getCoreStartTime().getTime());\n\n    // check for docs - reloading should have committed the new docs\n    // this also verifies that searching works in read-only mode\n    rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"num docs after turning on read-only\", NUM_DOCS * 2, rsp.getResults().getNumFound());\n\n    // try sending updates\n    try {\n      solrClient.add(new SolrInputDocument(\"id\", \"shouldFail\"));\n      fail(\"add() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.deleteById(\"shouldFail\");\n      fail(\"deleteById() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.deleteByQuery(\"id:shouldFail\");\n      fail(\"deleteByQuery() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.commit();\n      fail(\"commit() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.optimize();\n      fail(\"optimize() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n    try {\n      solrClient.rollback();\n      fail(\"rollback() should fail in read-only mode\");\n    } catch (Exception e) {\n      // expected - ignore\n    }\n\n    // Check for removing value\n    // setting to empty string is equivalent to removing the property, see SOLR-12507\n    CollectionAdminRequest.modifyCollection(collectionName,\n        Collections.singletonMap(ZkStateReader.READ_ONLY, \"\"))\n        .process(cluster.getSolrClient());\n    coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(collectionName);\n    assertNull(coll.toString(), coll.getProperties().get(ZkStateReader.READ_ONLY));\n\n    // wait for the expected collection reload\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime.get();\n    });\n\n    // check that updates are working now\n    docs.clear();\n    for (int i = NUM_DOCS * 2; i < NUM_DOCS * 3; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"string_s\", String.valueOf(i)));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n    rsp = solrClient.query(params(CommonParams.Q, \"*:*\"));\n    assertEquals(\"num docs after turning off read-only\", NUM_DOCS * 3, rsp.getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"]},"commit2Childs":{"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}