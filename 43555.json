{"path":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#doProxyFor(String).mjava","commits":[{"id":"bc6055f4a2e8e9f9caaec2297010c9502480ed69","date":1050060580,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#doProxyFor(String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Remove <var>host</var> from the list of hosts for which the proxy should\n     * not be used. This modifies the same list that <code>dontProxyFor()</code>\n     * uses, i.e. this is used to undo a <code>dontProxyFor()</code> setting.\n     * The syntax for <var>host</var> is specified in <code>dontProxyFor()</code>\n     * .\n     *\n     * @param host                a host name, domain name, IP-address or\n     *      IP-subnet.\n     * @return                    true if the remove was sucessful, false\n     *      otherwise\n     * @exception ParseException  if the length of the netmask does not match\n     *      the length of the IP-address\n     * @see                       #dontProxyFor(java.lang.String)\n     */\n    public static boolean doProxyFor(String host)\n        throws ParseException\n    {\n        host = host.trim().toLowerCase();\n\n        // check for domain name\n\n        if (host.charAt(0) == '.')\n        {\n            return non_proxy_dom_list.removeElement(host);\n        }\n\n        // check for host name\n\n        for (int idx = 0; idx < host.length(); idx++)\n        {\n            if (!Character.isDigit(host.charAt(idx)) &&\n                    host.charAt(idx) != '.' && host.charAt(idx) != '/')\n            {\n                return (non_proxy_host_list.remove(host) != null);\n            }\n        }\n\n        // must be an IP-address\n\n        byte[] ip_addr;\n        byte[] ip_mask;\n        int slash;\n        if ((slash = host.indexOf('/')) != -1)\n        {\n            // IP subnet\n\n            ip_addr = string2arr(host.substring(0, slash));\n            ip_mask = string2arr(host.substring(slash + 1));\n            if (ip_addr.length != ip_mask.length)\n            {\n                throw new ParseException(\"length of IP-address (\" +\n                        ip_addr.length + \") != length of netmask (\" +\n                        ip_mask.length + \")\");\n            }\n        }\n        else\n        {\n            ip_addr = string2arr(host);\n            ip_mask = new byte[ip_addr.length];\n            for (int idx = 0; idx < ip_mask.length; idx++)\n            {\n                ip_mask[idx] = (byte) 255;\n            }\n        }\n\n        ip_loop :\n        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)\n        {\n            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);\n            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);\n            if (addr.length != ip_addr.length)\n            {\n                continue;\n            }\n\n            for (int idx2 = 0; idx2 < addr.length; idx2++)\n            {\n                if ((ip_addr[idx2] & mask[idx2]) != (addr[idx2] & mask[idx2]) ||\n                        (mask[idx2] != ip_mask[idx2]))\n                {\n                    continue ip_loop;\n                }\n            }\n\n            non_proxy_addr_list.removeElementAt(idx);\n            non_proxy_mask_list.removeElementAt(idx);\n            return true;\n        }\n        return false;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#doProxyFor(String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Remove <var>host</var> from the list of hosts for which the proxy should\n     * not be used. This modifies the same list that <code>dontProxyFor()</code>\n     * uses, i.e. this is used to undo a <code>dontProxyFor()</code> setting.\n     * The syntax for <var>host</var> is specified in <code>dontProxyFor()</code>\n     * .\n     *\n     * @param host                a host name, domain name, IP-address or\n     *      IP-subnet.\n     * @return                    true if the remove was sucessful, false\n     *      otherwise\n     * @exception ParseException  if the length of the netmask does not match\n     *      the length of the IP-address\n     * @see                       #dontProxyFor(java.lang.String)\n     */\n    public static boolean doProxyFor(String host)\n        throws ParseException\n    {\n        host = host.trim().toLowerCase();\n\n        // check for domain name\n\n        if (host.charAt(0) == '.')\n        {\n            return non_proxy_dom_list.removeElement(host);\n        }\n\n        // check for host name\n\n        for (int idx = 0; idx < host.length(); idx++)\n        {\n            if (!Character.isDigit(host.charAt(idx)) &&\n                    host.charAt(idx) != '.' && host.charAt(idx) != '/')\n            {\n                return (non_proxy_host_list.remove(host) != null);\n            }\n        }\n\n        // must be an IP-address\n\n        byte[] ip_addr;\n        byte[] ip_mask;\n        int slash;\n        if ((slash = host.indexOf('/')) != -1)\n        {\n            // IP subnet\n\n            ip_addr = string2arr(host.substring(0, slash));\n            ip_mask = string2arr(host.substring(slash + 1));\n            if (ip_addr.length != ip_mask.length)\n            {\n                throw new ParseException(\"length of IP-address (\" +\n                        ip_addr.length + \") != length of netmask (\" +\n                        ip_mask.length + \")\");\n            }\n        }\n        else\n        {\n            ip_addr = string2arr(host);\n            ip_mask = new byte[ip_addr.length];\n            for (int idx = 0; idx < ip_mask.length; idx++)\n            {\n                ip_mask[idx] = (byte) 255;\n            }\n        }\n\n        ip_loop :\n        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)\n        {\n            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);\n            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);\n            if (addr.length != ip_addr.length)\n            {\n                continue;\n            }\n\n            for (int idx2 = 0; idx2 < addr.length; idx2++)\n            {\n                if ((ip_addr[idx2] & mask[idx2]) != (addr[idx2] & mask[idx2]) ||\n                        (mask[idx2] != ip_mask[idx2]))\n                {\n                    continue ip_loop;\n                }\n            }\n\n            non_proxy_addr_list.removeElementAt(idx);\n            non_proxy_mask_list.removeElementAt(idx);\n            return true;\n        }\n        return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}