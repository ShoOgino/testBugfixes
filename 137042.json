{"path":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","commits":[{"id":"283ff02f401ec3e7a2fad73643970f052383fb0c","date":1411407953,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","pathOld":"/dev/null","sourceNew":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.calcDistinct = statsField.getCalcDistinct();\n    this.distinctValues = new TreeSet<>();\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two \n    // masters: collecting concrete Values from things like DocValuesStats and \n    // the distributed aggregation logic, but also collecting docIds which it then\n    // uses to go out and pull concreate values from the ValueSource \n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d12bbc45d641864ffe03291bc30f178eb34e434c","date":1426001646,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","sourceNew":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n      \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two \n    // masters: collecting concrete Values from things like DocValuesStats and \n    // the distributed aggregation logic, but also collecting docIds which it then\n    // uses to go out and pull concreate values from the ValueSource \n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","sourceOld":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.calcDistinct = statsField.getCalcDistinct();\n    this.distinctValues = new TreeSet<>();\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two \n    // masters: collecting concrete Values from things like DocValuesStats and \n    // the distributed aggregation logic, but also collecting docIds which it then\n    // uses to go out and pull concreate values from the ValueSource \n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1002283cfd29923d517db7c33e07bb54aac7acd4","date":1427211199,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","sourceNew":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n      \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","sourceOld":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n      \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two \n    // masters: collecting concrete Values from things like DocValuesStats and \n    // the distributed aggregation logic, but also collecting docIds which it then\n    // uses to go out and pull concreate values from the ValueSource \n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","sourceNew":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n      \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","sourceOld":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.calcDistinct = statsField.getCalcDistinct();\n    this.distinctValues = new TreeSet<>();\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two \n    // masters: collecting concrete Values from things like DocValuesStats and \n    // the distributed aggregation logic, but also collecting docIds which it then\n    // uses to go out and pull concreate values from the ValueSource \n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a4e2c829188fb99886a64558664d79c9ac0fdf1","date":1431021538,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","sourceNew":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n    \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n    if ( computeCardinality ) {\n\n      hasher = statsField.getHllOptions().getHasher();\n      hll = statsField.getHllOptions().newHLL();\n      assert null != hll : \"Cardinality requires an HLL\";\n    } else {\n      hll = null;\n      hasher = null;\n    }\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","sourceOld":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n      \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e7062fc1cf235b04a88adfc21dc68e040c82561","date":1431110643,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","sourceNew":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct) \n      || statsField.calculateStats(Stat.distinctValues);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n    \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n    if ( computeCardinality ) {\n\n      hasher = statsField.getHllOptions().getHasher();\n      hll = statsField.getHllOptions().newHLL();\n      assert null != hll : \"Cardinality requires an HLL\";\n    } else {\n      hll = null;\n      hasher = null;\n    }\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","sourceOld":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.calcdistinct);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n    \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n    if ( computeCardinality ) {\n\n      hasher = statsField.getHllOptions().getHasher();\n      hll = statsField.getHllOptions().newHLL();\n      assert null != hll : \"Cardinality requires an HLL\";\n    } else {\n      hll = null;\n      hasher = null;\n    }\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":4,"author":"Mike Drob","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/component/AbstractStatsValues[StatsValuesFactory]#AbstractStatsValues(StatsField).mjava","sourceNew":null,"sourceOld":"  protected AbstractStatsValues(StatsField statsField) {\n    this.statsField = statsField;\n    this.computeCount = statsField.calculateStats(Stat.count);\n    this.computeMissing = statsField.calculateStats(Stat.missing);\n    this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct) \n      || statsField.calculateStats(Stat.distinctValues);\n    this.computeMin = statsField.calculateStats(Stat.min);\n    this.computeMax = statsField.calculateStats(Stat.max);\n    this.computeMinOrMax = computeMin || computeMax;\n    \n    this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n    this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n    if ( computeCardinality ) {\n\n      hasher = statsField.getHllOptions().getHasher();\n      hll = statsField.getHllOptions().newHLL();\n      assert null != hll : \"Cardinality requires an HLL\";\n    } else {\n      hll = null;\n      hasher = null;\n    }\n\n    // alternatively, we could refactor a common base class that doesn't know/care\n    // about either SchemaField or ValueSource - but then there would be a lot of\n    // duplicate code between \"NumericSchemaFieldStatsValues\" and \n    // \"NumericValueSourceStatsValues\" which would have diff parent classes\n    //\n    // part of the complexity here being that the StatsValues API serves two\n    // masters: collecting concrete Values from things like DocValuesStats and\n    // the distributed aggregation logic, but also collecting docIds which it\n    // then\n    // uses to go out and pull concreate values from the ValueSource\n    // (from a func, or single valued field)\n    if (null != statsField.getSchemaField()) {\n      assert null == statsField.getValueSource();\n      this.sf = statsField.getSchemaField();\n      this.ft = sf.getType();\n    } else {\n      assert null != statsField.getValueSource();\n      assert null == statsField.getSchemaField();\n      this.sf = null;\n      this.ft = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2e7062fc1cf235b04a88adfc21dc68e040c82561":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"283ff02f401ec3e7a2fad73643970f052383fb0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["283ff02f401ec3e7a2fad73643970f052383fb0c","1002283cfd29923d517db7c33e07bb54aac7acd4"],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["2e7062fc1cf235b04a88adfc21dc68e040c82561"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d12bbc45d641864ffe03291bc30f178eb34e434c":["283ff02f401ec3e7a2fad73643970f052383fb0c"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"]},"commit2Childs":{"2e7062fc1cf235b04a88adfc21dc68e040c82561":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"283ff02f401ec3e7a2fad73643970f052383fb0c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d12bbc45d641864ffe03291bc30f178eb34e434c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["2e7062fc1cf235b04a88adfc21dc68e040c82561"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["283ff02f401ec3e7a2fad73643970f052383fb0c"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d12bbc45d641864ffe03291bc30f178eb34e434c":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}