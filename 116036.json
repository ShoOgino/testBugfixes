{"path":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","commits":[{"id":"b3a34dae868734612eb6329aa0ef754f30bd2036","date":1438783154,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header\");\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    byte[] decipher = decipherData(nodeName, cipher);\n    if (decipher == null) {\n      return;\n    }\n\n    String s = new String(decipher, StandardCharsets.UTF_8).trim();\n    List<String> pcs = StrUtils.splitWS(s, false);\n    if (pcs.size() < 2) {\n      return;\n    }\n\n    final String userName = pcs.get(0);\n    String timeStr = pcs.get(1);\n    try {\n      long timeMillis = Long.parseLong(timeStr);\n      if ((receivedTime - timeMillis) > maxValidity) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n      }\n    } catch (NumberFormatException e) {\n      log.error(\"Invalid time \" + timeStr, e);\n      return;\n    }\n    final Principal principal = \"$\".equals(userName) ?\n        SU :\n        new BasicUserPrincipal(userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["946009ad0fba506337041a368b0a74d2edd59e2c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header\");\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    byte[] decipher = decipherData(nodeName, cipher);\n    if (decipher == null) {\n      return;\n    }\n\n    String s = new String(decipher, StandardCharsets.UTF_8).trim();\n    List<String> pcs = StrUtils.splitWS(s, false);\n    if (pcs.size() < 2) {\n      return;\n    }\n\n    final String userName = pcs.get(0);\n    String timeStr = pcs.get(1);\n    try {\n      long timeMillis = Long.parseLong(timeStr);\n      if ((receivedTime - timeMillis) > maxValidity) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n      }\n    } catch (NumberFormatException e) {\n      log.error(\"Invalid time \" + timeStr, e);\n      return;\n    }\n    final Principal principal = \"$\".equals(userName) ?\n        SU :\n        new BasicUserPrincipal(userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","sourceOld":"  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header\");\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    byte[] decipher = decipherData(nodeName, cipher);\n    if (decipher == null) {\n      return;\n    }\n\n    String s = new String(decipher, StandardCharsets.UTF_8).trim();\n    List<String> pcs = StrUtils.splitWS(s, false);\n    if (pcs.size() < 2) {\n      return;\n    }\n\n    final String userName = pcs.get(0);\n    String timeStr = pcs.get(1);\n    try {\n      long timeMillis = Long.parseLong(timeStr);\n      if ((receivedTime - timeMillis) > maxValidity) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n      }\n    } catch (NumberFormatException e) {\n      log.error(\"Invalid time \" + timeStr, e);\n      return;\n    }\n    final Principal principal = \"$\".equals(userName) ?\n        SU :\n        new BasicUserPrincipal(userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e76c7a05748b87468b5ccbcf325482013e002a3d","date":1448547807,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header\");\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    byte[] decipher = decipherData(nodeName, cipher);\n    if (decipher == null) {\n      return;\n    }\n\n    String s = new String(decipher, StandardCharsets.UTF_8).trim();\n    List<String> pcs = StrUtils.splitWS(s, false);\n    if (pcs.size() < 2) {\n      return;\n    }\n\n    final String userName = pcs.get(0);\n    String timeStr = pcs.get(1);\n    try {\n      long timeMillis = Long.parseLong(timeStr);\n      if ((receivedTime - timeMillis) > maxValidity) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n      }\n    } catch (NumberFormatException e) {\n      log.error(\"Invalid time \" + timeStr, e);\n      return;\n    }\n    final Principal principal = \"$\".equals(userName) ?\n        SU :\n        new BasicUserPrincipal(userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2673025c1f6208a4ab731e12f4e98a5e7f257cd","date":1463985317,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp {} : received timestamp {}\", decipher.timestamp, receivedTime);\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe77634baaecc558eab57f5f0e3d83738e8cf66f","date":1464066551,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp {} : received timestamp {}\", decipher.timestamp, receivedTime);\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20be168d828ac40d262f85364d02f15b491dd88b","date":1469725145,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n        log.error(\"Invalid key \");\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"946009ad0fba506337041a368b0a74d2edd59e2c","date":1528114477,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","bugFix":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85397dd93927c17347c6bf89800cd0fc566c2d03","date":1544610812,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      numPassThrough.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      numMissingCredentials.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      numErrors.mark();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      numMissingCredentials.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n      numErrors.mark();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    numAuthenticated.inc();\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n        filterChain.doFilter(request, response);\n        return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b436ffee26b67f87efef6a3bab24697332b6b2","date":1587575178,"type":5,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(HttpServletRequest,HttpServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin#doAuthenticate(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = request.getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      numPassThrough.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = request.getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      numMissingCredentials.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      numErrors.mark();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      numMissingCredentials.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n      numErrors.mark();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    numAuthenticated.inc();\n    filterChain.doFilter(wrapWithPrincipal(request, principal), response);\n    return true;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n  @Override\n  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n\n    String requestURI = ((HttpServletRequest) request).getRequestURI();\n    if (requestURI.endsWith(PublicKeyHandler.PATH)) {\n      numPassThrough.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    long receivedTime = System.currentTimeMillis();\n    String header = ((HttpServletRequest) request).getHeader(HEADER);\n    if (header == null) {\n      //this must not happen\n      log.error(\"No SolrAuth header present\");\n      numMissingCredentials.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    List<String> authInfo = StrUtils.splitWS(header, false);\n    if (authInfo.size() < 2) {\n      log.error(\"Invalid SolrAuth Header {}\", header);\n      numErrors.mark();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    String nodeName = authInfo.get(0);\n    String cipher = authInfo.get(1);\n\n    PKIHeaderData decipher = decipherHeader(nodeName, cipher);\n    if (decipher == null) {\n      log.error(\"Could not decipher a header {} . No principal set\", header);\n      numMissingCredentials.inc();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n    if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n      log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n      numErrors.mark();\n      filterChain.doFilter(request, response);\n      return true;\n    }\n\n    final Principal principal = \"$\".equals(decipher.userName) ?\n        SU :\n        new BasicUserPrincipal(decipher.userName);\n\n    numAuthenticated.inc();\n    filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"23b436ffee26b67f87efef6a3bab24697332b6b2":["85397dd93927c17347c6bf89800cd0fc566c2d03"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe77634baaecc558eab57f5f0e3d83738e8cf66f":["a2673025c1f6208a4ab731e12f4e98a5e7f257cd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["e76c7a05748b87468b5ccbcf325482013e002a3d","20be168d828ac40d262f85364d02f15b491dd88b"],"946009ad0fba506337041a368b0a74d2edd59e2c":["20be168d828ac40d262f85364d02f15b491dd88b"],"e76c7a05748b87468b5ccbcf325482013e002a3d":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"85397dd93927c17347c6bf89800cd0fc566c2d03":["946009ad0fba506337041a368b0a74d2edd59e2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["20be168d828ac40d262f85364d02f15b491dd88b","946009ad0fba506337041a368b0a74d2edd59e2c"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"20be168d828ac40d262f85364d02f15b491dd88b":["fe77634baaecc558eab57f5f0e3d83738e8cf66f"],"a2673025c1f6208a4ab731e12f4e98a5e7f257cd":["e76c7a05748b87468b5ccbcf325482013e002a3d"],"f592209545c71895260367152601e9200399776d":["20be168d828ac40d262f85364d02f15b491dd88b","946009ad0fba506337041a368b0a74d2edd59e2c"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["fe77634baaecc558eab57f5f0e3d83738e8cf66f","20be168d828ac40d262f85364d02f15b491dd88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23b436ffee26b67f87efef6a3bab24697332b6b2"]},"commit2Childs":{"23b436ffee26b67f87efef6a3bab24697332b6b2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"fe77634baaecc558eab57f5f0e3d83738e8cf66f":["20be168d828ac40d262f85364d02f15b491dd88b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"946009ad0fba506337041a368b0a74d2edd59e2c":["85397dd93927c17347c6bf89800cd0fc566c2d03","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"e76c7a05748b87468b5ccbcf325482013e002a3d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a2673025c1f6208a4ab731e12f4e98a5e7f257cd"],"85397dd93927c17347c6bf89800cd0fc566c2d03":["23b436ffee26b67f87efef6a3bab24697332b6b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["e76c7a05748b87468b5ccbcf325482013e002a3d"],"a2673025c1f6208a4ab731e12f4e98a5e7f257cd":["fe77634baaecc558eab57f5f0e3d83738e8cf66f"],"20be168d828ac40d262f85364d02f15b491dd88b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","946009ad0fba506337041a368b0a74d2edd59e2c","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"f592209545c71895260367152601e9200399776d":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}