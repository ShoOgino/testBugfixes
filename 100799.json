{"path":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","commits":[{"id":"21d517f3b4989fcd30eda0cad105d5fdcaeb5d7c","date":1373406544,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = upperBound;\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7581da3051efe8071ae92ac7eca27a270bc4611e","date":1373613227,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","sourceNew":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n  }\n\n","sourceOld":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = upperBound;\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"423470dff9e19aa0db92590e282e2ca12e34d65a","date":1381851051,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","sourceNew":"  /**\n  * Construct an Elias-Fano encoder using {@link #DEFAULT_INDEX_INTERVAL}.\n  */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    this(numValues, upperBound, DEFAULT_INDEX_INTERVAL);\n  }\n\n","sourceOld":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556259cdb46d4f7fb27f4688c4efcb3eaee4a550","date":1432028057,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long).mjava","sourceNew":null,"sourceOld":"  /**\n  * Construct an Elias-Fano encoder using {@link #DEFAULT_INDEX_INTERVAL}.\n  */\n  public EliasFanoEncoder(long numValues, long upperBound) {\n    this(numValues, upperBound, DEFAULT_INDEX_INTERVAL);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"556259cdb46d4f7fb27f4688c4efcb3eaee4a550":["423470dff9e19aa0db92590e282e2ca12e34d65a"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7581da3051efe8071ae92ac7eca27a270bc4611e"],"21d517f3b4989fcd30eda0cad105d5fdcaeb5d7c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"423470dff9e19aa0db92590e282e2ca12e34d65a":["7581da3051efe8071ae92ac7eca27a270bc4611e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7581da3051efe8071ae92ac7eca27a270bc4611e":["21d517f3b4989fcd30eda0cad105d5fdcaeb5d7c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["556259cdb46d4f7fb27f4688c4efcb3eaee4a550"]},"commit2Childs":{"556259cdb46d4f7fb27f4688c4efcb3eaee4a550":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"21d517f3b4989fcd30eda0cad105d5fdcaeb5d7c":["7581da3051efe8071ae92ac7eca27a270bc4611e"],"423470dff9e19aa0db92590e282e2ca12e34d65a":["556259cdb46d4f7fb27f4688c4efcb3eaee4a550"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","21d517f3b4989fcd30eda0cad105d5fdcaeb5d7c"],"7581da3051efe8071ae92ac7eca27a270bc4611e":["37a0f60745e53927c4c876cfe5b5a58170f0646c","423470dff9e19aa0db92590e282e2ca12e34d65a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}