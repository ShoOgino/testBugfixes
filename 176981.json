{"path":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","commits":[{"id":"eca6c16577c72bb12bfca3a7717d968c85ea729c","date":1486164338,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"AnalyzingInfixSuggesterTest\");\n    try {\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> \n          expectThrows(RuntimeException.class, SolrCoreState.CoreIsClosedException.class,\n              () -> assertQ(req(\"qt\", rh_analyzing_long,\n                  SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n                  \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3def6097490d483908343e95c16631f2580e2489","date":1533005389,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","sourceNew":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"AnalyzingInfixSuggesterTest\");\n    try {\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> \n          expectThrows(RuntimeException.class, SolrCoreState.CoreIsClosedException.class,\n              () -> assertQ(req(\"qt\", rh_analyzing_long,\n                  SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n                  \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e44eeeeb71d76b75cba9ba49f866a9c75a67a18","date":1544540322,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","sourceNew":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class, NullPointerException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e0abaca9e5481b5c3660805111683e8ce53bef3","date":1544554124,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","sourceNew":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class, NullPointerException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/InfixSuggestersTest#testShutdownDuringBuild().mjava","sourceNew":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class, NullPointerException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      @SuppressWarnings({\"rawtypes\"})\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testShutdownDuringBuild() throws Exception {\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"InfixSuggesterTest\");\n    try {\n      LinkedHashMap<Class<? extends Throwable>, List<Class<? extends Throwable>>> expected = new LinkedHashMap<>();\n      expected.put(RuntimeException.class, Arrays.asList\n          (SolrCoreState.CoreIsClosedException.class, SolrException.class, IllegalStateException.class, NullPointerException.class));\n      final Throwable[] outerException = new Throwable[1];\n      // Build the suggester in the background with a long dictionary\n      Future job = executor.submit(() -> outerException[0] = expectThrowsAnyOf(expected,\n          () -> assertQ(req(\"qt\", rh_analyzing_long, SuggesterParams.SUGGEST_BUILD_ALL, \"true\"),\n              \"//str[@name='command'][.='buildAll']\")));\n      Thread.sleep(100); // TODO: is there a better way to ensure that the build has begun?\n      h.close();\n      // Stop the dictionary's input iterator\n      System.clearProperty(RandomTestDictionaryFactory.RandomTestDictionary\n          .getEnabledSysProp(\"longRandomAnalyzingInfixSuggester\"));\n      job.get();\n      Throwable wrappedException = outerException[0].getCause();\n      if (wrappedException instanceof SolrException) {\n        String expectedMessage = \"SolrCoreState already closed.\";\n        assertTrue(\"Expected wrapped SolrException message to contain '\" + expectedMessage \n            + \"' but message is '\" + wrappedException.getMessage() + \"'\", \n            wrappedException.getMessage().contains(expectedMessage));\n      } else if (wrappedException instanceof IllegalStateException\n          && ! (wrappedException instanceof SolrCoreState.CoreIsClosedException)) { // CoreIsClosedException extends IllegalStateException\n        String expectedMessage = \"Cannot commit on an closed writer. Add documents first\";\n        assertTrue(\"Expected wrapped IllegalStateException message to contain '\" + expectedMessage\n                + \"' but message is '\" + wrappedException.getMessage() + \"'\",\n            wrappedException.getMessage().contains(expectedMessage));\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n      initCore(\"solrconfig-infixsuggesters.xml\",\"schema.xml\"); // put the core back for other tests\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eca6c16577c72bb12bfca3a7717d968c85ea729c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5e44eeeeb71d76b75cba9ba49f866a9c75a67a18":["3def6097490d483908343e95c16631f2580e2489"],"7e0abaca9e5481b5c3660805111683e8ce53bef3":["3def6097490d483908343e95c16631f2580e2489","5e44eeeeb71d76b75cba9ba49f866a9c75a67a18"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["7e0abaca9e5481b5c3660805111683e8ce53bef3"],"3def6097490d483908343e95c16631f2580e2489":["eca6c16577c72bb12bfca3a7717d968c85ea729c"]},"commit2Childs":{"eca6c16577c72bb12bfca3a7717d968c85ea729c":["3def6097490d483908343e95c16631f2580e2489"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eca6c16577c72bb12bfca3a7717d968c85ea729c"],"5e44eeeeb71d76b75cba9ba49f866a9c75a67a18":["7e0abaca9e5481b5c3660805111683e8ce53bef3"],"7e0abaca9e5481b5c3660805111683e8ce53bef3":["e98520789adb1d5ad05afb4956eca0944a929688"],"3def6097490d483908343e95c16631f2580e2489":["5e44eeeeb71d76b75cba9ba49f866a9c75a67a18","7e0abaca9e5481b5c3660805111683e8ce53bef3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}