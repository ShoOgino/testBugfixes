{"path":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    indexr(id, 1, i1, 100, tlong, 100, t1, \"now is the time for all good men\",\n        \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    \n    // make sure we are in a steady state...\n    waitForRecoveriesToFinish(false);\n    \n    commit();\n    \n    assertDocCounts(false);\n    \n    indexAbunchOfDocs();\n    \n    commit();\n    \n    assertDocCounts(VERBOSE);\n    checkQueries();\n    \n    assertDocCounts(VERBOSE);\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    brindDownShardIndexSomeDocsAndRecover();\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // test adding another replica to a shard - it should do a\n    // recovery/replication to pick up the index from the leader\n    addNewReplica();\n    \n    long docId = testUpdateAndDelete();\n    \n    // index a bad doc...\n    try {\n      indexr(t1, \"a doc with no id\");\n      fail(\"this should fail\");\n    } catch (SolrException e) {\n      // expected\n    }\n    \n    // TODO: bring this to it's own method?\n    // try indexing to a leader that has no replicas up\n    ZkNodeProps leaderProps = zkStateReader.getLeaderProps(DEFAULT_COLLECTION,\n        SHARD2);\n    \n    String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n    chaosMonkey.stopShardExcept(SHARD2, nodeName);\n    \n    SolrServer client = getClient(nodeName);\n    \n    index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n    \n    // expire a session...\n    CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n    chaosMonkey.expireSession(cloudJetty.jetty);\n    \n    indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n    \n    waitForRecoveriesToFinish(false);\n    \n    checkShardConsistency(\"shard1\");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    indexr(id, 1, i1, 100, tlong, 100, t1, \"now is the time for all good men\",\n        \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    \n    // make sure we are in a steady state...\n    waitForRecoveriesToFinish(false);\n    \n    commit();\n    \n    assertDocCounts(false);\n    \n    indexAbunchOfDocs();\n    \n    commit();\n    \n    assertDocCounts(VERBOSE);\n    checkQueries();\n    \n    assertDocCounts(VERBOSE);\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    brindDownShardIndexSomeDocsAndRecover();\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // test adding another replica to a shard - it should do a\n    // recovery/replication to pick up the index from the leader\n    addNewReplica();\n    \n    long docId = testUpdateAndDelete();\n    \n    // index a bad doc...\n    try {\n      indexr(t1, \"a doc with no id\");\n      fail(\"this should fail\");\n    } catch (SolrException e) {\n      // expected\n    }\n    \n    // TODO: bring this to it's own method?\n    // try indexing to a leader that has no replicas up\n    ZkNodeProps leaderProps = zkStateReader.getLeaderProps(DEFAULT_COLLECTION,\n        SHARD2);\n    \n    String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n    chaosMonkey.stopShardExcept(SHARD2, nodeName);\n    \n    SolrServer client = getClient(nodeName);\n    \n    index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n    \n    // expire a session...\n    CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n    chaosMonkey.expireSession(cloudJetty.jetty);\n    \n    indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n    \n    waitForRecoveriesToFinish(false);\n    \n    checkShardConsistency(\"shard1\");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    indexr(id, 1, i1, 100, tlong, 100, t1, \"now is the time for all good men\",\n        \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    \n    // make sure we are in a steady state...\n    waitForRecoveriesToFinish(false);\n    \n    commit();\n    \n    assertDocCounts(false);\n    \n    indexAbunchOfDocs();\n    \n    commit();\n    \n    assertDocCounts(VERBOSE);\n    checkQueries();\n    \n    assertDocCounts(VERBOSE);\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    brindDownShardIndexSomeDocsAndRecover();\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // test adding another replica to a shard - it should do a\n    // recovery/replication to pick up the index from the leader\n    addNewReplica();\n    \n    long docId = testUpdateAndDelete();\n    \n    // index a bad doc...\n    try {\n      indexr(t1, \"a doc with no id\");\n      fail(\"this should fail\");\n    } catch (SolrException e) {\n      // expected\n    }\n    \n    // TODO: bring this to it's own method?\n    // try indexing to a leader that has no replicas up\n    ZkNodeProps leaderProps = zkStateReader.getLeaderProps(DEFAULT_COLLECTION,\n        SHARD2);\n    \n    String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n    chaosMonkey.stopShardExcept(SHARD2, nodeName);\n    \n    SolrServer client = getClient(nodeName);\n    \n    index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n    \n    // expire a session...\n    CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n    chaosMonkey.expireSession(cloudJetty.jetty);\n    \n    indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n    \n    waitForRecoveriesToFinish(false);\n    \n    checkShardConsistency(\"shard1\");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be948e374a439077071179ec3f2edaa547064514","date":1327536385,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayout();\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    indexr(id, 1, i1, 100, tlong, 100, t1, \"now is the time for all good men\",\n        \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    \n    // make sure we are in a steady state...\n    waitForRecoveriesToFinish(false);\n    \n    commit();\n    \n    assertDocCounts(false);\n    \n    indexAbunchOfDocs();\n    \n    commit();\n    \n    assertDocCounts(VERBOSE);\n    checkQueries();\n    \n    assertDocCounts(VERBOSE);\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    brindDownShardIndexSomeDocsAndRecover();\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // test adding another replica to a shard - it should do a\n    // recovery/replication to pick up the index from the leader\n    addNewReplica();\n    \n    long docId = testUpdateAndDelete();\n    \n    // index a bad doc...\n    try {\n      indexr(t1, \"a doc with no id\");\n      fail(\"this should fail\");\n    } catch (SolrException e) {\n      // expected\n    }\n    \n    // TODO: bring this to it's own method?\n    // try indexing to a leader that has no replicas up\n    ZkNodeProps leaderProps = zkStateReader.getLeaderProps(DEFAULT_COLLECTION,\n        SHARD2);\n    \n    String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n    chaosMonkey.stopShardExcept(SHARD2, nodeName);\n    \n    SolrServer client = getClient(nodeName);\n    \n    index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n    \n    // expire a session...\n    CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n    chaosMonkey.expireSession(cloudJetty.jetty);\n    \n    indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n    \n    waitForRecoveriesToFinish(false);\n    \n    checkShardConsistency(\"shard1\");\n    \n  }\n\n","bugFix":null,"bugIntro":["072f211dfa8387028bb978d128c35bf9a450bbbf","072f211dfa8387028bb978d128c35bf9a450bbbf","072f211dfa8387028bb978d128c35bf9a450bbbf","1525b4dfbc0d413b8d7247da232009778e624836","1525b4dfbc0d413b8d7247da232009778e624836","1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7cf464adc9721589a2872247d15442e59766e791","date":1327607202,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayout();\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    indexr(id, 1, i1, 100, tlong, 100, t1, \"now is the time for all good men\",\n        \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    \n    // make sure we are in a steady state...\n    waitForRecoveriesToFinish(false);\n    \n    commit();\n    \n    assertDocCounts(false);\n    \n    indexAbunchOfDocs();\n    \n    commit();\n    \n    assertDocCounts(VERBOSE);\n    checkQueries();\n    \n    assertDocCounts(VERBOSE);\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    brindDownShardIndexSomeDocsAndRecover();\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // test adding another replica to a shard - it should do a\n    // recovery/replication to pick up the index from the leader\n    addNewReplica();\n    \n    long docId = testUpdateAndDelete();\n    \n    // index a bad doc...\n    try {\n      indexr(t1, \"a doc with no id\");\n      fail(\"this should fail\");\n    } catch (SolrException e) {\n      // expected\n    }\n    \n    // TODO: bring this to it's own method?\n    // try indexing to a leader that has no replicas up\n    ZkNodeProps leaderProps = zkStateReader.getLeaderProps(DEFAULT_COLLECTION,\n        SHARD2);\n    \n    String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n    chaosMonkey.stopShardExcept(SHARD2, nodeName);\n    \n    SolrServer client = getClient(nodeName);\n    \n    index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n    \n    // expire a session...\n    CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n    chaosMonkey.expireSession(cloudJetty.jetty);\n    \n    indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n    \n    waitForRecoveriesToFinish(false);\n    \n    checkShardConsistency(\"shard1\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    indexr(id, 1, i1, 100, tlong, 100, t1, \"now is the time for all good men\",\n        \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    \n    // make sure we are in a steady state...\n    waitForRecoveriesToFinish(false);\n    \n    commit();\n    \n    assertDocCounts(false);\n    \n    indexAbunchOfDocs();\n    \n    commit();\n    \n    assertDocCounts(VERBOSE);\n    checkQueries();\n    \n    assertDocCounts(VERBOSE);\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    brindDownShardIndexSomeDocsAndRecover();\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // test adding another replica to a shard - it should do a\n    // recovery/replication to pick up the index from the leader\n    addNewReplica();\n    \n    long docId = testUpdateAndDelete();\n    \n    // index a bad doc...\n    try {\n      indexr(t1, \"a doc with no id\");\n      fail(\"this should fail\");\n    } catch (SolrException e) {\n      // expected\n    }\n    \n    // TODO: bring this to it's own method?\n    // try indexing to a leader that has no replicas up\n    ZkNodeProps leaderProps = zkStateReader.getLeaderProps(DEFAULT_COLLECTION,\n        SHARD2);\n    \n    String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n    chaosMonkey.stopShardExcept(SHARD2, nodeName);\n    \n    SolrServer client = getClient(nodeName);\n    \n    index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n    \n    // expire a session...\n    CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n    chaosMonkey.expireSession(cloudJetty.jetty);\n    \n    indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n    \n    waitForRecoveriesToFinish(false);\n    \n    checkShardConsistency(\"shard1\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e231a1df000b2ffc6a146812b1ff40d3617dfdcb","date":1343000701,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZk2Test#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":5,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZk2Test#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZk2Test#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#doTest().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.BaseDistributedSearchTestCase#doTest()\n   * \n   * Create 3 shards, each with one replica\n   */\n  @Override\n  public void doTest() throws Exception {\n    boolean testFinished = false;\n    try {\n      handle.clear();\n      handle.put(\"QTime\", SKIPVAL);\n      handle.put(\"timestamp\", SKIPVAL);\n      \n      indexr(id, 1, i1, 100, tlong, 100, t1,\n          \"now is the time for all good men\", \"foo_f\", 1.414f, \"foo_b\", \"true\",\n          \"foo_d\", 1.414d);\n      \n      // make sure we are in a steady state...\n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(false);\n      \n      indexAbunchOfDocs();\n      \n      // check again \n      waitForRecoveriesToFinish(false);\n      \n      commit();\n      \n      assertDocCounts(VERBOSE);\n      checkQueries();\n      \n      assertDocCounts(VERBOSE);\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      brindDownShardIndexSomeDocsAndRecover();\n      \n      query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n      \n      // test adding another replica to a shard - it should do a\n      // recovery/replication to pick up the index from the leader\n      addNewReplica();\n      \n      long docId = testUpdateAndDelete();\n      \n      // index a bad doc...\n      try {\n        indexr(t1, \"a doc with no id\");\n        fail(\"this should fail\");\n      } catch (SolrException e) {\n        // expected\n      }\n      \n      // TODO: bring this to it's own method?\n      // try indexing to a leader that has no replicas up\n      ZkNodeProps leaderProps = zkStateReader.getLeaderProps(\n          DEFAULT_COLLECTION, SHARD2);\n      \n      String nodeName = leaderProps.get(ZkStateReader.NODE_NAME_PROP);\n      chaosMonkey.stopShardExcept(SHARD2, nodeName);\n      \n      SolrServer client = getClient(nodeName);\n      \n      index_specific(client, \"id\", docId + 1, t1, \"what happens here?\");\n      \n      // expire a session...\n      CloudJettyRunner cloudJetty = shardToJetty.get(\"shard1\").get(0);\n      chaosMonkey.expireSession(cloudJetty.jetty);\n      \n      indexr(\"id\", docId + 1, t1, \"slip this doc in\");\n      \n      waitForRecoveriesToFinish(false);\n      \n      checkShardConsistency(\"shard1\");\n      \n      testFinished = true;\n    } finally {\n      if (!testFinished) {\n        printLayoutOnTearDown = true;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","7cf464adc9721589a2872247d15442e59766e791"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","7cf464adc9721589a2872247d15442e59766e791"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","2c30e4c1cee08b3b229a77991882594fe7250b66"],"aba371508186796cc6151d8223a5b4e16d02e26e":["7cf464adc9721589a2872247d15442e59766e791","e231a1df000b2ffc6a146812b1ff40d3617dfdcb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","2c30e4c1cee08b3b229a77991882594fe7250b66"],"be948e374a439077071179ec3f2edaa547064514":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e231a1df000b2ffc6a146812b1ff40d3617dfdcb":["7cf464adc9721589a2872247d15442e59766e791"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["7cf464adc9721589a2872247d15442e59766e791","e231a1df000b2ffc6a146812b1ff40d3617dfdcb"],"7cf464adc9721589a2872247d15442e59766e791":["be948e374a439077071179ec3f2edaa547064514"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["e231a1df000b2ffc6a146812b1ff40d3617dfdcb"]},"commit2Childs":{"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","be948e374a439077071179ec3f2edaa547064514"],"be948e374a439077071179ec3f2edaa547064514":["7cf464adc9721589a2872247d15442e59766e791"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"e231a1df000b2ffc6a146812b1ff40d3617dfdcb":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","2c30e4c1cee08b3b229a77991882594fe7250b66"],"7cf464adc9721589a2872247d15442e59766e791":["78a55f24d9b493c2a1cecf79f1d78279062b545b","fd92b8bcc88e969302510acf77bd6970da3994c4","aba371508186796cc6151d8223a5b4e16d02e26e","e231a1df000b2ffc6a146812b1ff40d3617dfdcb","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["78a55f24d9b493c2a1cecf79f1d78279062b545b","fd92b8bcc88e969302510acf77bd6970da3994c4","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}