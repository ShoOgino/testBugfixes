{"path":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","commits":[{"id":"d2b26522f870cd9ff2faccbc2a5e1f9019366c98","date":1399316087,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","pathOld":"/dev/null","sourceNew":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio >= 0.9 && ratio <= 1.1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b47eb0aafc8f053650b3bf3b8a5a9e1758935045","date":1399386417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","sourceNew":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n\n    // Only enforce that it wasn't too fast; if machine is bogged down (can't schedule threads / sleep properly) then it may falsely be too slow:\n    //assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio >= 0.9 && ratio <= 1.1);\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio <= 1.1);\n  }\n\n","sourceOld":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio >= 0.9 && ratio <= 1.1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4df3d75523b0f9eb44c74ea0b5b44dbe78a89f6","date":1459963137,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","sourceNew":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n\n    // Only enforce that it wasn't too fast; if machine is bogged down (can't schedule threads / sleep properly) then it may falsely be too slow:\n    assumeTrue(\"actualMBPerSec=\" + actualMBPerSec + \" targetMBPerSec=\" + targetMBPerSec, 0.9 <= ratio);\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio <= 1.1);\n  }\n\n","sourceOld":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n\n    // Only enforce that it wasn't too fast; if machine is bogged down (can't schedule threads / sleep properly) then it may falsely be too slow:\n    //assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio >= 0.9 && ratio <= 1.1);\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio <= 1.1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestRateLimiter#testThreads().mjava","sourceNew":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n\n    // Only enforce that it wasn't too fast; if machine is bogged down (can't schedule threads / sleep properly) then it may falsely be too slow:\n    assumeTrue(\"actualMBPerSec=\" + actualMBPerSec + \" targetMBPerSec=\" + targetMBPerSec, 0.9 <= ratio);\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio <= 1.1);\n  }\n\n","sourceOld":"  public void testThreads() throws Exception {\n\n    double targetMBPerSec = 10.0 + 20 * random().nextDouble();\n    final SimpleRateLimiter limiter = new SimpleRateLimiter(targetMBPerSec);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 3, 6)];\n    final AtomicLong totBytes = new AtomicLong();\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n            long bytesSinceLastPause = 0;\n            for(int i=0;i<500;i++) {\n              long numBytes = TestUtil.nextInt(random(), 1000, 10000);\n              totBytes.addAndGet(numBytes);\n              bytesSinceLastPause += numBytes;\n              if (bytesSinceLastPause > limiter.getMinPauseCheckBytes()) {\n                limiter.pause(bytesSinceLastPause);\n                bytesSinceLastPause = 0;\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    long startNS = System.nanoTime();\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    long endNS = System.nanoTime();\n    double actualMBPerSec = (totBytes.get()/1024/1024.)/((endNS-startNS)/1000000000.0);\n\n    // TODO: this may false trip .... could be we can only assert that it never exceeds the max, so slow jenkins doesn't trip:\n    double ratio = actualMBPerSec/targetMBPerSec;\n\n    // Only enforce that it wasn't too fast; if machine is bogged down (can't schedule threads / sleep properly) then it may falsely be too slow:\n    //assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio >= 0.9 && ratio <= 1.1);\n    assertTrue(\"targetMBPerSec=\" + targetMBPerSec + \" actualMBPerSec=\" + actualMBPerSec, ratio <= 1.1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b47eb0aafc8f053650b3bf3b8a5a9e1758935045":["d2b26522f870cd9ff2faccbc2a5e1f9019366c98"],"d2b26522f870cd9ff2faccbc2a5e1f9019366c98":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b6284684320a9808c41a5e43de958b2da22f89bd":["b47eb0aafc8f053650b3bf3b8a5a9e1758935045","a4df3d75523b0f9eb44c74ea0b5b44dbe78a89f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a4df3d75523b0f9eb44c74ea0b5b44dbe78a89f6":["b47eb0aafc8f053650b3bf3b8a5a9e1758935045"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6284684320a9808c41a5e43de958b2da22f89bd"]},"commit2Childs":{"b47eb0aafc8f053650b3bf3b8a5a9e1758935045":["b6284684320a9808c41a5e43de958b2da22f89bd","a4df3d75523b0f9eb44c74ea0b5b44dbe78a89f6"],"d2b26522f870cd9ff2faccbc2a5e1f9019366c98":["b47eb0aafc8f053650b3bf3b8a5a9e1758935045"],"b6284684320a9808c41a5e43de958b2da22f89bd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2b26522f870cd9ff2faccbc2a5e1f9019366c98"],"a4df3d75523b0f9eb44c74ea0b5b44dbe78a89f6":["b6284684320a9808c41a5e43de958b2da22f89bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}