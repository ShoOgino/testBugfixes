{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","commits":[{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,String,String,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            String min,\n                                            String max,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if(max != null) {\n        if(max.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(max).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(max, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      if(min != null) {\n        if(min.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(min).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(min, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (min != null || max != null) {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n\n      } else {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if(collapseFieldType instanceof TrieIntField ||\n                  collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getLeafReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getLeafReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e07c409cff8701e4dc3d45934b021a949a5a8822","date":1475694629,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getLeafReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ea826cad27aae1c1287b70d2eaf0202ec6aa754","date":1490169633,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n              if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if(isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa09e86cb64347ee96ff0a59f09b539abd620e57","date":1490280013,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n              if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if(isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d048016075a0b8589fcfc77fdf8e2a29fc80964","date":1494631326,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n              if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if(isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n              if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if(isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          if (collapseFieldType instanceof TrieFloatField || collapseFieldType instanceof FloatPointField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f15af35d55d70c34451f9df5edeaeff6b31f8cbe","date":1519625627,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          @SuppressWarnings(\"resource\") final UninvertingReader uninvertingReader =\n              new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a07eeba66d4090af0095b50cbd1795a3d6182c1d","date":1538797239,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n          /*\n          * This hint forces the use of the top level field cache for String fields.\n          * This is VERY fast at query time but slower to warm and causes insanity.\n          */\n          @SuppressWarnings(\"resource\") final LeafReader uninvertingReader = UninvertingReader.wrap(\n                  new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField),\n                  Collections.singletonMap(collapseField, UninvertingReader.Type.SORTED)::get);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          @SuppressWarnings(\"resource\") final UninvertingReader uninvertingReader =\n              new UninvertingReader(new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField), mapping);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7bc10aeb596994a4cbfa5801932a4dac9fdd2afc","date":1541533532,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n          /*\n          * This hint forces the use of the top level field cache for String fields.\n          * This is VERY fast at query time but slower to warm and causes insanity.\n          */\n          @SuppressWarnings(\"resource\") final LeafReader uninvertingReader = UninvertingReader.wrap(\n                  new ReaderWrapper(searcher.getSlowAtomicReader(), collapseField),\n                  Collections.singletonMap(collapseField, UninvertingReader.Type.SORTED)::get);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":["8ced52befdc8d88d90766aadbaac496f3fd0e4ee","a07eeba66d4090af0095b50cbd1795a3d6182c1d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3","date":1556831715,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4d048016075a0b8589fcfc77fdf8e2a29fc80964":["5ea826cad27aae1c1287b70d2eaf0202ec6aa754"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc"],"e07c409cff8701e4dc3d45934b021a949a5a8822":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0325de99180d346d61d36938843a5c8451fe26ae","e07c409cff8701e4dc3d45934b021a949a5a8822"],"7bc10aeb596994a4cbfa5801932a4dac9fdd2afc":["a07eeba66d4090af0095b50cbd1795a3d6182c1d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fa09e86cb64347ee96ff0a59f09b539abd620e57","4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["0325de99180d346d61d36938843a5c8451fe26ae","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["0325de99180d346d61d36938843a5c8451fe26ae"],"fa09e86cb64347ee96ff0a59f09b539abd620e57":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"a07eeba66d4090af0095b50cbd1795a3d6182c1d":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"0325de99180d346d61d36938843a5c8451fe26ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"5ea826cad27aae1c1287b70d2eaf0202ec6aa754":["e07c409cff8701e4dc3d45934b021a949a5a8822"]},"commit2Childs":{"4d048016075a0b8589fcfc77fdf8e2a29fc80964":["e9017cf144952056066919f1ebc7897ff9bd71b1","f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e07c409cff8701e4dc3d45934b021a949a5a8822":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fa09e86cb64347ee96ff0a59f09b539abd620e57","5ea826cad27aae1c1287b70d2eaf0202ec6aa754"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"7bc10aeb596994a4cbfa5801932a4dac9fdd2afc":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0325de99180d346d61d36938843a5c8451fe26ae"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"fa09e86cb64347ee96ff0a59f09b539abd620e57":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"a07eeba66d4090af0095b50cbd1795a3d6182c1d":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["a07eeba66d4090af0095b50cbd1795a3d6182c1d"],"0325de99180d346d61d36938843a5c8451fe26ae":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"5ea826cad27aae1c1287b70d2eaf0202ec6aa754":["4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}