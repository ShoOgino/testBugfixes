{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(Bits,QueryState,int).mjava","commits":[{"id":"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96","date":1433340999,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(Bits,QueryState,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(Bits acceptDocs, QueryState state, int nodeID) throws IOException {\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      if (state.latLonFilter != null) {\n        // Handle this differently since we must also look up lat/lon:\n\n        int hitCount = 0;\n        for(int i=0;i<count;i++) {\n\n          int docID = state.in.readInt();\n          \n          if (acceptDocs == null || acceptDocs.get(docID)) {\n\n            state.sndv.setDocument(docID);\n\n            // How many values this doc has:\n            int docValueCount = state.sndv.count();\n            for(int j=0;j<docValueCount;j++) {\n              long enc = state.sndv.valueAt(j);\n              int latEnc = (int) ((enc>>32) & 0xffffffffL);\n              int lonEnc = (int) (enc & 0xffffffffL);\n\n              // TODO: maybe we can fix LatLonFilter to operate on encoded forms?\n              if (state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc))) {\n                state.bits.set(docID);\n                hitCount++;\n\n                // Stop processing values for this doc since it's now accepted:\n                break;\n              }\n            }\n          }\n        }\n\n        return hitCount;\n\n      } else if (acceptDocs != null) {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          if (acceptDocs.get(docID)) {\n            state.bits.set(docID);\n          }\n        }\n      } else {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          state.bits.set(docID);\n        }\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = 0;\n      count += addAll(acceptDocs, state, 2*nodeID);\n      count += addAll(acceptDocs, state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"087ab61b67c554befcfe6f666ca3bb613eac8fe3","date":1433956986,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(Bits,QueryState,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(Bits,QueryState,int).mjava","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(Bits acceptDocs, QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      if (acceptDocs != null) {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          if (acceptDocs.get(docID)) {\n            state.bits.set(docID);\n          }\n        }\n      } else {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          state.bits.set(docID);\n        }\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(acceptDocs, state, 2*nodeID);\n      count += addAll(acceptDocs, state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(Bits acceptDocs, QueryState state, int nodeID) throws IOException {\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      if (state.latLonFilter != null) {\n        // Handle this differently since we must also look up lat/lon:\n\n        int hitCount = 0;\n        for(int i=0;i<count;i++) {\n\n          int docID = state.in.readInt();\n          \n          if (acceptDocs == null || acceptDocs.get(docID)) {\n\n            state.sndv.setDocument(docID);\n\n            // How many values this doc has:\n            int docValueCount = state.sndv.count();\n            for(int j=0;j<docValueCount;j++) {\n              long enc = state.sndv.valueAt(j);\n              int latEnc = (int) ((enc>>32) & 0xffffffffL);\n              int lonEnc = (int) (enc & 0xffffffffL);\n\n              // TODO: maybe we can fix LatLonFilter to operate on encoded forms?\n              if (state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc))) {\n                state.bits.set(docID);\n                hitCount++;\n\n                // Stop processing values for this doc since it's now accepted:\n                break;\n              }\n            }\n          }\n        }\n\n        return hitCount;\n\n      } else if (acceptDocs != null) {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          if (acceptDocs.get(docID)) {\n            state.bits.set(docID);\n          }\n        }\n      } else {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          state.bits.set(docID);\n        }\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = 0;\n      count += addAll(acceptDocs, state, 2*nodeID);\n      count += addAll(acceptDocs, state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(Bits,QueryState,int).mjava","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.bits.set(docID);\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(Bits acceptDocs, QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      if (acceptDocs != null) {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          if (acceptDocs.get(docID)) {\n            state.bits.set(docID);\n          }\n        }\n      } else {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          state.bits.set(docID);\n        }\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(acceptDocs, state, 2*nodeID);\n      count += addAll(acceptDocs, state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["087ab61b67c554befcfe6f666ca3bb613eac8fe3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"087ab61b67c554befcfe6f666ca3bb613eac8fe3":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"087ab61b67c554befcfe6f666ca3bb613eac8fe3":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["087ab61b67c554befcfe6f666ca3bb613eac8fe3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}