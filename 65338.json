{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","commits":[{"id":"02c6a0e240c698414e7728a55f07361be84852d8","date":1392675457,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    \n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = compareResults(controlDocs, cloudClientDocs, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4339eef0c1b12030c8590187e652cd1cd0a1f3cb","date":1397833225,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    \n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    \n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = compareResults(controlDocs, cloudClientDocs, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    \n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    \n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    \n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3d9a2e4ec5db2bc6cc023d9a1fd387ceb5b69b5","date":1498283633,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, coreClients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, coreClients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean,Set[String],Set[String]).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, coreClients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose, Set<String> addFails, Set<String> deleteFails)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n\n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n\n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrClient client = cjetty.client.solrClient;\n          boolean active = Replica.State.getState(props.getStr(ZkStateReader.STATE_PROP)) == Replica.State.ACTIVE;\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient, addFails, deleteFails);\n      if (shouldFail) {\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a219f1dcad1700e84807666bdbd2b573e8de7021":["abb23fcc2461782ab204e61213240feb77d355aa"],"c3d9a2e4ec5db2bc6cc023d9a1fd387ceb5b69b5":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"abb23fcc2461782ab204e61213240feb77d355aa":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["4339eef0c1b12030c8590187e652cd1cd0a1f3cb"],"4339eef0c1b12030c8590187e652cd1cd0a1f3cb":["02c6a0e240c698414e7728a55f07361be84852d8"],"02c6a0e240c698414e7728a55f07361be84852d8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a219f1dcad1700e84807666bdbd2b573e8de7021","c3d9a2e4ec5db2bc6cc023d9a1fd387ceb5b69b5"],"28288370235ed02234a64753cdbf0c6ec096304a":["a219f1dcad1700e84807666bdbd2b573e8de7021","c3d9a2e4ec5db2bc6cc023d9a1fd387ceb5b69b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"a219f1dcad1700e84807666bdbd2b573e8de7021":["c3d9a2e4ec5db2bc6cc023d9a1fd387ceb5b69b5","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c3d9a2e4ec5db2bc6cc023d9a1fd387ceb5b69b5":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"abb23fcc2461782ab204e61213240feb77d355aa":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["02c6a0e240c698414e7728a55f07361be84852d8"],"bafca15d8e408346a67f4282ad1143b88023893b":["abb23fcc2461782ab204e61213240feb77d355aa"],"4339eef0c1b12030c8590187e652cd1cd0a1f3cb":["bafca15d8e408346a67f4282ad1143b88023893b"],"02c6a0e240c698414e7728a55f07361be84852d8":["4339eef0c1b12030c8590187e652cd1cd0a1f3cb"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}