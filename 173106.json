{"path":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","commits":[{"id":"cb9af919a17be70cfc512901fc70f1beaf840ca1","date":1413208885,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[Operation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations){\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout >0  ? System.nanoTime()+ (timeout * 1000*1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for(;System.nanoTime() < endTime ;) {\n      managedIndexSchema = (ManagedIndexSchema) core.getLatestSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n\n      try {\n        managedIndexSchema.persistManagedSchema(false);\n        core.setLatestSchema(managedIndexSchema);\n        waitForOtherReplicasToUpdate(timeout, startTime);\n        return EMPTY_LIST;\n      } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n        String s = \"Failed to update schema because schema is modified\";\n        log.warn(s, e);\n        continue;\n      } catch (Exception e){\n        String s = \"Exception persisting schema\";\n        log.warn(s, e);\n        return singletonList(s + e.getMessage());\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","sourceOld":"  private List<String> doOperations(List<Operation> operations){\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout >0  ? System.nanoTime()+ (timeout * 1000*1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for(;System.nanoTime() < endTime ;) {\n      managedIndexSchema = (ManagedIndexSchema) core.getLatestSchema();\n      for (Operation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n\n      try {\n        managedIndexSchema.persistManagedSchema(false);\n        core.setLatestSchema(managedIndexSchema);\n        waitForOtherReplicasToUpdate(timeout, startTime);\n        return EMPTY_LIST;\n      } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n        String s = \"Failed to update schema because schema is modified\";\n        log.warn(s, e);\n        continue;\n      } catch (Exception e){\n        String s = \"Exception persisting schema\";\n        log.warn(s, e);\n        return singletonList(s + e.getMessage());\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[Operation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations){\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout >0  ? System.nanoTime()+ (timeout * 1000*1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for(;System.nanoTime() < endTime ;) {\n      managedIndexSchema = (ManagedIndexSchema) core.getLatestSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n\n      try {\n        managedIndexSchema.persistManagedSchema(false);\n        core.setLatestSchema(managedIndexSchema);\n        waitForOtherReplicasToUpdate(timeout, startTime);\n        return EMPTY_LIST;\n      } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n        String s = \"Failed to update schema because schema is modified\";\n        log.warn(s, e);\n        continue;\n      } catch (Exception e){\n        String s = \"Exception persisting schema\";\n        log.warn(s, e);\n        return singletonList(s + e.getMessage());\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","sourceOld":"  private List<String> doOperations(List<Operation> operations){\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout >0  ? System.nanoTime()+ (timeout * 1000*1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for(;System.nanoTime() < endTime ;) {\n      managedIndexSchema = (ManagedIndexSchema) core.getLatestSchema();\n      for (Operation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n\n      try {\n        managedIndexSchema.persistManagedSchema(false);\n        core.setLatestSchema(managedIndexSchema);\n        waitForOtherReplicasToUpdate(timeout, startTime);\n        return EMPTY_LIST;\n      } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n        String s = \"Failed to update schema because schema is modified\";\n        log.warn(s, e);\n        continue;\n      } catch (Exception e){\n        String s = \"Exception persisting schema\";\n        log.warn(s, e);\n        return singletonList(s + e.getMessage());\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d72e80cee24be385c713864a9f1f90be3744482","date":1417420925,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for (; System.nanoTime() < endTime; ) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(loader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return EMPTY_LIST;\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n\n      }else {\n\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return EMPTY_LIST;\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations){\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout >0  ? System.nanoTime()+ (timeout * 1000*1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for(;System.nanoTime() < endTime ;) {\n      managedIndexSchema = (ManagedIndexSchema) core.getLatestSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n\n      try {\n        managedIndexSchema.persistManagedSchema(false);\n        core.setLatestSchema(managedIndexSchema);\n        waitForOtherReplicasToUpdate(timeout, startTime);\n        return EMPTY_LIST;\n      } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n        String s = \"Failed to update schema because schema is modified\";\n        log.warn(s, e);\n        continue;\n      } catch (Exception e){\n        String s = \"Exception persisting schema\";\n        log.warn(s, e);\n        return singletonList(s + e.getMessage());\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","bugFix":null,"bugIntro":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45a5f13e4e6b3c60912dc0911227739fe2f371c2","date":1420449490,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for (; System.nanoTime() < endTime; ) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return EMPTY_LIST;\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n\n      }else {\n\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return EMPTY_LIST;\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for (; System.nanoTime() < endTime; ) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(loader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return EMPTY_LIST;\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n\n      }else {\n\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return EMPTY_LIST;\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","bugFix":null,"bugIntro":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeeea2295d6355a29e259130a5c48ace73022d7c","date":1426569216,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    while (System.nanoTime() < endTime) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return Collections.emptyList();\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n    return singletonList(\"Unable to persist schema\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for (; System.nanoTime() < endTime; ) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return EMPTY_LIST;\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n\n      }else {\n\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return EMPTY_LIST;\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","bugFix":null,"bugIntro":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    while (System.nanoTime() < endTime) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return Collections.emptyList();\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n    return singletonList(\"Unable to persist schema\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    for (; System.nanoTime() < endTime; ) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        if (ADD_FIELD.equals(op.name) || ADD_DYNAMIC_FIELD.equals(op.name)) {\n          applyAddField(op);\n        } else if(ADD_COPY_FIELD.equals(op.name)) {\n          applyAddCopyField(op);\n        } else if(ADD_FIELD_TYPE.equals(op.name)) {\n          applyAddType(op);\n\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return EMPTY_LIST;\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n\n      }else {\n\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return EMPTY_LIST;\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n          continue;\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n\n    return singletonList(\"Unable to persist schema\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a368d9d724cdb5d45e54f59c0d768bd4ee79979","date":1431953557,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    while (System.nanoTime() < endTime) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n    return singletonList(\"Unable to persist schema\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    while (System.nanoTime() < endTime) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return Collections.emptyList();\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n    return singletonList(\"Unable to persist schema\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"484264228e1de4c93d0f9ec7ad2181223b11889a","date":1460910418,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    while (System.nanoTime() < endTime) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n    return singletonList(\"Unable to persist schema\");\n  }\n\n","bugFix":null,"bugIntro":["5b25ee75ed6af3df45e6fa30072db01d921df493","6f210f93b33ab0a937f545d5f1cc76211cfac904"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8cb57c50beb99a1245256e866350af8e5ea1f36","date":1460921840,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, -1);\n    long startTime = System.nanoTime();\n    long endTime = timeout > 0 ? System.nanoTime() + (timeout * 1000 * 1000) : Long.MAX_VALUE;\n    SolrCore core = req.getCore();\n    while (System.nanoTime() < endTime) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          log.info(\"race condition \");\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader,\n              managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(),\n              sw.toString().getBytes(StandardCharsets.UTF_8),\n              true);\n          waitForOtherReplicasToUpdate(timeout, startTime);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Race condition schema modified by another node\");\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ManagedIndexSchema.SchemaChangedInZkException e) {\n          String s = \"Failed to update schema because schema is modified\";\n          log.warn(s, e);\n        } catch (Exception e) {\n          String s = \"Exception persisting schema\";\n          log.warn(s, e);\n          return singletonList(s + e.getMessage());\n        }\n      }\n    }\n    return singletonList(\"Unable to persist schema\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"734d38d5abe4f98cce936b31450702d597f6fc69","date":1467794285,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":null,"bugIntro":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema();\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b25ee75ed6af3df45e6fa30072db01d921df493","date":1481047896,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":["484264228e1de4c93d0f9ec7ad2181223b11889a"],"bugIntro":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d","date":1481116359,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f210f93b33ab0a937f545d5f1cc76211cfac904","date":1482253533,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":["eeeea2295d6355a29e259130a5c48ace73022d7c","484264228e1de4c93d0f9ec7ad2181223b11889a","5b25ee75ed6af3df45e6fa30072db01d921df493","cb9af919a17be70cfc512901fc70f1beaf840ca1","4a54d9ede1b7f2f026639186eb07f3f314d87d9a","734d38d5abe4f98cce936b31450702d597f6fc69","45a5f13e4e6b3c60912dc0911227739fe2f371c2","7d72e80cee24be385c713864a9f1f90be3744482"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    while (!timeOut.hasTimedOut()) {\n      managedIndexSchema = getFreshManagedSchema(req.getCore());\n      for (CommandOperation op : operations) {\n        OpType opType = OpType.get(op.name);\n        if (opType != null) {\n          opType.perform(op, this);\n        } else {\n          op.addError(\"No such operation : \" + op.name);\n        }\n      }\n      List errs = CommandOperation.captureErrors(operations);\n      if (!errs.isEmpty()) return errs;\n      SolrResourceLoader loader = req.getCore().getResourceLoader();\n      if (loader instanceof ZkSolrResourceLoader) {\n        ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n        StringWriter sw = new StringWriter();\n        try {\n          managedIndexSchema.persist(sw);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n          //unlikely\n        }\n\n        try {\n          int latestVersion = ZkController.persistConfigResourceToZooKeeper(zkLoader, managedIndexSchema.getSchemaZkVersion(),\n              managedIndexSchema.getResourceName(), sw.toString().getBytes(StandardCharsets.UTF_8), true);\n          req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n          waitForOtherReplicasToUpdate(timeOut, latestVersion);\n          return Collections.emptyList();\n        } catch (ZkController.ResourceModifiedInZkException e) {\n          log.info(\"Schema was modified by another node. Retrying..\");\n        }\n      } else {\n        try {\n          //only for non cloud stuff\n          managedIndexSchema.persistManagedSchema(false);\n          core.setLatestSchema(managedIndexSchema);\n          return Collections.emptyList();\n        } catch (SolrException e) {\n          log.warn(errorMsg);\n          return singletonList(errorMsg + e.getMessage());\n        }\n      }\n    }\n    log.warn(errorMsg + \"Timed out.\");\n    return singletonList(errorMsg + \"Timed out.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreDescriptor().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3","date":1570208701,"type":3,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b2329af9080ec86a454c9439598b88e169fc28a","date":1579536707,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    //The default timeout is 10 minutes when no BaseSolrResource.UPDATE_TIMEOUT_SECS is specified\n    int timeout = req.getParams().getInt(BaseSolrResource.UPDATE_TIMEOUT_SECS, 600);\n\n    //If BaseSolrResource.UPDATE_TIMEOUT_SECS=0 or -1 then end time then we'll try for 10 mins ( default timeout )\n    if (timeout < 1) {\n      timeout = 600;\n    }\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(errorMsg + \"Timed out.\");\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e225693f479462798cae64c4d4350c1df6632f41","date":1598082835,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName());\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName());\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fc1087854af39c9b439f47d913fd3ac1d85ac5c","date":1599523122,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId, false);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId, false);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938fe8fd4d30ae70161827366f67c2382985e446","date":1600050178,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId, false);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId, false);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e451e492cce54699988e2ce0aea55e3ff170cb0","date":1600305561,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId, false);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId, false);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"818e98f73e60a2284311c913586399fdb0bd90e2","date":1601357867,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaManager#doOperations(List[CommandOperation]).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","sourceOld":"  @SuppressWarnings({\"rawtypes\"})\n  private List doOperations(List<CommandOperation> operations) throws InterruptedException, IOException, KeeperException {\n    TimeOut timeOut = new TimeOut(timeout, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    SolrCore core = req.getCore();\n    String errorMsg = \"Unable to persist managed schema. \";\n    List errors = Collections.emptyList();\n    int latestVersion = -1;\n\n    synchronized (req.getSchema().getSchemaUpdateLock()) {\n      while (!timeOut.hasTimedOut()) {\n        managedIndexSchema = getFreshManagedSchema(req.getCore());\n        for (CommandOperation op : operations) {\n          OpType opType = OpType.get(op.name);\n          if (opType != null) {\n            opType.perform(op, this);\n          } else {\n            op.addError(\"No such operation : \" + op.name);\n          }\n        }\n        errors = CommandOperation.captureErrors(operations);\n        if (!errors.isEmpty()) break;\n        SolrResourceLoader loader = req.getCore().getResourceLoader();\n        if (loader instanceof ZkSolrResourceLoader) {\n          ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader) loader;\n          StringWriter sw = new StringWriter();\n          try {\n            managedIndexSchema.persist(sw);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"unable to serialize schema\");\n            //unlikely\n          }\n\n          try {\n            latestVersion = ZkController.persistConfigResourceToZooKeeper\n                (zkLoader, managedIndexSchema.getSchemaZkVersion(), managedIndexSchema.getResourceName(),\n                 sw.toString().getBytes(StandardCharsets.UTF_8), true);\n            req.getCore().getCoreContainer().reload(req.getCore().getName(), req.getCore().uniqueId, false);\n            break;\n          } catch (ZkController.ResourceModifiedInZkException e) {\n            log.info(\"Schema was modified by another node. Retrying..\");\n          }\n        } else {\n          try {\n            //only for non cloud stuff\n            managedIndexSchema.persistManagedSchema(false);\n            core.setLatestSchema(managedIndexSchema);\n            core.getCoreContainer().reload(core.getName(), core.uniqueId, false);\n          } catch (SolrException e) {\n            log.warn(errorMsg);\n            errors = singletonList(errorMsg + e.getMessage());\n          }\n          break;\n        }\n      }\n    }\n    if (req.getCore().getResourceLoader() instanceof ZkSolrResourceLoader) {\n      // Don't block further schema updates while waiting for a pending update to propagate to other replicas.\n      // This reduces the likelihood of a (time-limited) distributed deadlock during concurrent schema updates.\n      waitForOtherReplicasToUpdate(timeOut, latestVersion);\n    }\n    if (errors.isEmpty() && timeOut.hasTimedOut()) {\n      log.warn(\"{} Timed out\", errorMsg);\n      errors = singletonList(errorMsg + \"Timed out.\");\n    }\n    return errors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d":["734d38d5abe4f98cce936b31450702d597f6fc69","5b25ee75ed6af3df45e6fa30072db01d921df493"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["45a5f13e4e6b3c60912dc0911227739fe2f371c2"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["e225693f479462798cae64c4d4350c1df6632f41"],"45a5f13e4e6b3c60912dc0911227739fe2f371c2":["7d72e80cee24be385c713864a9f1f90be3744482"],"484264228e1de4c93d0f9ec7ad2181223b11889a":["8a368d9d724cdb5d45e54f59c0d768bd4ee79979"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["45a5f13e4e6b3c60912dc0911227739fe2f371c2","eeeea2295d6355a29e259130a5c48ace73022d7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"5b25ee75ed6af3df45e6fa30072db01d921df493":["734d38d5abe4f98cce936b31450702d597f6fc69"],"6f210f93b33ab0a937f545d5f1cc76211cfac904":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["938fe8fd4d30ae70161827366f67c2382985e446"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cb9af919a17be70cfc512901fc70f1beaf840ca1"],"7d72e80cee24be385c713864a9f1f90be3744482":["cb9af919a17be70cfc512901fc70f1beaf840ca1"],"cb9af919a17be70cfc512901fc70f1beaf840ca1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8b2329af9080ec86a454c9439598b88e169fc28a":["43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3"],"818e98f73e60a2284311c913586399fdb0bd90e2":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["6f210f93b33ab0a937f545d5f1cc76211cfac904"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["8a368d9d724cdb5d45e54f59c0d768bd4ee79979","484264228e1de4c93d0f9ec7ad2181223b11889a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f8cb57c50beb99a1245256e866350af8e5ea1f36","734d38d5abe4f98cce936b31450702d597f6fc69"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["9856095f7afb5a607bf5e65077615ed91273508c","6f210f93b33ab0a937f545d5f1cc76211cfac904"],"8a368d9d724cdb5d45e54f59c0d768bd4ee79979":["eeeea2295d6355a29e259130a5c48ace73022d7c"],"e225693f479462798cae64c4d4350c1df6632f41":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"938fe8fd4d30ae70161827366f67c2382985e446":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"734d38d5abe4f98cce936b31450702d597f6fc69":["f8cb57c50beb99a1245256e866350af8e5ea1f36"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["818e98f73e60a2284311c913586399fdb0bd90e2"],"9df8125ba9193a2e2e285ed92157810b1952a244":["8b2329af9080ec86a454c9439598b88e169fc28a"],"b0b597c65628ca9e73913a07e81691f8229bae35":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d":["9856095f7afb5a607bf5e65077615ed91273508c","6f210f93b33ab0a937f545d5f1cc76211cfac904"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","8a368d9d724cdb5d45e54f59c0d768bd4ee79979"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["938fe8fd4d30ae70161827366f67c2382985e446"],"45a5f13e4e6b3c60912dc0911227739fe2f371c2":["eeeea2295d6355a29e259130a5c48ace73022d7c","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"484264228e1de4c93d0f9ec7ad2181223b11889a":["f8cb57c50beb99a1245256e866350af8e5ea1f36"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55980207f1977bd1463465de1659b821347e2fa8","cb9af919a17be70cfc512901fc70f1beaf840ca1"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["e225693f479462798cae64c4d4350c1df6632f41"],"9856095f7afb5a607bf5e65077615ed91273508c":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3":["8b2329af9080ec86a454c9439598b88e169fc28a","b0b597c65628ca9e73913a07e81691f8229bae35"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3","b0b597c65628ca9e73913a07e81691f8229bae35"],"5b25ee75ed6af3df45e6fa30072db01d921df493":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"6f210f93b33ab0a937f545d5f1cc76211cfac904":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["818e98f73e60a2284311c913586399fdb0bd90e2"],"55980207f1977bd1463465de1659b821347e2fa8":[],"7d72e80cee24be385c713864a9f1f90be3744482":["45a5f13e4e6b3c60912dc0911227739fe2f371c2"],"cb9af919a17be70cfc512901fc70f1beaf840ca1":["55980207f1977bd1463465de1659b821347e2fa8","7d72e80cee24be385c713864a9f1f90be3744482"],"8b2329af9080ec86a454c9439598b88e169fc28a":["9df8125ba9193a2e2e285ed92157810b1952a244"],"818e98f73e60a2284311c913586399fdb0bd90e2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","734d38d5abe4f98cce936b31450702d597f6fc69"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"8a368d9d724cdb5d45e54f59c0d768bd4ee79979":["484264228e1de4c93d0f9ec7ad2181223b11889a","f8cb57c50beb99a1245256e866350af8e5ea1f36"],"e225693f479462798cae64c4d4350c1df6632f41":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"938fe8fd4d30ae70161827366f67c2382985e446":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"734d38d5abe4f98cce936b31450702d597f6fc69":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d","5b25ee75ed6af3df45e6fa30072db01d921df493","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"9df8125ba9193a2e2e285ed92157810b1952a244":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","55980207f1977bd1463465de1659b821347e2fa8","f03e4bed5023ec3ef93a771b8888cae991cf448d","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}