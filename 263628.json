{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","commits":[{"id":"86fcb04ff2d63aad8754270211d5fc084d3526b9","date":1459278881,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","pathOld":"/dev/null","sourceNew":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.SEMIMAJOR_AXIS;\n    assertEquals(90, GeoUtils.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = GeoUtils.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = GeoUtils.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bd00e9af390947b2751706503ba0d2f0b28da6d","date":1459503650,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","sourceNew":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.EARTH_MEAN_RADIUS_METERS;\n    assertEquals(90, GeoUtils.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = GeoUtils.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = GeoUtils.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","sourceOld":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.SEMIMAJOR_AXIS;\n    assertEquals(90, GeoUtils.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = GeoUtils.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = GeoUtils.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ddc1b7a872fafd838d3f3129984ca661e29b36","date":1459526591,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","sourceNew":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.EARTH_MEAN_RADIUS_METERS;\n    assertEquals(90, GeoRect.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = GeoRect.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = GeoRect.axisLat(lat, radius);\n        GeoRect bbox = GeoRect.fromPointDistance(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = GeoRect.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = GeoRect.axisLat(lat, radius);\n        GeoRect bbox = GeoRect.fromPointDistance(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","sourceOld":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.EARTH_MEAN_RADIUS_METERS;\n    assertEquals(90, GeoUtils.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = GeoUtils.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = GeoUtils.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = GeoUtils.axisLat(lat, radius);\n        GeoRect bbox = GeoUtils.circleToBBox(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testAxisLat().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testAxisLat().mjava","sourceNew":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.EARTH_MEAN_RADIUS_METERS;\n    assertEquals(90, Rectangle.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = Rectangle.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = Rectangle.axisLat(lat, radius);\n        Rectangle bbox = Rectangle.fromPointDistance(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = Rectangle.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = Rectangle.axisLat(lat, radius);\n        Rectangle bbox = Rectangle.fromPointDistance(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","sourceOld":"  public void testAxisLat() {\n    double earthCircumference = 2D * Math.PI * GeoUtils.EARTH_MEAN_RADIUS_METERS;\n    assertEquals(90, GeoRect.axisLat(0, earthCircumference / 4), 0.0D);\n\n    for (int i = 0; i < 100; ++i) {\n      boolean reallyBig = random().nextInt(10) == 0;\n      final double maxRadius = reallyBig ? 1.1 * earthCircumference : earthCircumference / 8;\n      final double radius = maxRadius * random().nextDouble();\n      double prevAxisLat = GeoRect.axisLat(0.0D, radius);\n      for (double lat = 0.1D; lat < 90D; lat += 0.1D) {\n        double nextAxisLat = GeoRect.axisLat(lat, radius);\n        GeoRect bbox = GeoRect.fromPointDistance(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat < GeoUtils.MAX_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat <= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n\n      prevAxisLat = GeoRect.axisLat(-0.0D, radius);\n      for (double lat = -0.1D; lat > -90D; lat -= 0.1D) {\n        double nextAxisLat = GeoRect.axisLat(lat, radius);\n        GeoRect bbox = GeoRect.fromPointDistance(lat, 180D, radius);\n        double dist = SloppyMath.haversinMeters(lat, 180D, nextAxisLat, bbox.maxLon);\n        if (nextAxisLat > GeoUtils.MIN_LAT_INCL) {\n          assertEquals(\"lat = \" + lat, dist, radius, 0.1D);\n        }\n        assertTrue(\"lat = \" + lat, prevAxisLat >= nextAxisLat);\n        prevAxisLat = nextAxisLat;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["9bd00e9af390947b2751706503ba0d2f0b28da6d"],"9bd00e9af390947b2751706503ba0d2f0b28da6d":["86fcb04ff2d63aad8754270211d5fc084d3526b9"],"86fcb04ff2d63aad8754270211d5fc084d3526b9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["86fcb04ff2d63aad8754270211d5fc084d3526b9"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"9bd00e9af390947b2751706503ba0d2f0b28da6d":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"86fcb04ff2d63aad8754270211d5fc084d3526b9":["9bd00e9af390947b2751706503ba0d2f0b28da6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}