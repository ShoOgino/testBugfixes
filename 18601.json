{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","commits":[{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRef result = new IntsRef();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          // System.out.println(\"  array arcs\");\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.length = bestUpto;\n            InputOutput io = new InputOutput();\n            io.input = result;\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.ints[upto++] = arc.label;\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.length = bestUpto;\n              InputOutput io = new InputOutput();\n              io.input = result;\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.length = bestUpto;\n        InputOutput io = new InputOutput();\n        io.input = result;\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          // System.out.println(\"  array arcs\");\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRef result = new IntsRef();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          // System.out.println(\"  array arcs\");\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.length = bestUpto;\n            InputOutput io = new InputOutput();\n            io.input = result;\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.ints[upto++] = arc.label;\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.length = bestUpto;\n              InputOutput io = new InputOutput();\n              io.input = result;\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.length = bestUpto;\n        InputOutput io = new InputOutput();\n        io.input = result;\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          // System.out.println(\"  array arcs\");\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a1204a92958bea883656169000a87a6c55c2d0","date":1562106073,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output();\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput());\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target(), arc, fstReader);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart());\n            fstReader.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n              // Keep recursing\n              arc.arcIdx(mid - 1);\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label());\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output();\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput());\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target(), arc, fstReader);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart());\n            fstReader.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found == false) {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          // Recurse on this arc:\n          fr.index.readArcByIndex(arc, fstReader, mid);\n          result.setIntAt(upto++, arc.label());\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output();\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput());\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target(), arc, fstReader);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart());\n            fstReader.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n              // Keep recursing\n              arc.arcIdx(mid - 1);\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label());\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output();\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput());\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target(), arc, fstReader);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart());\n            fstReader.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found == false) {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          // Recurse on this arc:\n          fr.index.readArcByIndex(arc, fstReader, mid);\n          result.setIntAt(upto++, arc.label());\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output;\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput);\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target, arc, fstReader);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart);\n            fstReader.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            // Keep recursing\n            arc.arcIdx = mid-1;\n          } else {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          fr.index.readNextRealArc(arc, fstReader);\n\n          // Recurse on this arc:\n          result.setIntAt(upto++, arc.label);\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71d31a7d5773508492505519bb5230b87c8937ad","date":1573681693,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnum#getByOutput(long).mjava","sourceNew":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output();\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput());\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target(), arc, fstReader);\n\n        if (arc.bytesPerArc() != 0 && arc.nodeFlags() == FST.ARCS_FOR_BINARY_SEARCH) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart());\n            fstReader.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found == false) {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          // Recurse on this arc:\n          fr.index.readArcByIndex(arc, fstReader, mid);\n          result.setIntAt(upto++, arc.label());\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: this is similar to Util.getByOutput ... can we refactor/share?\n  /** Specialized getByOutput that can understand the ranges (startOrd to endOrd) we use here, not just startOrd. */\n  private InputOutput getByOutput(long targetOrd) throws IOException {\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n\n    fr.index.getFirstArc(arc);\n    Output output = arc.output();\n    int upto = 0;\n\n    int bestUpto = 0;\n    Output bestOutput = null;\n\n    /*\n    Writer w = new OutputStreamWriter(new FileOutputStream(\"/tmp/out.dot\"));\n    Util.toDot(fr.index, w, true, true);\n    w.close();\n    */\n\n    // System.out.println(\"reverseLookup seg=\" + fr.parent.segment + \" output=\" + targetOrd);\n\n    while (true) {\n      // System.out.println(\"  loop: output=\" + output.startOrd + \"-\" + (Long.MAX_VALUE-output.endOrd) + \" upto=\" + upto + \" arc=\" + arc + \" final?=\" + arc.isFinal());\n      if (arc.isFinal()) {\n        final Output finalOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput());\n        // System.out.println(\"  isFinal: \" + finalOutput.startOrd + \"-\" + (Long.MAX_VALUE-finalOutput.endOrd));\n        if (targetOrd >= finalOutput.startOrd && targetOrd <= Long.MAX_VALUE-finalOutput.endOrd) {\n          // Only one range should match across all arc leaving this node\n          //assert bestOutput == null;\n          bestOutput = finalOutput;\n          bestUpto = upto;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        // System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        fr.index.readFirstRealTargetArc(arc.target(), arc, fstReader);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n          // System.out.println(\"  array arcs\");\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean found = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            fstReader.setPosition(arc.posArcsStart());\n            fstReader.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = fstReader.readByte();\n            fr.index.readLabel(fstReader);\n            final Output minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, OrdsBlockTreeTermsWriter.FST_OUTPUTS.read(fstReader));\n            } else {\n              minArcOutput = output;\n            }\n            // System.out.println(\"  cycle mid=\" + mid + \" targetOrd=\" + targetOrd + \" output=\" + minArcOutput.startOrd + \"-\" + (Long.MAX_VALUE-minArcOutput.endOrd));\n            if (targetOrd > Long.MAX_VALUE-minArcOutput.endOrd) {\n              low = mid + 1;\n            } else if (targetOrd < minArcOutput.startOrd) {\n              high = mid - 1;\n            } else {\n              // System.out.println(\"    found!!\");\n              found = true;\n              break;\n            }\n          }\n\n          if (found == false) {\n            result.setLength(bestUpto);\n            InputOutput io = new InputOutput();\n            io.input = result.get();\n            io.output = bestOutput;\n            // System.out.println(\"  ret0=\" + io);\n            return io;\n          }\n\n          // Recurse on this arc:\n          fr.index.readArcByIndex(arc, fstReader, mid);\n          result.setIntAt(upto++, arc.label());\n          output = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n\n        } else {\n          // System.out.println(\"    non-array arc\");\n\n          while (true) {\n            // System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final Output minArcOutput = OrdsBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n            long endOrd = Long.MAX_VALUE - minArcOutput.endOrd;\n            // System.out.println(\"    endOrd=\" + endOrd + \" targetOrd=\" + targetOrd);\n\n            if (targetOrd >= minArcOutput.startOrd && targetOrd <= endOrd) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (targetOrd < endOrd || arc.isLast()) {\n              result.setLength(bestUpto);\n              InputOutput io = new InputOutput();\n              io.input = result.get();\n              assert bestOutput != null;\n              io.output = bestOutput;\n              // System.out.println(\"  ret2=\" + io);\n              return io;\n            } else {\n              // System.out.println(\"  next arc\");\n              // Read next arc in this node:\n              fr.index.readNextRealArc(arc, fstReader);\n            }\n          }\n        }\n      } else {\n        result.setLength(bestUpto);\n        InputOutput io = new InputOutput();\n        io.input = result.get();\n        io.output = bestOutput;\n        // System.out.println(\"  ret3=\" + io);\n        return io;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["59a1204a92958bea883656169000a87a6c55c2d0"],"59a1204a92958bea883656169000a87a6c55c2d0":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"71d31a7d5773508492505519bb5230b87c8937ad":["f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"f8061ddd97f3352007d927dae445884a6f3d857b":["59a1204a92958bea883656169000a87a6c55c2d0","f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71d31a7d5773508492505519bb5230b87c8937ad"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"59a1204a92958bea883656169000a87a6c55c2d0":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244":["71d31a7d5773508492505519bb5230b87c8937ad","f8061ddd97f3352007d927dae445884a6f3d857b"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["59a1204a92958bea883656169000a87a6c55c2d0"],"71d31a7d5773508492505519bb5230b87c8937ad":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}