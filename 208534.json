{"path":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","commits":[{"id":"296b8b38a87feb478921f77834a2302dfe77641c","date":1209506838,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"/dev/null","sourceNew":"  /**\r\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\r\n   * \r\n   * @param query\r\n   *          Query to extract Terms from\r\n   * @param terms\r\n   *          Map to place created WeightedSpanTerms in\r\n   * @throws IOException\r\n   */\r\n  private void extract(Query query, Map terms) throws IOException {\r\n    if (query instanceof BooleanQuery) {\r\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\r\n      Map booleanTerms = new HashMap();\r\n      for (int i = 0; i < queryClauses.length; i++) {\r\n        if (!queryClauses[i].isProhibited()) {\r\n          extract(queryClauses[i].getQuery(), booleanTerms);\r\n        }\r\n      }\r\n      terms.putAll(booleanTerms);\r\n    } else if (query instanceof PhraseQuery) {\r\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\r\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\r\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\r\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\r\n      }\r\n\r\n      int slop = ((PhraseQuery) query).getSlop();\r\n      boolean inorder = false;\r\n\r\n      if (slop == 0) {\r\n        inorder = true;\r\n      }\r\n\r\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\r\n      sp.setBoost(query.getBoost());\r\n      extractWeightedSpanTerms(terms, sp);\r\n    } else if (query instanceof TermQuery) {\r\n      extractWeightedTerms(terms, query);\r\n    } else if (query instanceof SpanQuery) {\r\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\r\n    } else if (query instanceof FilteredQuery) {\r\n      extract(((FilteredQuery) query).getQuery(), terms);\r\n    } else if (query instanceof DisjunctionMaxQuery) {\r\n      Map disjunctTerms = new HashMap();\r\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\r\n        extract((Query) iterator.next(), disjunctTerms);\r\n      }\r\n      terms.putAll(disjunctTerms);\r\n    } else if (query instanceof MultiPhraseQuery) {\r\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\r\n      final List termArrays = mpq.getTermArrays();\r\n      final int[] positions = mpq.getPositions();\r\n      if (positions.length > 0) {\r\n\r\n        int maxPosition = positions[positions.length - 1];\r\n        for (int i = 0; i < positions.length - 1; ++i) {\r\n          if (positions[i] > maxPosition) {\r\n            maxPosition = positions[i];\r\n          }\r\n        }\r\n\r\n        final List[] disjunctLists = new List[maxPosition + 1];\r\n        int distinctPositions = 0;\r\n\r\n        for (int i = 0; i < termArrays.size(); ++i) {\r\n          final Term[] termArray = (Term[]) termArrays.get(i);\r\n          List disjuncts = disjunctLists[positions[i]];\r\n          if (disjuncts == null) {\r\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\r\n            ++distinctPositions;\r\n          }\r\n          for (int j = 0; j < termArray.length; ++j) {\r\n            disjuncts.add(new SpanTermQuery(termArray[j]));\r\n          }\r\n        }\r\n\r\n        int positionGaps = 0;\r\n        int position = 0;\r\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\r\n        for (int i = 0; i < disjunctLists.length; ++i) {\r\n          List disjuncts = disjunctLists[i];\r\n          if (disjuncts != null) {\r\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\r\n                .toArray(new SpanQuery[disjuncts.size()]));\r\n          } else {\r\n            ++positionGaps;\r\n          }\r\n        }\r\n\r\n        final int slop = mpq.getSlop();\r\n        final boolean inorder = (slop == 0);\r\n\r\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\r\n        sp.setBoost(query.getBoost());\r\n        extractWeightedSpanTerms(terms, sp);\r\n      }\r\n    } else if (query instanceof ConstantScoreRangeQuery) {\r\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\r\n      Term lower = new Term(fieldName, q.getLowerVal());\r\n      Term upper = new Term(fieldName, q.getUpperVal());\r\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\r\n      try {\r\n        TermEnum te = fir.terms(lower);\r\n        BooleanQuery bq = new BooleanQuery();\r\n        do {\r\n          Term term = te.term();\r\n          if (term != null && upper.compareTo(term) >= 0) {\r\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\r\n          } else {\r\n            break;\r\n          }\r\n        } while (te.next());\r\n        extract(bq, terms);\r\n      } finally {\r\n        fir.close();\r\n      }\r\n    } else {\r\n      // NO-OP\r\n      System.out.println(\"found none\");\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7016613244a3cb636b6c43b1af8fa4947a413573","5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7016613244a3cb636b6c43b1af8fa4947a413573","date":1209668346,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\r\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\r\n   * \r\n   * @param query\r\n   *          Query to extract Terms from\r\n   * @param terms\r\n   *          Map to place created WeightedSpanTerms in\r\n   * @throws IOException\r\n   */\r\n  private void extract(Query query, Map terms) throws IOException {\r\n    if (query instanceof BooleanQuery) {\r\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\r\n      Map booleanTerms = new HashMap();\r\n      for (int i = 0; i < queryClauses.length; i++) {\r\n        if (!queryClauses[i].isProhibited()) {\r\n          extract(queryClauses[i].getQuery(), booleanTerms);\r\n        }\r\n      }\r\n      terms.putAll(booleanTerms);\r\n    } else if (query instanceof PhraseQuery) {\r\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\r\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\r\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\r\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\r\n      }\r\n\r\n      int slop = ((PhraseQuery) query).getSlop();\r\n      boolean inorder = false;\r\n\r\n      if (slop == 0) {\r\n        inorder = true;\r\n      }\r\n\r\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\r\n      sp.setBoost(query.getBoost());\r\n      extractWeightedSpanTerms(terms, sp);\r\n    } else if (query instanceof TermQuery) {\r\n      extractWeightedTerms(terms, query);\r\n    } else if (query instanceof SpanQuery) {\r\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\r\n    } else if (query instanceof FilteredQuery) {\r\n      extract(((FilteredQuery) query).getQuery(), terms);\r\n    } else if (query instanceof DisjunctionMaxQuery) {\r\n      Map disjunctTerms = new HashMap();\r\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\r\n        extract((Query) iterator.next(), disjunctTerms);\r\n      }\r\n      terms.putAll(disjunctTerms);\r\n    } else if (query instanceof MultiPhraseQuery) {\r\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\r\n      final List termArrays = mpq.getTermArrays();\r\n      final int[] positions = mpq.getPositions();\r\n      if (positions.length > 0) {\r\n\r\n        int maxPosition = positions[positions.length - 1];\r\n        for (int i = 0; i < positions.length - 1; ++i) {\r\n          if (positions[i] > maxPosition) {\r\n            maxPosition = positions[i];\r\n          }\r\n        }\r\n\r\n        final List[] disjunctLists = new List[maxPosition + 1];\r\n        int distinctPositions = 0;\r\n\r\n        for (int i = 0; i < termArrays.size(); ++i) {\r\n          final Term[] termArray = (Term[]) termArrays.get(i);\r\n          List disjuncts = disjunctLists[positions[i]];\r\n          if (disjuncts == null) {\r\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\r\n            ++distinctPositions;\r\n          }\r\n          for (int j = 0; j < termArray.length; ++j) {\r\n            disjuncts.add(new SpanTermQuery(termArray[j]));\r\n          }\r\n        }\r\n\r\n        int positionGaps = 0;\r\n        int position = 0;\r\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\r\n        for (int i = 0; i < disjunctLists.length; ++i) {\r\n          List disjuncts = disjunctLists[i];\r\n          if (disjuncts != null) {\r\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\r\n                .toArray(new SpanQuery[disjuncts.size()]));\r\n          } else {\r\n            ++positionGaps;\r\n          }\r\n        }\r\n\r\n        final int slop = mpq.getSlop();\r\n        final boolean inorder = (slop == 0);\r\n\r\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\r\n        sp.setBoost(query.getBoost());\r\n        extractWeightedSpanTerms(terms, sp);\r\n      }\r\n    } else if (query instanceof ConstantScoreRangeQuery) {\r\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\r\n      Term lower = new Term(fieldName, q.getLowerVal());\r\n      Term upper = new Term(fieldName, q.getUpperVal());\r\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\r\n      try {\r\n        TermEnum te = fir.terms(lower);\r\n        BooleanQuery bq = new BooleanQuery();\r\n        do {\r\n          Term term = te.term();\r\n          if (term != null && upper.compareTo(term) >= 0) {\r\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\r\n          } else {\r\n            break;\r\n          }\r\n        } while (te.next());\r\n        extract(bq, terms);\r\n      } finally {\r\n        fir.close();\r\n      }\r\n    } \r\n  }\r\n\n","sourceOld":"  /**\r\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\r\n   * \r\n   * @param query\r\n   *          Query to extract Terms from\r\n   * @param terms\r\n   *          Map to place created WeightedSpanTerms in\r\n   * @throws IOException\r\n   */\r\n  private void extract(Query query, Map terms) throws IOException {\r\n    if (query instanceof BooleanQuery) {\r\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\r\n      Map booleanTerms = new HashMap();\r\n      for (int i = 0; i < queryClauses.length; i++) {\r\n        if (!queryClauses[i].isProhibited()) {\r\n          extract(queryClauses[i].getQuery(), booleanTerms);\r\n        }\r\n      }\r\n      terms.putAll(booleanTerms);\r\n    } else if (query instanceof PhraseQuery) {\r\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\r\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\r\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\r\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\r\n      }\r\n\r\n      int slop = ((PhraseQuery) query).getSlop();\r\n      boolean inorder = false;\r\n\r\n      if (slop == 0) {\r\n        inorder = true;\r\n      }\r\n\r\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\r\n      sp.setBoost(query.getBoost());\r\n      extractWeightedSpanTerms(terms, sp);\r\n    } else if (query instanceof TermQuery) {\r\n      extractWeightedTerms(terms, query);\r\n    } else if (query instanceof SpanQuery) {\r\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\r\n    } else if (query instanceof FilteredQuery) {\r\n      extract(((FilteredQuery) query).getQuery(), terms);\r\n    } else if (query instanceof DisjunctionMaxQuery) {\r\n      Map disjunctTerms = new HashMap();\r\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\r\n        extract((Query) iterator.next(), disjunctTerms);\r\n      }\r\n      terms.putAll(disjunctTerms);\r\n    } else if (query instanceof MultiPhraseQuery) {\r\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\r\n      final List termArrays = mpq.getTermArrays();\r\n      final int[] positions = mpq.getPositions();\r\n      if (positions.length > 0) {\r\n\r\n        int maxPosition = positions[positions.length - 1];\r\n        for (int i = 0; i < positions.length - 1; ++i) {\r\n          if (positions[i] > maxPosition) {\r\n            maxPosition = positions[i];\r\n          }\r\n        }\r\n\r\n        final List[] disjunctLists = new List[maxPosition + 1];\r\n        int distinctPositions = 0;\r\n\r\n        for (int i = 0; i < termArrays.size(); ++i) {\r\n          final Term[] termArray = (Term[]) termArrays.get(i);\r\n          List disjuncts = disjunctLists[positions[i]];\r\n          if (disjuncts == null) {\r\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\r\n            ++distinctPositions;\r\n          }\r\n          for (int j = 0; j < termArray.length; ++j) {\r\n            disjuncts.add(new SpanTermQuery(termArray[j]));\r\n          }\r\n        }\r\n\r\n        int positionGaps = 0;\r\n        int position = 0;\r\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\r\n        for (int i = 0; i < disjunctLists.length; ++i) {\r\n          List disjuncts = disjunctLists[i];\r\n          if (disjuncts != null) {\r\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\r\n                .toArray(new SpanQuery[disjuncts.size()]));\r\n          } else {\r\n            ++positionGaps;\r\n          }\r\n        }\r\n\r\n        final int slop = mpq.getSlop();\r\n        final boolean inorder = (slop == 0);\r\n\r\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\r\n        sp.setBoost(query.getBoost());\r\n        extractWeightedSpanTerms(terms, sp);\r\n      }\r\n    } else if (query instanceof ConstantScoreRangeQuery) {\r\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\r\n      Term lower = new Term(fieldName, q.getLowerVal());\r\n      Term upper = new Term(fieldName, q.getUpperVal());\r\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\r\n      try {\r\n        TermEnum te = fir.terms(lower);\r\n        BooleanQuery bq = new BooleanQuery();\r\n        do {\r\n          Term term = te.term();\r\n          if (term != null && upper.compareTo(term) >= 0) {\r\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\r\n          } else {\r\n            break;\r\n          }\r\n        } while (te.next());\r\n        extract(bq, terms);\r\n      } finally {\r\n        fir.close();\r\n      }\r\n    } else {\r\n      // NO-OP\r\n      System.out.println(\"found none\");\r\n    }\r\n  }\r\n\n","bugFix":["296b8b38a87feb478921f77834a2302dfe77641c"],"bugIntro":["5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d934099a6f0a3ae0285025a1e1b61b7b05fed8f","date":1211715535,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof ConstantScoreRangeQuery) {\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\n      Term lower = new Term(fieldName, q.getLowerVal());\n      Term upper = new Term(fieldName, q.getUpperVal());\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\n      try {\n        TermEnum te = fir.terms(lower);\n        BooleanQuery bq = new BooleanQuery();\n        do {\n          Term term = te.term();\n          if (term != null && upper.compareTo(term) >= 0) {\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n          } else {\n            break;\n          }\n        } while (te.next());\n        extract(bq, terms);\n      } finally {\n        fir.close();\n      }\n    } \n  }\n\n","sourceOld":"  /**\r\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\r\n   * \r\n   * @param query\r\n   *          Query to extract Terms from\r\n   * @param terms\r\n   *          Map to place created WeightedSpanTerms in\r\n   * @throws IOException\r\n   */\r\n  private void extract(Query query, Map terms) throws IOException {\r\n    if (query instanceof BooleanQuery) {\r\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\r\n      Map booleanTerms = new HashMap();\r\n      for (int i = 0; i < queryClauses.length; i++) {\r\n        if (!queryClauses[i].isProhibited()) {\r\n          extract(queryClauses[i].getQuery(), booleanTerms);\r\n        }\r\n      }\r\n      terms.putAll(booleanTerms);\r\n    } else if (query instanceof PhraseQuery) {\r\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\r\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\r\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\r\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\r\n      }\r\n\r\n      int slop = ((PhraseQuery) query).getSlop();\r\n      boolean inorder = false;\r\n\r\n      if (slop == 0) {\r\n        inorder = true;\r\n      }\r\n\r\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\r\n      sp.setBoost(query.getBoost());\r\n      extractWeightedSpanTerms(terms, sp);\r\n    } else if (query instanceof TermQuery) {\r\n      extractWeightedTerms(terms, query);\r\n    } else if (query instanceof SpanQuery) {\r\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\r\n    } else if (query instanceof FilteredQuery) {\r\n      extract(((FilteredQuery) query).getQuery(), terms);\r\n    } else if (query instanceof DisjunctionMaxQuery) {\r\n      Map disjunctTerms = new HashMap();\r\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\r\n        extract((Query) iterator.next(), disjunctTerms);\r\n      }\r\n      terms.putAll(disjunctTerms);\r\n    } else if (query instanceof MultiPhraseQuery) {\r\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\r\n      final List termArrays = mpq.getTermArrays();\r\n      final int[] positions = mpq.getPositions();\r\n      if (positions.length > 0) {\r\n\r\n        int maxPosition = positions[positions.length - 1];\r\n        for (int i = 0; i < positions.length - 1; ++i) {\r\n          if (positions[i] > maxPosition) {\r\n            maxPosition = positions[i];\r\n          }\r\n        }\r\n\r\n        final List[] disjunctLists = new List[maxPosition + 1];\r\n        int distinctPositions = 0;\r\n\r\n        for (int i = 0; i < termArrays.size(); ++i) {\r\n          final Term[] termArray = (Term[]) termArrays.get(i);\r\n          List disjuncts = disjunctLists[positions[i]];\r\n          if (disjuncts == null) {\r\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\r\n            ++distinctPositions;\r\n          }\r\n          for (int j = 0; j < termArray.length; ++j) {\r\n            disjuncts.add(new SpanTermQuery(termArray[j]));\r\n          }\r\n        }\r\n\r\n        int positionGaps = 0;\r\n        int position = 0;\r\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\r\n        for (int i = 0; i < disjunctLists.length; ++i) {\r\n          List disjuncts = disjunctLists[i];\r\n          if (disjuncts != null) {\r\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\r\n                .toArray(new SpanQuery[disjuncts.size()]));\r\n          } else {\r\n            ++positionGaps;\r\n          }\r\n        }\r\n\r\n        final int slop = mpq.getSlop();\r\n        final boolean inorder = (slop == 0);\r\n\r\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\r\n        sp.setBoost(query.getBoost());\r\n        extractWeightedSpanTerms(terms, sp);\r\n      }\r\n    } else if (query instanceof ConstantScoreRangeQuery) {\r\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\r\n      Term lower = new Term(fieldName, q.getLowerVal());\r\n      Term upper = new Term(fieldName, q.getUpperVal());\r\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\r\n      try {\r\n        TermEnum te = fir.terms(lower);\r\n        BooleanQuery bq = new BooleanQuery();\r\n        do {\r\n          Term term = te.term();\r\n          if (term != null && upper.compareTo(term) >= 0) {\r\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\r\n          } else {\r\n            break;\r\n          }\r\n        } while (te.next());\r\n        extract(bq, terms);\r\n      } finally {\r\n        fir.close();\r\n      }\r\n    } \r\n  }\r\n\n","bugFix":["7016613244a3cb636b6c43b1af8fa4947a413573","296b8b38a87feb478921f77834a2302dfe77641c"],"bugIntro":["7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16","cb2eac46a4023564c3d2b41ec4bc90eb48e61154","bbc553081eea52ac8a9c5e1af5ca003289216561","02d468a946da60dfedb2d8d178fc0c40461f9798","e6af5ddb3f8b6e8d63c23b3336cf936bb9d79c62","25b09d64ea2a5e3eb87f819544b3fa1f306b9c4b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25b09d64ea2a5e3eb87f819544b3fa1f306b9c4b","date":1220957570,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (highlightCnstScrRngQuery && query instanceof ConstantScoreRangeQuery) {\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\n      Term lower = new Term(fieldName, q.getLowerVal());\n      Term upper = new Term(fieldName, q.getUpperVal());\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\n      try {\n        TermEnum te = fir.terms(lower);\n        BooleanQuery bq = new BooleanQuery();\n        do {\n          Term term = te.term();\n          if (term != null && upper.compareTo(term) >= 0) {\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n          } else {\n            break;\n          }\n        } while (te.next());\n        extract(bq, terms);\n      } finally {\n        fir.close();\n      }\n    } \n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof ConstantScoreRangeQuery) {\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\n      Term lower = new Term(fieldName, q.getLowerVal());\n      Term upper = new Term(fieldName, q.getUpperVal());\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\n      try {\n        TermEnum te = fir.terms(lower);\n        BooleanQuery bq = new BooleanQuery();\n        do {\n          Term term = te.term();\n          if (term != null && upper.compareTo(term) >= 0) {\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n          } else {\n            break;\n          }\n        } while (te.next());\n        extract(bq, terms);\n      } finally {\n        fir.close();\n      }\n    } \n  }\n\n","bugFix":["5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e89ac7460543b39f8de96654421e96790abaa26","date":1239329386,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getConstantScoreRewrite()) {\n        query = copyMultiTermQuery(mtq);\n        mtq.setConstantScoreRewrite(false);\n      }\n      IndexReader ir = getReaderForField(fieldName);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (highlightCnstScrRngQuery && query instanceof ConstantScoreRangeQuery) {\n      ConstantScoreRangeQuery q = (ConstantScoreRangeQuery) query;\n      Term lower = new Term(fieldName, q.getLowerVal());\n      Term upper = new Term(fieldName, q.getUpperVal());\n      FilterIndexReader fir = new FilterIndexReader(getReaderForField(fieldName));\n      try {\n        TermEnum te = fir.terms(lower);\n        BooleanQuery bq = new BooleanQuery();\n        do {\n          Term term = te.term();\n          if (term != null && upper.compareTo(term) >= 0) {\n            bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));\n          } else {\n            break;\n          }\n        } while (te.next());\n        extract(bq, terms);\n      } finally {\n        fir.close();\n      }\n    } \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e88427698ce39ca16c9ecc0ab9c414209ea98e04","date":1241304386,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getConstantScoreRewrite()) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setConstantScoreRewrite(false);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof RangeQuery) {\n        field = ((RangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getConstantScoreRewrite()) {\n        query = copyMultiTermQuery(mtq);\n        mtq.setConstantScoreRewrite(false);\n      }\n      IndexReader ir = getReaderForField(fieldName);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f612096ab5275c4821d05f126bf45a89f4782b8","date":1246738452,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getConstantScoreRewrite()) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setConstantScoreRewrite(false);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getConstantScoreRewrite()) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setConstantScoreRewrite(false);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof RangeQuery) {\n        field = ((RangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b20609f6fb2cd074bd08115b0c3280b9646af7c","date":1248480213,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() == MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getConstantScoreRewrite()) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setConstantScoreRewrite(false);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fe42720c4aa75275e3f2ec2ae9c7343acb93846","date":1248514277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() == MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6af5ddb3f8b6e8d63c23b3336cf936bb9d79c62","date":1248886025,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n  \n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n      Map booleanTerms = new PositionCheckingMap();\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), booleanTerms);\n        }\n      }\n      terms.putAll(booleanTerms);\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      Map disjunctTerms = new PositionCheckingMap();\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), disjunctTerms);\n      }\n      terms.putAll(disjunctTerms);\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":["5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4471b2ef75c0e11869f60b23cabe292b895c3ee","date":1248991247,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n  \n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"943c3f9cf96b8df37f4273d66a66182e2a669467","date":1249394171,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"322d95cfb0c59ace7533e19e5cec7f359ce6d6d3","date":1255442836,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field = null;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else if (mtq instanceof PrefixQuery) {\n        field = ((PrefixQuery) mtq).getPrefix().field();\n      } else if (mtq instanceof WildcardQuery) {\n        field = ((WildcardQuery) mtq).getTerm().field();\n      } else if (mtq instanceof FuzzyQuery) {\n        field = ((FuzzyQuery) mtq).getTerm().field();\n      }\n      if (field != null) {\n        IndexReader ir = getReaderForField(field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else {\n        field = mtq.getTerm().field();\n      }\n      IndexReader ir = getReaderForField(field);\n      extract(query.rewrite(ir), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cfd30f39d4b9b5bdcb2e23379090a0a93789b0df","date":1256317730,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field = null;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else if (mtq instanceof PrefixQuery) {\n        field = ((PrefixQuery) mtq).getPrefix().field();\n      } else if (mtq instanceof WildcardQuery) {\n        field = ((WildcardQuery) mtq).getTerm().field();\n      } else if (mtq instanceof FuzzyQuery) {\n        field = ((FuzzyQuery) mtq).getTerm().field();\n      }\n      if (field != null) {\n        IndexReader ir = getReaderForField(field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field = null;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else if (mtq instanceof PrefixQuery) {\n        field = ((PrefixQuery) mtq).getPrefix().field();\n      } else if (mtq instanceof WildcardQuery) {\n        field = ((WildcardQuery) mtq).getTerm().field();\n      } else if (mtq instanceof FuzzyQuery) {\n        field = ((FuzzyQuery) mtq).getTerm().field();\n      }\n      if (field != null) {\n        IndexReader ir = getReaderForField(field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16","bbc553081eea52ac8a9c5e1af5ca003289216561"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ffdf794cee8d43eb612df752c592cef2dc3e75ae","date":1256465578,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field = null;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else if (mtq instanceof PrefixQuery) {\n        field = ((PrefixQuery) mtq).getPrefix().field();\n      } else if (mtq instanceof WildcardQuery) {\n        field = ((WildcardQuery) mtq).getTerm().field();\n      } else if (mtq instanceof FuzzyQuery) {\n        field = ((FuzzyQuery) mtq).getTerm().field();\n      }\n      if (field != null) {\n        IndexReader ir = getReaderForField(field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract((Query) iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = copyMultiTermQuery(mtq);\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      String field = null;\n      if(mtq instanceof TermRangeQuery) {\n        field = ((TermRangeQuery)mtq).getField();\n      } else if (mtq instanceof PrefixQuery) {\n        field = ((PrefixQuery) mtq).getPrefix().field();\n      } else if (mtq instanceof WildcardQuery) {\n        field = ((WildcardQuery) mtq).getTerm().field();\n      } else if (mtq instanceof FuzzyQuery) {\n        field = ((FuzzyQuery) mtq).getTerm().field();\n      }\n      if (field != null) {\n        IndexReader ir = getReaderForField(field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = (Term[]) termArrays.get(i);\n          List disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["cb2eac46a4023564c3d2b41ec4bc90eb48e61154"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e88427698ce39ca16c9ecc0ab9c414209ea98e04":["1e89ac7460543b39f8de96654421e96790abaa26"],"8b20609f6fb2cd074bd08115b0c3280b9646af7c":["0f612096ab5275c4821d05f126bf45a89f4782b8"],"1e89ac7460543b39f8de96654421e96790abaa26":["25b09d64ea2a5e3eb87f819544b3fa1f306b9c4b"],"5d934099a6f0a3ae0285025a1e1b61b7b05fed8f":["7016613244a3cb636b6c43b1af8fa4947a413573"],"943c3f9cf96b8df37f4273d66a66182e2a669467":["b4471b2ef75c0e11869f60b23cabe292b895c3ee"],"25b09d64ea2a5e3eb87f819544b3fa1f306b9c4b":["5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"ffdf794cee8d43eb612df752c592cef2dc3e75ae":["cfd30f39d4b9b5bdcb2e23379090a0a93789b0df"],"322d95cfb0c59ace7533e19e5cec7f359ce6d6d3":["943c3f9cf96b8df37f4273d66a66182e2a669467"],"0f612096ab5275c4821d05f126bf45a89f4782b8":["e88427698ce39ca16c9ecc0ab9c414209ea98e04"],"b4471b2ef75c0e11869f60b23cabe292b895c3ee":["e6af5ddb3f8b6e8d63c23b3336cf936bb9d79c62"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e6af5ddb3f8b6e8d63c23b3336cf936bb9d79c62":["8fe42720c4aa75275e3f2ec2ae9c7343acb93846"],"7016613244a3cb636b6c43b1af8fa4947a413573":["296b8b38a87feb478921f77834a2302dfe77641c"],"cfd30f39d4b9b5bdcb2e23379090a0a93789b0df":["322d95cfb0c59ace7533e19e5cec7f359ce6d6d3"],"8fe42720c4aa75275e3f2ec2ae9c7343acb93846":["8b20609f6fb2cd074bd08115b0c3280b9646af7c"],"296b8b38a87feb478921f77834a2302dfe77641c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ffdf794cee8d43eb612df752c592cef2dc3e75ae"]},"commit2Childs":{"e88427698ce39ca16c9ecc0ab9c414209ea98e04":["0f612096ab5275c4821d05f126bf45a89f4782b8"],"8b20609f6fb2cd074bd08115b0c3280b9646af7c":["8fe42720c4aa75275e3f2ec2ae9c7343acb93846"],"1e89ac7460543b39f8de96654421e96790abaa26":["e88427698ce39ca16c9ecc0ab9c414209ea98e04"],"5d934099a6f0a3ae0285025a1e1b61b7b05fed8f":["25b09d64ea2a5e3eb87f819544b3fa1f306b9c4b"],"943c3f9cf96b8df37f4273d66a66182e2a669467":["322d95cfb0c59ace7533e19e5cec7f359ce6d6d3"],"25b09d64ea2a5e3eb87f819544b3fa1f306b9c4b":["1e89ac7460543b39f8de96654421e96790abaa26"],"ffdf794cee8d43eb612df752c592cef2dc3e75ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0f612096ab5275c4821d05f126bf45a89f4782b8":["8b20609f6fb2cd074bd08115b0c3280b9646af7c"],"322d95cfb0c59ace7533e19e5cec7f359ce6d6d3":["cfd30f39d4b9b5bdcb2e23379090a0a93789b0df"],"b4471b2ef75c0e11869f60b23cabe292b895c3ee":["943c3f9cf96b8df37f4273d66a66182e2a669467"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["296b8b38a87feb478921f77834a2302dfe77641c"],"7016613244a3cb636b6c43b1af8fa4947a413573":["5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"e6af5ddb3f8b6e8d63c23b3336cf936bb9d79c62":["b4471b2ef75c0e11869f60b23cabe292b895c3ee"],"cfd30f39d4b9b5bdcb2e23379090a0a93789b0df":["ffdf794cee8d43eb612df752c592cef2dc3e75ae"],"8fe42720c4aa75275e3f2ec2ae9c7343acb93846":["e6af5ddb3f8b6e8d63c23b3336cf936bb9d79c62"],"296b8b38a87feb478921f77834a2302dfe77641c":["7016613244a3cb636b6c43b1af8fa4947a413573"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}