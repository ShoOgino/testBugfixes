{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerWeight.getAutomaton());\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, needsScores, boost));\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerWeight.getAutomaton());\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerWeight.getAutomaton());\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, needsScores, boost));\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerWeight.getAutomaton());\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5d3b3ab0062c441ef30035f527dbb188c70d9da","date":1526545789,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerWeight.getAutomaton());\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","bugFix":["9fc47cb7b4346802411bb432f501ed0673d7119e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a","date":1528168051,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(ConcatenateGraphFilter.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(ConcatenateGraphFilter.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(ConcatenateGraphFilter.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    final CompletionWeight innerWeight = ((CompletionWeight) innerQuery.createWeight(searcher, scoreMode, boost));\n    final Automaton innerAutomaton = innerWeight.getAutomaton();\n\n    // If the inner automaton matches nothing, then we return an empty weight to avoid\n    // traversing all contexts during scoring.\n    if (innerAutomaton.getNumStates() == 0) {\n      return new CompletionWeight(this, innerAutomaton);\n    }\n\n    // if separators are preserved the fst contains a SEP_LABEL\n    // behind each gap. To have a matching automaton, we need to\n    // include the SEP_LABEL in the query as well\n    Automaton optionalSepLabel = Operations.optional(Automata.makeChar(CompletionAnalyzer.SEP_LABEL));\n    Automaton prefixAutomaton = Operations.concatenate(optionalSepLabel, innerAutomaton);\n    Automaton contextsAutomaton = Operations.concatenate(toContextAutomaton(contexts, matchAllContexts), prefixAutomaton);\n    contextsAutomaton = Operations.determinize(contextsAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n    final Map<IntsRef, Float> contextMap = new HashMap<>(contexts.size());\n    final TreeSet<Integer> contextLengths = new TreeSet<>();\n    for (Map.Entry<IntsRef, ContextMetaData> entry : contexts.entrySet()) {\n      ContextMetaData contextMetaData = entry.getValue();\n      contextMap.put(entry.getKey(), contextMetaData.boost);\n      contextLengths.add(entry.getKey().length);\n    }\n    int[] contextLengthArray = new int[contextLengths.size()];\n    final Iterator<Integer> iterator = contextLengths.descendingIterator();\n    for (int i = 0; iterator.hasNext(); i++) {\n      contextLengthArray[i] = iterator.next();\n    }\n    return new ContextCompletionWeight(this, contextsAutomaton, innerWeight, contextMap, contextLengthArray);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["e5d3b3ab0062c441ef30035f527dbb188c70d9da","9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a"],"e5d3b3ab0062c441ef30035f527dbb188c70d9da":["417142ff08fda9cf0b72d5133e63097a166c6458"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a":["e5d3b3ab0062c441ef30035f527dbb188c70d9da"],"f592209545c71895260367152601e9200399776d":["e5d3b3ab0062c441ef30035f527dbb188c70d9da","9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a"],"417142ff08fda9cf0b72d5133e63097a166c6458":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc47cb7b4346802411bb432f501ed0673d7119e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"e5d3b3ab0062c441ef30035f527dbb188c70d9da":["b70042a8a492f7054d480ccdd2be9796510d4327","9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a","f592209545c71895260367152601e9200399776d"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f592209545c71895260367152601e9200399776d":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["e5d3b3ab0062c441ef30035f527dbb188c70d9da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}