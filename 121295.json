{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","commits":[{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":1,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerProcessor.getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2209af2c265d2258ec4b29c8cc78622d36994a15","date":1440641916,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerProcessor.getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5551d21c759979ad637581208f5ff5bd7497b5d7","date":1447783672,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19498030e0adab22f604f935cae3c03dcf0952a6","date":1456558851,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"073f1aa70444ec64f3e216816af2a3b43fa38fe7","date":1488920481,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, OverseerElectionContext.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    stateUpdateQueue.offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":["19498030e0adab22f604f935cae3c03dcf0952a6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      if (log.isInfoEnabled()) {\n        log.info(\"asking the old first in line {} to rejoin election  \", electionNodes.get(1));\n      }\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    stateUpdateQueue.offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    stateUpdateQueue.offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    @SuppressWarnings({\"rawtypes\"})\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    @SuppressWarnings({\"rawtypes\"})\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      if (log.isInfoEnabled()) {\n        log.info(\"asking the old first in line {} to rejoin election  \", electionNodes.get(1));\n      }\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    stateUpdateQueue.offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws Exception {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerTaskProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zk, Overseer.OVERSEER_ELECT + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      if (log.isInfoEnabled()) {\n        log.info(\"asking the old first in line {} to rejoin election  \", electionNodes.get(1));\n      }\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    stateUpdateQueue.offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            ID, OverseerTaskProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5551d21c759979ad637581208f5ff5bd7497b5d7":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"af2638813028b254a88b418ebeafb541afb49653":["5551d21c759979ad637581208f5ff5bd7497b5d7","19498030e0adab22f604f935cae3c03dcf0952a6"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"ad4957cde742defe6db19689abdc267c5d948066":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"19498030e0adab22f604f935cae3c03dcf0952a6":["5551d21c759979ad637581208f5ff5bd7497b5d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["ad4957cde742defe6db19689abdc267c5d948066"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["af2638813028b254a88b418ebeafb541afb49653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"]},"commit2Childs":{"5551d21c759979ad637581208f5ff5bd7497b5d7":["af2638813028b254a88b418ebeafb541afb49653","19498030e0adab22f604f935cae3c03dcf0952a6"],"af2638813028b254a88b418ebeafb541afb49653":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["5551d21c759979ad637581208f5ff5bd7497b5d7"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ad4957cde742defe6db19689abdc267c5d948066"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ad4957cde742defe6db19689abdc267c5d948066":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"b869898f50ca80263bac2e3ae0949f7700e5c977":[],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"19498030e0adab22f604f935cae3c03dcf0952a6":["af2638813028b254a88b418ebeafb541afb49653"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b869898f50ca80263bac2e3ae0949f7700e5c977","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}