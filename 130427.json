{"path":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"c286b0d8c507a88b289407e2fe161effa275c6b0","date":1562615977,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    return new ConstantScoreWeight(this, boost) {\n\n      /** create a visitor that adds documents that match the query using a sparse bitset. (Used by INTERSECT) */\n      protected IntersectVisitor getSparseIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          final int[] scratchTriangle = new int[6];\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              visit(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              int docID;\n              while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                visit(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, ShapeField.QueryRelation.INTERSECTS);\n          }\n        };\n      }\n\n      /** create a visitor that adds documents that match the query using a dense bitset. (Used by WITHIN, DISJOINT) */\n      protected IntersectVisitor getDenseIntersectVisitor(FixedBitSet intersect, FixedBitSet disjoint, ShapeField.QueryRelation queryRelation) {\n        return new IntersectVisitor() {\n          final int[] scratchTriangle = new int[6];\n          @Override\n          public void visit(int docID) throws IOException {\n            if (queryRelation == ShapeField.QueryRelation.DISJOINT) {\n              // if DISJOINT query set the doc in the disjoint bitset\n              disjoint.set(docID);\n            } else {\n              // for INTERSECT, and WITHIN queries we set the intersect bitset\n              intersect.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, queryRelation)) {\n              intersect.set(docID);\n            } else {\n              disjoint.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            boolean queryMatches = queryMatches(t, scratchTriangle, queryRelation);\n            int docID;\n            while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n              if (queryMatches) {\n                intersect.set(docID);\n              } else {\n                disjoint.set(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, queryRelation);\n          }\n        };\n      }\n\n      /** get a scorer supplier for INTERSECT queries */\n      protected ScorerSupplier getIntersectScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        IntersectVisitor visitor = getSparseIntersectVisitor(result);\n        return new RelationScorerSupplier(values, visitor, null, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getIntersectsScorer(ShapeQuery.this, reader, weight, result, score(), scoreMode);\n          }\n        };\n      }\n\n      /** get a scorer supplier for all other queries (DISJOINT, WITHIN) */\n      protected ScorerSupplier getScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        if (queryRelation == ShapeField.QueryRelation.INTERSECTS) {\n          return getIntersectScorerSupplier(reader, values, weight, scoreMode);\n        }\n        //For within and disjoint we need two passes to remove false positives in case of multi-shapes.\n        FixedBitSet within = new FixedBitSet(reader.maxDoc());\n        FixedBitSet disjoint = new FixedBitSet(reader.maxDoc());\n        IntersectVisitor withinVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.WITHIN);\n        IntersectVisitor disjointVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.DISJOINT);\n        return new RelationScorerSupplier(values, withinVisitor, disjointVisitor, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getScorer(ShapeQuery.this, weight, within, disjoint, score(), scoreMode);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        boolean allDocsMatch = true;\n        if (values.getDocCount() != reader.maxDoc() ||\n            relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation) != Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return getScorerSupplier(reader, values, weight, scoreMode);\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    return new ConstantScoreWeight(this, boost) {\n\n      /** create a visitor that adds documents that match the query using a sparse bitset. (Used by INTERSECT) */\n      protected IntersectVisitor getSparseIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          final int[] scratchTriangle = new int[6];\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              visit(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              int docID;\n              while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                visit(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, QueryRelation.INTERSECTS);\n          }\n        };\n      }\n\n      /** create a visitor that adds documents that match the query using a dense bitset. (Used by WITHIN, DISJOINT) */\n      protected IntersectVisitor getDenseIntersectVisitor(FixedBitSet intersect, FixedBitSet disjoint, QueryRelation queryRelation) {\n        return new IntersectVisitor() {\n          final int[] scratchTriangle = new int[6];\n          @Override\n          public void visit(int docID) throws IOException {\n            if (queryRelation == QueryRelation.DISJOINT) {\n              // if DISJOINT query set the doc in the disjoint bitset\n              disjoint.set(docID);\n            } else {\n              // for INTERSECT, and WITHIN queries we set the intersect bitset\n              intersect.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, queryRelation)) {\n              intersect.set(docID);\n            } else {\n              disjoint.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            boolean queryMatches = queryMatches(t, scratchTriangle, queryRelation);\n            int docID;\n            while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n              if (queryMatches) {\n                intersect.set(docID);\n              } else {\n                disjoint.set(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, queryRelation);\n          }\n        };\n      }\n\n      /** get a scorer supplier for INTERSECT queries */\n      protected ScorerSupplier getIntersectScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        IntersectVisitor visitor = getSparseIntersectVisitor(result);\n        return new RelationScorerSupplier(values, visitor, null, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getIntersectsScorer(LatLonShapeQuery.this, reader, weight, result, score(), scoreMode);\n          }\n        };\n      }\n\n      /** get a scorer supplier for all other queries (DISJOINT, WITHIN) */\n      protected ScorerSupplier getScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        if (queryRelation == QueryRelation.INTERSECTS) {\n          return getIntersectScorerSupplier(reader, values, weight, scoreMode);\n        }\n        //For within and disjoint we need two passes to remove false positives in case of multi-shapes.\n        FixedBitSet within = new FixedBitSet(reader.maxDoc());\n        FixedBitSet disjoint = new FixedBitSet(reader.maxDoc());\n        IntersectVisitor withinVisitor = getDenseIntersectVisitor(within, disjoint, QueryRelation.WITHIN);\n        IntersectVisitor disjointVisitor = getDenseIntersectVisitor(within, disjoint, QueryRelation.DISJOINT);\n        return new RelationScorerSupplier(values, withinVisitor, disjointVisitor, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getScorer(LatLonShapeQuery.this, weight, within, disjoint, score(), scoreMode);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        boolean allDocsMatch = true;\n        if (values.getDocCount() != reader.maxDoc() ||\n            relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation) != Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return getScorerSupplier(reader, values, weight, scoreMode);\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ed90f8ba7e7be13d155f954862178b23a324125","date":1568020603,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    return new ConstantScoreWeight(this, boost) {\n\n      /** create a visitor that adds documents that match the query using a sparse bitset. (Used by INTERSECT) */\n      protected IntersectVisitor getSparseIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          final ShapeField.DecodedTriangle scratchTriangle = new ShapeField.DecodedTriangle();\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              visit(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              int docID;\n              while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                visit(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, ShapeField.QueryRelation.INTERSECTS);\n          }\n        };\n      }\n\n      /** create a visitor that adds documents that match the query using a dense bitset. (Used by WITHIN, DISJOINT) */\n      protected IntersectVisitor getDenseIntersectVisitor(FixedBitSet intersect, FixedBitSet disjoint, ShapeField.QueryRelation queryRelation) {\n        return new IntersectVisitor() {\n          final ShapeField.DecodedTriangle scratchTriangle = new ShapeField.DecodedTriangle();\n          @Override\n          public void visit(int docID) throws IOException {\n            if (queryRelation == ShapeField.QueryRelation.DISJOINT) {\n              // if DISJOINT query set the doc in the disjoint bitset\n              disjoint.set(docID);\n            } else {\n              // for INTERSECT, and WITHIN queries we set the intersect bitset\n              intersect.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, queryRelation)) {\n              intersect.set(docID);\n            } else {\n              disjoint.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            boolean queryMatches = queryMatches(t, scratchTriangle, queryRelation);\n            int docID;\n            while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n              if (queryMatches) {\n                intersect.set(docID);\n              } else {\n                disjoint.set(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, queryRelation);\n          }\n        };\n      }\n\n      /** get a scorer supplier for INTERSECT queries */\n      protected ScorerSupplier getIntersectScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        IntersectVisitor visitor = getSparseIntersectVisitor(result);\n        return new RelationScorerSupplier(values, visitor, null, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getIntersectsScorer(ShapeQuery.this, reader, weight, result, score(), scoreMode);\n          }\n        };\n      }\n\n      /** get a scorer supplier for all other queries (DISJOINT, WITHIN) */\n      protected ScorerSupplier getScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        if (queryRelation == ShapeField.QueryRelation.INTERSECTS) {\n          return getIntersectScorerSupplier(reader, values, weight, scoreMode);\n        }\n        //For within and disjoint we need two passes to remove false positives in case of multi-shapes.\n        FixedBitSet within = new FixedBitSet(reader.maxDoc());\n        FixedBitSet disjoint = new FixedBitSet(reader.maxDoc());\n        IntersectVisitor withinVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.WITHIN);\n        IntersectVisitor disjointVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.DISJOINT);\n        return new RelationScorerSupplier(values, withinVisitor, disjointVisitor, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getScorer(ShapeQuery.this, weight, within, disjoint, score(), scoreMode);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        boolean allDocsMatch = true;\n        if (values.getDocCount() != reader.maxDoc() ||\n            relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation) != Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return getScorerSupplier(reader, values, weight, scoreMode);\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    return new ConstantScoreWeight(this, boost) {\n\n      /** create a visitor that adds documents that match the query using a sparse bitset. (Used by INTERSECT) */\n      protected IntersectVisitor getSparseIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          final int[] scratchTriangle = new int[6];\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              visit(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              int docID;\n              while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                visit(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, ShapeField.QueryRelation.INTERSECTS);\n          }\n        };\n      }\n\n      /** create a visitor that adds documents that match the query using a dense bitset. (Used by WITHIN, DISJOINT) */\n      protected IntersectVisitor getDenseIntersectVisitor(FixedBitSet intersect, FixedBitSet disjoint, ShapeField.QueryRelation queryRelation) {\n        return new IntersectVisitor() {\n          final int[] scratchTriangle = new int[6];\n          @Override\n          public void visit(int docID) throws IOException {\n            if (queryRelation == ShapeField.QueryRelation.DISJOINT) {\n              // if DISJOINT query set the doc in the disjoint bitset\n              disjoint.set(docID);\n            } else {\n              // for INTERSECT, and WITHIN queries we set the intersect bitset\n              intersect.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, queryRelation)) {\n              intersect.set(docID);\n            } else {\n              disjoint.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            boolean queryMatches = queryMatches(t, scratchTriangle, queryRelation);\n            int docID;\n            while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n              if (queryMatches) {\n                intersect.set(docID);\n              } else {\n                disjoint.set(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, queryRelation);\n          }\n        };\n      }\n\n      /** get a scorer supplier for INTERSECT queries */\n      protected ScorerSupplier getIntersectScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        IntersectVisitor visitor = getSparseIntersectVisitor(result);\n        return new RelationScorerSupplier(values, visitor, null, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getIntersectsScorer(ShapeQuery.this, reader, weight, result, score(), scoreMode);\n          }\n        };\n      }\n\n      /** get a scorer supplier for all other queries (DISJOINT, WITHIN) */\n      protected ScorerSupplier getScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        if (queryRelation == ShapeField.QueryRelation.INTERSECTS) {\n          return getIntersectScorerSupplier(reader, values, weight, scoreMode);\n        }\n        //For within and disjoint we need two passes to remove false positives in case of multi-shapes.\n        FixedBitSet within = new FixedBitSet(reader.maxDoc());\n        FixedBitSet disjoint = new FixedBitSet(reader.maxDoc());\n        IntersectVisitor withinVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.WITHIN);\n        IntersectVisitor disjointVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.DISJOINT);\n        return new RelationScorerSupplier(values, withinVisitor, disjointVisitor, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getScorer(ShapeQuery.this, weight, within, disjoint, score(), scoreMode);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        boolean allDocsMatch = true;\n        if (values.getDocCount() != reader.maxDoc() ||\n            relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation) != Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return getScorerSupplier(reader, values, weight, scoreMode);\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"637ced5887480f9803707c2fc68df68ce0c0bf13","date":1568120036,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY) {\n          // no documents match the query\n          return null;\n        }\n        else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    return new ConstantScoreWeight(this, boost) {\n\n      /** create a visitor that adds documents that match the query using a sparse bitset. (Used by INTERSECT) */\n      protected IntersectVisitor getSparseIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          final ShapeField.DecodedTriangle scratchTriangle = new ShapeField.DecodedTriangle();\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              visit(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, QueryRelation.INTERSECTS)) {\n              int docID;\n              while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                visit(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, ShapeField.QueryRelation.INTERSECTS);\n          }\n        };\n      }\n\n      /** create a visitor that adds documents that match the query using a dense bitset. (Used by WITHIN, DISJOINT) */\n      protected IntersectVisitor getDenseIntersectVisitor(FixedBitSet intersect, FixedBitSet disjoint, ShapeField.QueryRelation queryRelation) {\n        return new IntersectVisitor() {\n          final ShapeField.DecodedTriangle scratchTriangle = new ShapeField.DecodedTriangle();\n          @Override\n          public void visit(int docID) throws IOException {\n            if (queryRelation == ShapeField.QueryRelation.DISJOINT) {\n              // if DISJOINT query set the doc in the disjoint bitset\n              disjoint.set(docID);\n            } else {\n              // for INTERSECT, and WITHIN queries we set the intersect bitset\n              intersect.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(int docID, byte[] t) throws IOException {\n            if (queryMatches(t, scratchTriangle, queryRelation)) {\n              intersect.set(docID);\n            } else {\n              disjoint.set(docID);\n            }\n          }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] t) throws IOException {\n            boolean queryMatches = queryMatches(t, scratchTriangle, queryRelation);\n            int docID;\n            while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n              if (queryMatches) {\n                intersect.set(docID);\n              } else {\n                disjoint.set(docID);\n              }\n            }\n          }\n\n          @Override\n          public Relation compare(byte[] minTriangle, byte[] maxTriangle) {\n            return relateRangeToQuery(minTriangle, maxTriangle, queryRelation);\n          }\n        };\n      }\n\n      /** get a scorer supplier for INTERSECT queries */\n      protected ScorerSupplier getIntersectScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        IntersectVisitor visitor = getSparseIntersectVisitor(result);\n        return new RelationScorerSupplier(values, visitor, null, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getIntersectsScorer(ShapeQuery.this, reader, weight, result, score(), scoreMode);\n          }\n        };\n      }\n\n      /** get a scorer supplier for all other queries (DISJOINT, WITHIN) */\n      protected ScorerSupplier getScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {\n        if (queryRelation == ShapeField.QueryRelation.INTERSECTS) {\n          return getIntersectScorerSupplier(reader, values, weight, scoreMode);\n        }\n        //For within and disjoint we need two passes to remove false positives in case of multi-shapes.\n        FixedBitSet within = new FixedBitSet(reader.maxDoc());\n        FixedBitSet disjoint = new FixedBitSet(reader.maxDoc());\n        IntersectVisitor withinVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.WITHIN);\n        IntersectVisitor disjointVisitor = getDenseIntersectVisitor(within, disjoint, ShapeField.QueryRelation.DISJOINT);\n        return new RelationScorerSupplier(values, withinVisitor, disjointVisitor, queryRelation) {\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return getScorer(ShapeQuery.this, weight, within, disjoint, score(), scoreMode);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        boolean allDocsMatch = true;\n        if (values.getDocCount() != reader.maxDoc() ||\n            relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation) != Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return getScorerSupplier(reader, values, weight, scoreMode);\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f2d8fb73c718c3fc5600f453cc514f18ae1b8c3","date":1576052211,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY || (rel == Relation.CELL_INSIDE_QUERY && queryRelation == QueryRelation.CONTAINS)) {\n          // no documents match the query\n          return null;\n        } else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && queryRelation != QueryRelation.CONTAINS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY) {\n          // no documents match the query\n          return null;\n        }\n        else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c6b7e01cb749c3b01e226e06085dfb1d9ed8eab","date":1576073026,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY || (rel == Relation.CELL_INSIDE_QUERY && queryRelation == QueryRelation.CONTAINS)) {\n          // no documents match the query\n          return null;\n        } else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && queryRelation != QueryRelation.CONTAINS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY) {\n          // no documents match the query\n          return null;\n        }\n        else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c1e6d465800c73af60624bf9d4459a19f7940c","date":1579293280,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY || (rel == Relation.CELL_INSIDE_QUERY && queryRelation == QueryRelation.CONTAINS)) {\n          // no documents match the query\n          return null;\n        } else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && queryRelation != QueryRelation.CONTAINS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) {\n    final ShapeQuery query = this;\n    return new ConstantScoreWeight(query, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        final FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n\n        final Weight weight = this;\n        final Relation rel = relateRangeToQuery(values.getMinPackedValue(), values.getMaxPackedValue(), queryRelation);\n        if (rel == Relation.CELL_OUTSIDE_QUERY || (rel == Relation.CELL_INSIDE_QUERY && queryRelation == QueryRelation.CONTAINS)) {\n          // no documents match the query\n          return null;\n        } else if (values.getDocCount() == reader.maxDoc() && rel == Relation.CELL_INSIDE_QUERY) {\n          // all documents match the query\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          if (queryRelation != QueryRelation.INTERSECTS\n              && queryRelation != QueryRelation.CONTAINS\n              && hasAnyHits(query, values) == false) {\n            // First we check if we have any hits so we are fast in the adversarial case where\n            // the shape does not match any documents and we are in the dense case\n            return null;\n          }\n          // walk the tree to get matching documents\n          return new RelationScorerSupplier(values, ShapeQuery.this) {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              return getScorer(reader, weight, score(), scoreMode);\n            }\n          };\n        }\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6c6b7e01cb749c3b01e226e06085dfb1d9ed8eab":["637ced5887480f9803707c2fc68df68ce0c0bf13","3f2d8fb73c718c3fc5600f453cc514f18ae1b8c3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09c1e6d465800c73af60624bf9d4459a19f7940c":["3f2d8fb73c718c3fc5600f453cc514f18ae1b8c3"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ed90f8ba7e7be13d155f954862178b23a324125":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"3f2d8fb73c718c3fc5600f453cc514f18ae1b8c3":["637ced5887480f9803707c2fc68df68ce0c0bf13"],"637ced5887480f9803707c2fc68df68ce0c0bf13":["5ed90f8ba7e7be13d155f954862178b23a324125"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09c1e6d465800c73af60624bf9d4459a19f7940c"]},"commit2Childs":{"6c6b7e01cb749c3b01e226e06085dfb1d9ed8eab":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"09c1e6d465800c73af60624bf9d4459a19f7940c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["5ed90f8ba7e7be13d155f954862178b23a324125"],"5ed90f8ba7e7be13d155f954862178b23a324125":["637ced5887480f9803707c2fc68df68ce0c0bf13"],"3f2d8fb73c718c3fc5600f453cc514f18ae1b8c3":["6c6b7e01cb749c3b01e226e06085dfb1d9ed8eab","09c1e6d465800c73af60624bf9d4459a19f7940c"],"637ced5887480f9803707c2fc68df68ce0c0bf13":["6c6b7e01cb749c3b01e226e06085dfb1d9ed8eab","3f2d8fb73c718c3fc5600f453cc514f18ae1b8c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6c6b7e01cb749c3b01e226e06085dfb1d9ed8eab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}