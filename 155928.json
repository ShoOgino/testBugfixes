{"path":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","commits":[{"id":"7ecad62a91d16f94e09186098207ad6865137c58","date":1174933286,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            // TODO: SOLR-179?\n            log.warning( \"multiple handlers registered on the same path! ignoring: \"+old );\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          // TODO: SOLR-179\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          // TODO: SOLR-179\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"368c8927753a9ca6ee214a251da2746ff35aeef6","date":1177630664,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            // TODO: SOLR-179?\n            log.warning( \"multiple handlers registered on the same path! ignoring: \"+old );\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            // TODO: SOLR-179?\n            log.warning( \"multiple handlers registered on the same path! ignoring: \"+old );\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          // TODO: SOLR-179\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          // TODO: SOLR-179\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aceda38d9d3f703668f1a4569473f90880ed3f1e","date":1178744011,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            String msg = \"multiple handlers registered on the same path! ignoring: \"+old;\n            Throwable t = new SolrException( 500, msg );\n            SolrConfig.severeErrors.add( t );\n            SolrException.logOnce(log,null,t);\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            // TODO: SOLR-179?\n            log.warning( \"multiple handlers registered on the same path! ignoring: \"+old );\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            String msg = \"multiple handlers registered on the same path! ignoring: \"+old;\n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrConfig.severeErrors.add( t );\n            SolrException.logOnce(log,null,t);\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            String msg = \"multiple handlers registered on the same path! ignoring: \"+old;\n            Throwable t = new SolrException( 500, msg );\n            SolrConfig.severeErrors.add( t );\n            SolrException.logOnce(log,null,t);\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4cc0532e82274748c1910318b92089c5604e48a","date":1183443010,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true )\n    {\n      @Override\n      protected SolrRequestHandler create( String name, String className, Map<String,String> params, Node node ) throws Exception\n      {\n        String startup = params.get( \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( name, className, params, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Map<String, String> params, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initalizad \n   * before they are registered, this function does not do that exactly.\n   * \n   * This funciton registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initalized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are avaliable at startup.\n   * \n   * Handlers will be registered and initalized in the order they appear in solrconfig.xml\n   */\n  @SuppressWarnings(\"unchecked\")\n  void initHandlersFromConfig( Config config )  \n  {\n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    if (nodes !=null ) {\n      // make sure it only once/handler and that that handlers get initalized in the \n      // order they were defined\n      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); \n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name = DOMUtil.getAttr(node,\"name\",\"requestHandler config\");\n          String className = DOMUtil.getAttr(node,\"class\",\"requestHandler config\");\n          String startup = DOMUtil.getAttr(node,\"startup\", null );\n          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);\n  \n          // Perhaps lazy load the request handler with a wrapper\n          SolrRequestHandler handler = null;\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + name + \"=\" + className);\n            handler = new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );\n            log.info(\"adding requestHandler: \" + name + \"=\" + className);\n            handler = clazz.newInstance();\n          }\n          \n          SolrRequestHandler old = register( name, handler );\n          if( old != null ) {\n            String msg = \"multiple handlers registered on the same path! ignoring: \"+old;\n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrConfig.severeErrors.add( t );\n            SolrException.logOnce(log,null,t);\n          }\n          names.put( name, args );\n        } \n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n      \n      // Call init() on each handler after they have all been registered\n      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {\n        try {\n          handlers.get( reg.getKey() ).init( reg.getValue() );\n        }\n        catch( Exception e ) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    //\n    // Get the default handler and add it in the map under null and empty\n    // to act as the default.\n    //\n    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n    if (handler == null) {\n      handler = new StandardRequestHandler();\n      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);\n    }\n    register(null, handler);\n    register(\"\", handler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1","date":1183450581,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true )\n    {\n      @Override\n      protected SolrRequestHandler create( String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true )\n    {\n      @Override\n      protected SolrRequestHandler create( String name, String className, Map<String,String> params, Node node ) throws Exception\n      {\n        String startup = params.get( \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( name, className, params, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Map<String, String> params, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6589002090bd74db749eef5befe2f447c0e3dd49","date":1184345280,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true )\n    {\n      @Override\n      protected SolrRequestHandler create( String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( SolrCore core, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( core, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( core, nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7","date":1189312484,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( final Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( Config config, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( config, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( config, nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( SolrCore core, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( core, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( core, nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014","date":1195912306,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( final Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( ResourceLoader config, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( config, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( config.getResourceLoader(), nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( final Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( Config config, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( config, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( config, nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dbb193e1674e022fe0f7df04a444307bff223b7","date":1229519560,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( final Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( ResourceLoader config, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( config, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( config.getResourceLoader(), nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(\"\", defaultHandler);\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( final Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( ResourceLoader config, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( config, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( config.getResourceLoader(), nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(null, defaultHandler);\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"696ae660e2377ef5574e572e9969026ed20f36cb","date":1244283521,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(Config).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    Map<SolrConfig.PluginInfo,SolrRequestHandler> handlers = new HashMap<SolrConfig.PluginInfo,SolrRequestHandler>();\n    for (SolrConfig.PluginInfo info : config.reqHandlerInfo) {\n      try {\n        SolrRequestHandler requestHandler;\n        if( info.startup != null ) {\n          if( \"lazy\".equals(info.startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+info.startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = (SolrRequestHandler) config.getResourceLoader().newInstance(info.className);\n        }\n        handlers.put(info,requestHandler);\n        requestHandler.init(info.initArgs);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n      }\n    }\n    for (Map.Entry<SolrConfig.PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      entry.getValue().init(entry.getKey().initArgs);\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized \n   * before they are registered, this function does not do that exactly.\n   * \n   * This function registers all handlers first and then calls init() for each one.  \n   * \n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n  void initHandlersFromConfig( final Config config )  \n  {\n    final RequestHandlers handlers = this;\n    AbstractPluginLoader<SolrRequestHandler> loader = \n      new AbstractPluginLoader<SolrRequestHandler>( \"[solrconfig.xml] requestHandler\", true, true )\n    {\n      @Override\n      protected SolrRequestHandler create( ResourceLoader config, String name, String className, Node node ) throws Exception\n      {    \n        String startup = DOMUtil.getAttr( node, \"startup\" );\n        if( startup != null ) {\n          if( \"lazy\".equals( startup ) ) {\n            log.info(\"adding lazy requestHandler: \" + className );\n            NamedList args = DOMUtil.childNodesToNamedList(node);\n            return new LazyRequestHandlerWrapper( core, className, args );\n          }\n          else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+className );\n          }\n        }\n        return super.create( config, name, className, node );\n      }\n\n      @Override\n      protected SolrRequestHandler register(String name, SolrRequestHandler plugin) throws Exception {\n        return handlers.register( name, plugin );\n      }\n      \n      @Override\n      protected void init(SolrRequestHandler plugin, Node node ) throws Exception {\n        plugin.init( DOMUtil.childNodesToNamedList(node) );\n      }      \n    };\n    \n    NodeList nodes = (NodeList)config.evaluate(\"requestHandler\", XPathConstants.NODESET);\n    \n    // Load the handlers and get the default one\n    SolrRequestHandler defaultHandler = loader.load( config.getResourceLoader(), nodes );\n    if( defaultHandler == null ) {\n      defaultHandler = get(RequestHandlers.DEFAULT_HANDLER_NAME);\n      if( defaultHandler == null ) {\n        defaultHandler = new StandardRequestHandler();\n        register(RequestHandlers.DEFAULT_HANDLER_NAME, defaultHandler);\n      }\n    }\n    register(\"\", defaultHandler);\n  }\n\n","bugFix":null,"bugIntro":["0aea57ab530d174e645bf6e14d04db1e243e13d7","aac723595c848b3bb678eec506ae63c85102b6ec"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"aceda38d9d3f703668f1a4569473f90880ed3f1e":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"6d6338c87060be5f66757a94945975f3bbd377a9":["6589002090bd74db749eef5befe2f447c0e3dd49"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["7ecad62a91d16f94e09186098207ad6865137c58"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["aceda38d9d3f703668f1a4569473f90880ed3f1e"],"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1":["a4cc0532e82274748c1910318b92089c5604e48a"],"a4cc0532e82274748c1910318b92089c5604e48a":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"696ae660e2377ef5574e572e9969026ed20f36cb":["2dbb193e1674e022fe0f7df04a444307bff223b7"],"6589002090bd74db749eef5befe2f447c0e3dd49":["29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1"],"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["6d6338c87060be5f66757a94945975f3bbd377a9"],"7ecad62a91d16f94e09186098207ad6865137c58":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"2dbb193e1674e022fe0f7df04a444307bff223b7":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"aceda38d9d3f703668f1a4569473f90880ed3f1e":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"6d6338c87060be5f66757a94945975f3bbd377a9":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["aceda38d9d3f703668f1a4569473f90880ed3f1e"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["7ecad62a91d16f94e09186098207ad6865137c58"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["a4cc0532e82274748c1910318b92089c5604e48a"],"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1":["6589002090bd74db749eef5befe2f447c0e3dd49"],"a4cc0532e82274748c1910318b92089c5604e48a":["29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6589002090bd74db749eef5befe2f447c0e3dd49":["6d6338c87060be5f66757a94945975f3bbd377a9"],"696ae660e2377ef5574e572e9969026ed20f36cb":[],"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014":["2dbb193e1674e022fe0f7df04a444307bff223b7"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014"],"7ecad62a91d16f94e09186098207ad6865137c58":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"2dbb193e1674e022fe0f7df04a444307bff223b7":["696ae660e2377ef5574e572e9969026ed20f36cb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["696ae660e2377ef5574e572e9969026ed20f36cb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}