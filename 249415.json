{"path":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","commits":[{"id":"056868364d4e4a9ab9351ae5cc55e0506fe19769","date":1473148338,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","pathOld":"/dev/null","sourceNew":"  public void writeResponse(OutputStream out, LinkedHashMap<String, String> colNamesMap,\n                            LinkedHashMap<String, Integer> colWidthsMap) throws IOException {\n    SolrParams params = req.getParams();\n\n    Collection<String> fields = returnFields.getRequestedFieldNames();\n    Object responseObj = rsp.getValues().get(\"response\");\n    boolean returnOnlyStored = false;\n    if (fields==null||returnFields.hasPatternMatching()) {\n      if (responseObj instanceof SolrDocumentList) {\n        // get the list of fields from the SolrDocumentList\n        if(fields==null) {\n          fields = new LinkedHashSet<String>();\n        }\n        for (SolrDocument sdoc: (SolrDocumentList)responseObj) {\n          fields.addAll(sdoc.getFieldNames());\n        }\n      } else {\n        // get the list of fields from the index\n        Iterable<String> all = req.getSearcher().getFieldNames();\n        if (fields == null) {\n          fields = Sets.newHashSet(all);\n        } else {\n          Iterables.addAll(fields, all);\n        }\n      }\n      if (returnFields.wantsScore()) {\n        fields.add(\"score\");\n      } else {\n        fields.remove(\"score\");\n      }\n      returnOnlyStored = true;\n    }\n\n    for (String field : fields) {\n      if (!returnFields.wantsField(field)) {\n        continue;\n      }\n      if (field.equals(\"score\")) {\n        XLField xlField = new XLField();\n        xlField.name = \"score\";\n        xlFields.put(\"score\", xlField);\n        continue;\n      }\n\n      SchemaField sf = schema.getFieldOrNull(field);\n      if (sf == null) {\n        FieldType ft = new StrField();\n        sf = new SchemaField(field, ft);\n      }\n\n      // Return only stored fields, unless an explicit field list is specified\n      if (returnOnlyStored && sf != null && !sf.stored()) {\n        continue;\n      }\n\n      XLField xlField = new XLField();\n      xlField.name = field;\n      xlField.sf = sf;\n      xlFields.put(field, xlField);\n    }\n\n\n\n    wb.addRow();\n    //write header\n    for (XLField xlField : xlFields.values()) {\n      String printName = xlField.name;\n      int colWidth = 14;\n\n      String niceName = colNamesMap.get(xlField.name);\n      if (niceName != null) {\n        printName = niceName;\n      }\n\n      Integer niceWidth = colWidthsMap.get(xlField.name);\n      if (niceWidth != null) {\n        colWidth = niceWidth.intValue();\n      }\n\n      writeStr(xlField.name, printName, false);\n      wb.setColWidth(colWidth);\n      wb.setHeaderCell();\n    }\n    wb.setHeaderRow();\n    wb.addRow();\n\n    if (responseObj instanceof ResultContext) {\n      writeDocuments(null, (ResultContext)responseObj );\n    }\n    else if (responseObj instanceof DocList) {\n      ResultContext ctx = new BasicResultContext((DocList)responseObj, returnFields, null, null, req);\n      writeDocuments(null, ctx );\n    } else if (responseObj instanceof SolrDocumentList) {\n      writeSolrDocumentList(null, (SolrDocumentList)responseObj, returnFields );\n    }\n\n    wb.flush(out);\n    wb = null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["080177034f0f8c5fc458255dbe1e84334b531ade"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","pathOld":"/dev/null","sourceNew":"  public void writeResponse(OutputStream out, LinkedHashMap<String, String> colNamesMap,\n                            LinkedHashMap<String, Integer> colWidthsMap) throws IOException {\n    SolrParams params = req.getParams();\n\n    Collection<String> fields = returnFields.getRequestedFieldNames();\n    Object responseObj = rsp.getValues().get(\"response\");\n    boolean returnOnlyStored = false;\n    if (fields==null||returnFields.hasPatternMatching()) {\n      if (responseObj instanceof SolrDocumentList) {\n        // get the list of fields from the SolrDocumentList\n        if(fields==null) {\n          fields = new LinkedHashSet<String>();\n        }\n        for (SolrDocument sdoc: (SolrDocumentList)responseObj) {\n          fields.addAll(sdoc.getFieldNames());\n        }\n      } else {\n        // get the list of fields from the index\n        Iterable<String> all = req.getSearcher().getFieldNames();\n        if (fields == null) {\n          fields = Sets.newHashSet(all);\n        } else {\n          Iterables.addAll(fields, all);\n        }\n      }\n      if (returnFields.wantsScore()) {\n        fields.add(\"score\");\n      } else {\n        fields.remove(\"score\");\n      }\n      returnOnlyStored = true;\n    }\n\n    for (String field : fields) {\n      if (!returnFields.wantsField(field)) {\n        continue;\n      }\n      if (field.equals(\"score\")) {\n        XLField xlField = new XLField();\n        xlField.name = \"score\";\n        xlFields.put(\"score\", xlField);\n        continue;\n      }\n\n      SchemaField sf = schema.getFieldOrNull(field);\n      if (sf == null) {\n        FieldType ft = new StrField();\n        sf = new SchemaField(field, ft);\n      }\n\n      // Return only stored fields, unless an explicit field list is specified\n      if (returnOnlyStored && sf != null && !sf.stored()) {\n        continue;\n      }\n\n      XLField xlField = new XLField();\n      xlField.name = field;\n      xlField.sf = sf;\n      xlFields.put(field, xlField);\n    }\n\n\n\n    wb.addRow();\n    //write header\n    for (XLField xlField : xlFields.values()) {\n      String printName = xlField.name;\n      int colWidth = 14;\n\n      String niceName = colNamesMap.get(xlField.name);\n      if (niceName != null) {\n        printName = niceName;\n      }\n\n      Integer niceWidth = colWidthsMap.get(xlField.name);\n      if (niceWidth != null) {\n        colWidth = niceWidth.intValue();\n      }\n\n      writeStr(xlField.name, printName, false);\n      wb.setColWidth(colWidth);\n      wb.setHeaderCell();\n    }\n    wb.setHeaderRow();\n    wb.addRow();\n\n    if (responseObj instanceof ResultContext) {\n      writeDocuments(null, (ResultContext)responseObj );\n    }\n    else if (responseObj instanceof DocList) {\n      ResultContext ctx = new BasicResultContext((DocList)responseObj, returnFields, null, null, req);\n      writeDocuments(null, ctx );\n    } else if (responseObj instanceof SolrDocumentList) {\n      writeSolrDocumentList(null, (SolrDocumentList)responseObj, returnFields );\n    }\n\n    wb.flush(out);\n    wb = null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","pathOld":"/dev/null","sourceNew":"  public void writeResponse(OutputStream out, LinkedHashMap<String, String> colNamesMap,\n                            LinkedHashMap<String, Integer> colWidthsMap) throws IOException {\n    SolrParams params = req.getParams();\n\n    Collection<String> fields = returnFields.getRequestedFieldNames();\n    Object responseObj = rsp.getValues().get(\"response\");\n    boolean returnOnlyStored = false;\n    if (fields==null||returnFields.hasPatternMatching()) {\n      if (responseObj instanceof SolrDocumentList) {\n        // get the list of fields from the SolrDocumentList\n        if(fields==null) {\n          fields = new LinkedHashSet<String>();\n        }\n        for (SolrDocument sdoc: (SolrDocumentList)responseObj) {\n          fields.addAll(sdoc.getFieldNames());\n        }\n      } else {\n        // get the list of fields from the index\n        Iterable<String> all = req.getSearcher().getFieldNames();\n        if (fields == null) {\n          fields = Sets.newHashSet(all);\n        } else {\n          Iterables.addAll(fields, all);\n        }\n      }\n      if (returnFields.wantsScore()) {\n        fields.add(\"score\");\n      } else {\n        fields.remove(\"score\");\n      }\n      returnOnlyStored = true;\n    }\n\n    for (String field : fields) {\n      if (!returnFields.wantsField(field)) {\n        continue;\n      }\n      if (field.equals(\"score\")) {\n        XLField xlField = new XLField();\n        xlField.name = \"score\";\n        xlFields.put(\"score\", xlField);\n        continue;\n      }\n\n      SchemaField sf = schema.getFieldOrNull(field);\n      if (sf == null) {\n        FieldType ft = new StrField();\n        sf = new SchemaField(field, ft);\n      }\n\n      // Return only stored fields, unless an explicit field list is specified\n      if (returnOnlyStored && sf != null && !sf.stored()) {\n        continue;\n      }\n\n      XLField xlField = new XLField();\n      xlField.name = field;\n      xlField.sf = sf;\n      xlFields.put(field, xlField);\n    }\n\n\n\n    wb.addRow();\n    //write header\n    for (XLField xlField : xlFields.values()) {\n      String printName = xlField.name;\n      int colWidth = 14;\n\n      String niceName = colNamesMap.get(xlField.name);\n      if (niceName != null) {\n        printName = niceName;\n      }\n\n      Integer niceWidth = colWidthsMap.get(xlField.name);\n      if (niceWidth != null) {\n        colWidth = niceWidth.intValue();\n      }\n\n      writeStr(xlField.name, printName, false);\n      wb.setColWidth(colWidth);\n      wb.setHeaderCell();\n    }\n    wb.setHeaderRow();\n    wb.addRow();\n\n    if (responseObj instanceof ResultContext) {\n      writeDocuments(null, (ResultContext)responseObj );\n    }\n    else if (responseObj instanceof DocList) {\n      ResultContext ctx = new BasicResultContext((DocList)responseObj, returnFields, null, null, req);\n      writeDocuments(null, ctx );\n    } else if (responseObj instanceof SolrDocumentList) {\n      writeSolrDocumentList(null, (SolrDocumentList)responseObj, returnFields );\n    }\n\n    wb.flush(out);\n    wb = null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","pathOld":"/dev/null","sourceNew":"  public void writeResponse(OutputStream out, LinkedHashMap<String, String> colNamesMap,\n                            LinkedHashMap<String, Integer> colWidthsMap) throws IOException {\n    SolrParams params = req.getParams();\n\n    Collection<String> fields = returnFields.getRequestedFieldNames();\n    Object responseObj = rsp.getValues().get(\"response\");\n    boolean returnOnlyStored = false;\n    if (fields==null||returnFields.hasPatternMatching()) {\n      if (responseObj instanceof SolrDocumentList) {\n        // get the list of fields from the SolrDocumentList\n        if(fields==null) {\n          fields = new LinkedHashSet<String>();\n        }\n        for (SolrDocument sdoc: (SolrDocumentList)responseObj) {\n          fields.addAll(sdoc.getFieldNames());\n        }\n      } else {\n        // get the list of fields from the index\n        Iterable<String> all = req.getSearcher().getFieldNames();\n        if (fields == null) {\n          fields = Sets.newHashSet(all);\n        } else {\n          Iterables.addAll(fields, all);\n        }\n      }\n      if (returnFields.wantsScore()) {\n        fields.add(\"score\");\n      } else {\n        fields.remove(\"score\");\n      }\n      returnOnlyStored = true;\n    }\n\n    for (String field : fields) {\n      if (!returnFields.wantsField(field)) {\n        continue;\n      }\n      if (field.equals(\"score\")) {\n        XLField xlField = new XLField();\n        xlField.name = \"score\";\n        xlFields.put(\"score\", xlField);\n        continue;\n      }\n\n      SchemaField sf = schema.getFieldOrNull(field);\n      if (sf == null) {\n        FieldType ft = new StrField();\n        sf = new SchemaField(field, ft);\n      }\n\n      // Return only stored fields, unless an explicit field list is specified\n      if (returnOnlyStored && sf != null && !sf.stored()) {\n        continue;\n      }\n\n      XLField xlField = new XLField();\n      xlField.name = field;\n      xlField.sf = sf;\n      xlFields.put(field, xlField);\n    }\n\n\n\n    wb.addRow();\n    //write header\n    for (XLField xlField : xlFields.values()) {\n      String printName = xlField.name;\n      int colWidth = 14;\n\n      String niceName = colNamesMap.get(xlField.name);\n      if (niceName != null) {\n        printName = niceName;\n      }\n\n      Integer niceWidth = colWidthsMap.get(xlField.name);\n      if (niceWidth != null) {\n        colWidth = niceWidth.intValue();\n      }\n\n      writeStr(xlField.name, printName, false);\n      wb.setColWidth(colWidth);\n      wb.setHeaderCell();\n    }\n    wb.setHeaderRow();\n    wb.addRow();\n\n    if (responseObj instanceof ResultContext) {\n      writeDocuments(null, (ResultContext)responseObj );\n    }\n    else if (responseObj instanceof DocList) {\n      ResultContext ctx = new BasicResultContext((DocList)responseObj, returnFields, null, null, req);\n      writeDocuments(null, ctx );\n    } else if (responseObj instanceof SolrDocumentList) {\n      writeSolrDocumentList(null, (SolrDocumentList)responseObj, returnFields );\n    }\n\n    wb.flush(out);\n    wb = null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"080177034f0f8c5fc458255dbe1e84334b531ade","date":1553677716,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/XLSXWriter[XLSXResponseWriter]#writeResponse(OutputStream,LinkedHashMap[String,String],LinkedHashMap[String,Integer]).mjava","sourceNew":"  public void writeResponse(OutputStream out, LinkedHashMap<String, String> colNamesMap,\n                            LinkedHashMap<String, Integer> colWidthsMap) throws IOException {\n\n    Collection<String> fields = getFields();\n    for (String field : fields) {\n      if (!returnFields.wantsField(field)) {\n        continue;\n      }\n      if (field.equals(\"score\")) {\n        XLField xlField = new XLField();\n        xlField.name = \"score\";\n        xlFields.put(\"score\", xlField);\n        continue;\n      }\n\n      if (shouldSkipField(field)) {\n        continue;\n      }\n      SchemaField sf = schema.getFieldOrNull(field);\n      if (sf == null) {\n        FieldType ft = new StrField();\n        sf = new SchemaField(field, ft);\n      }\n\n      XLField xlField = new XLField();\n      xlField.name = field;\n      xlField.sf = sf;\n      xlFields.put(field, xlField);\n    }\n\n\n\n    wb.addRow();\n    //write header\n    for (XLField xlField : xlFields.values()) {\n      String printName = xlField.name;\n      int colWidth = 14;\n\n      String niceName = colNamesMap.get(xlField.name);\n      if (niceName != null) {\n        printName = niceName;\n      }\n\n      Integer niceWidth = colWidthsMap.get(xlField.name);\n      if (niceWidth != null) {\n        colWidth = niceWidth.intValue();\n      }\n\n      writeStr(xlField.name, printName, false);\n      wb.setColWidth(colWidth);\n      wb.setHeaderCell();\n    }\n    wb.setHeaderRow();\n    wb.addRow();\n\n    writeResponse(rsp.getResponse());\n\n    wb.flush(out);\n    wb = null;\n  }\n\n","sourceOld":"  public void writeResponse(OutputStream out, LinkedHashMap<String, String> colNamesMap,\n                            LinkedHashMap<String, Integer> colWidthsMap) throws IOException {\n    SolrParams params = req.getParams();\n\n    Collection<String> fields = returnFields.getRequestedFieldNames();\n    Object responseObj = rsp.getValues().get(\"response\");\n    boolean returnOnlyStored = false;\n    if (fields==null||returnFields.hasPatternMatching()) {\n      if (responseObj instanceof SolrDocumentList) {\n        // get the list of fields from the SolrDocumentList\n        if(fields==null) {\n          fields = new LinkedHashSet<String>();\n        }\n        for (SolrDocument sdoc: (SolrDocumentList)responseObj) {\n          fields.addAll(sdoc.getFieldNames());\n        }\n      } else {\n        // get the list of fields from the index\n        Iterable<String> all = req.getSearcher().getFieldNames();\n        if (fields == null) {\n          fields = Sets.newHashSet(all);\n        } else {\n          Iterables.addAll(fields, all);\n        }\n      }\n      if (returnFields.wantsScore()) {\n        fields.add(\"score\");\n      } else {\n        fields.remove(\"score\");\n      }\n      returnOnlyStored = true;\n    }\n\n    for (String field : fields) {\n      if (!returnFields.wantsField(field)) {\n        continue;\n      }\n      if (field.equals(\"score\")) {\n        XLField xlField = new XLField();\n        xlField.name = \"score\";\n        xlFields.put(\"score\", xlField);\n        continue;\n      }\n\n      SchemaField sf = schema.getFieldOrNull(field);\n      if (sf == null) {\n        FieldType ft = new StrField();\n        sf = new SchemaField(field, ft);\n      }\n\n      // Return only stored fields, unless an explicit field list is specified\n      if (returnOnlyStored && sf != null && !sf.stored()) {\n        continue;\n      }\n\n      XLField xlField = new XLField();\n      xlField.name = field;\n      xlField.sf = sf;\n      xlFields.put(field, xlField);\n    }\n\n\n\n    wb.addRow();\n    //write header\n    for (XLField xlField : xlFields.values()) {\n      String printName = xlField.name;\n      int colWidth = 14;\n\n      String niceName = colNamesMap.get(xlField.name);\n      if (niceName != null) {\n        printName = niceName;\n      }\n\n      Integer niceWidth = colWidthsMap.get(xlField.name);\n      if (niceWidth != null) {\n        colWidth = niceWidth.intValue();\n      }\n\n      writeStr(xlField.name, printName, false);\n      wb.setColWidth(colWidth);\n      wb.setHeaderCell();\n    }\n    wb.setHeaderRow();\n    wb.addRow();\n\n    if (responseObj instanceof ResultContext) {\n      writeDocuments(null, (ResultContext)responseObj );\n    }\n    else if (responseObj instanceof DocList) {\n      ResultContext ctx = new BasicResultContext((DocList)responseObj, returnFields, null, null, req);\n      writeDocuments(null, ctx );\n    } else if (responseObj instanceof SolrDocumentList) {\n      writeSolrDocumentList(null, (SolrDocumentList)responseObj, returnFields );\n    }\n\n    wb.flush(out);\n    wb = null;\n  }\n\n","bugFix":["056868364d4e4a9ab9351ae5cc55e0506fe19769"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"056868364d4e4a9ab9351ae5cc55e0506fe19769":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"080177034f0f8c5fc458255dbe1e84334b531ade":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89424def13674ea17829b41c5883c54ecc31a132"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["080177034f0f8c5fc458255dbe1e84334b531ade"],"89424def13674ea17829b41c5883c54ecc31a132":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","056868364d4e4a9ab9351ae5cc55e0506fe19769"]},"commit2Childs":{"056868364d4e4a9ab9351ae5cc55e0506fe19769":["89424def13674ea17829b41c5883c54ecc31a132"],"080177034f0f8c5fc458255dbe1e84334b531ade":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["056868364d4e4a9ab9351ae5cc55e0506fe19769","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["080177034f0f8c5fc458255dbe1e84334b531ade","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}