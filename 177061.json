{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString().mjava","commits":[{"id":"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89","date":1567784912,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Increments the byte buffer to the next String in binary order after s that will not put\n     * the machine into a reject state. If such a string does not exist, returns\n     * false.\n     *\n     * The correctness of this method depends upon the automaton being deterministic,\n     * and having no transitions to dead states.\n     *\n     * @return true if more possible solutions exist for the DFA\n     */\n    protected boolean nextString() {\n      int state;\n      int pos = 0;\n      savedStates.grow(seekBytesRef.length()+1);\n      savedStates.setIntAt(0, 0);\n\n      while (true) {\n        curGen++;\n        linear = false;\n        // walk the automaton until a character is rejected.\n        for (state = savedStates.intAt(pos); pos < seekBytesRef.length(); pos++) {\n          visited[state] = curGen;\n          int nextState = runAutomaton.step(state, seekBytesRef.byteAt(pos) & 0xff);\n          if (nextState == -1)\n            break;\n          savedStates.setIntAt(pos+1, nextState);\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[nextState] == curGen) {\n            setLinear(pos);\n          }\n          state = nextState;\n        }\n\n        // take the useful portion, and the last non-reject state, and attempt to\n        // append characters that will match.\n        if (nextString(state, pos)) {\n          return true;\n        } else { /* no more solutions exist from this useful portion, backtrack */\n          if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n            return false;\n          final int newState = runAutomaton.step(savedStates.intAt(pos), seekBytesRef.byteAt(pos) & 0xff);\n          if (newState >= 0 && runAutomaton.isAccept(newState))\n            /* String is good to go as-is */\n            return true;\n          /* else advance further */\n          // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n          // for now, restart from scratch for all infinite DFAs\n          if (!finite) pos = 0;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23fcccd57316410c404dd37307a496ab850efa9c","date":1582897939,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString().mjava","sourceNew":"    /**\n     * Increments the byte buffer to the next String in binary order after s that will not put\n     * the machine into a reject state. If such a string does not exist, returns\n     * false.\n     * <p>\n     * The correctness of this method depends upon the automaton being deterministic,\n     * and having no transitions to dead states.\n     *\n     * @return true if more possible solutions exist for the DFA\n     */\n    protected boolean nextString() {\n      int state;\n      int pos = 0;\n      savedStates.grow(seekBytesRef.length() + 1);\n      savedStates.setIntAt(0, 0);\n\n      while (true) {\n        if (!finite && ++curGen == 0) {\n          // Clear the visited states every time curGen wraps (so very infrequently to not impact average perf).\n          Arrays.fill(visited, (short) -1);\n        }\n        linear = false;\n        // walk the automaton until a character is rejected.\n        for (state = savedStates.intAt(pos); pos < seekBytesRef.length(); pos++) {\n          setVisited(state);\n          int nextState = runAutomaton.step(state, seekBytesRef.byteAt(pos) & 0xff);\n          if (nextState == -1)\n            break;\n          savedStates.setIntAt(pos + 1, nextState);\n          // we found a loop, record it for faster enumeration\n          if (!linear && isVisited(nextState)) {\n            setLinear(pos);\n          }\n          state = nextState;\n        }\n\n        // take the useful portion, and the last non-reject state, and attempt to\n        // append characters that will match.\n        if (nextString(state, pos)) {\n          return true;\n        } else { /* no more solutions exist from this useful portion, backtrack */\n          if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n            return false;\n          final int newState = runAutomaton.step(savedStates.intAt(pos), seekBytesRef.byteAt(pos) & 0xff);\n          if (newState >= 0 && runAutomaton.isAccept(newState))\n            /* String is good to go as-is */\n            return true;\n          /* else advance further */\n          // paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n          // for now, restart from scratch for all infinite DFAs\n          if (!finite) pos = 0;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Increments the byte buffer to the next String in binary order after s that will not put\n     * the machine into a reject state. If such a string does not exist, returns\n     * false.\n     *\n     * The correctness of this method depends upon the automaton being deterministic,\n     * and having no transitions to dead states.\n     *\n     * @return true if more possible solutions exist for the DFA\n     */\n    protected boolean nextString() {\n      int state;\n      int pos = 0;\n      savedStates.grow(seekBytesRef.length()+1);\n      savedStates.setIntAt(0, 0);\n\n      while (true) {\n        curGen++;\n        linear = false;\n        // walk the automaton until a character is rejected.\n        for (state = savedStates.intAt(pos); pos < seekBytesRef.length(); pos++) {\n          visited[state] = curGen;\n          int nextState = runAutomaton.step(state, seekBytesRef.byteAt(pos) & 0xff);\n          if (nextState == -1)\n            break;\n          savedStates.setIntAt(pos+1, nextState);\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[nextState] == curGen) {\n            setLinear(pos);\n          }\n          state = nextState;\n        }\n\n        // take the useful portion, and the last non-reject state, and attempt to\n        // append characters that will match.\n        if (nextString(state, pos)) {\n          return true;\n        } else { /* no more solutions exist from this useful portion, backtrack */\n          if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n            return false;\n          final int newState = runAutomaton.step(savedStates.intAt(pos), seekBytesRef.byteAt(pos) & 0xff);\n          if (newState >= 0 && runAutomaton.isAccept(newState))\n            /* String is good to go as-is */\n            return true;\n          /* else advance further */\n          // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n          // for now, restart from scratch for all infinite DFAs\n          if (!finite) pos = 0;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23fcccd57316410c404dd37307a496ab850efa9c":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23fcccd57316410c404dd37307a496ab850efa9c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["23fcccd57316410c404dd37307a496ab850efa9c"],"23fcccd57316410c404dd37307a496ab850efa9c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}