{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","commits":[{"id":"6256acedd658c13275a01e4ba106a621956a22f6","date":1400192928,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9","date":1400353720,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + IDVersionSegmentTermsEnum.brToString(target) + \" term=\" + IDVersionSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n       if (DEBUG) {\n         BytesRef suffixBytesRef = new BytesRef();\n         suffixBytesRef.bytes = suffixBytes;\n         suffixBytesRef.offset = suffixesReader.getPosition();\n         suffixBytesRef.length = suffix;\n         System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + IDVersionSegmentTermsEnum.brToString(suffixBytesRef));\n       }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20","date":1400712483,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + IDVersionSegmentTermsEnum.brToString(target) + \" term=\" + IDVersionSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //    BytesRef suffixBytesRef = new BytesRef();\n      //    suffixBytesRef.bytes = suffixBytes;\n      //    suffixBytesRef.offset = suffixesReader.getPosition();\n      //    suffixBytesRef.length = suffix;\n      //    System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + IDVersionSegmentTermsEnum.brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + IDVersionSegmentTermsEnum.brToString(target) + \" term=\" + IDVersionSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n       if (DEBUG) {\n         BytesRef suffixBytesRef = new BytesRef();\n         suffixBytesRef.bytes = suffixBytes;\n         suffixBytesRef.offset = suffixesReader.getPosition();\n         suffixBytesRef.length = suffix;\n         System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + IDVersionSegmentTermsEnum.brToString(suffixBytesRef));\n       }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + IDVersionSegmentTermsEnum.brToString(target) + \" term=\" + IDVersionSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //    BytesRef suffixBytesRef = new BytesRef();\n      //    suffixBytesRef.bytes = suffixBytes;\n      //    suffixBytesRef.offset = suffixesReader.getPosition();\n      //    suffixBytesRef.length = suffix;\n      //    System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + IDVersionSegmentTermsEnum.brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + IDVersionSegmentTermsEnum.brToString(target) + \" term=\" + IDVersionSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //    BytesRef suffixBytesRef = new BytesRef();\n      //    suffixBytesRef.bytes = suffixBytes;\n      //    suffixBytesRef.offset = suffixesReader.getPosition();\n      //    suffixBytesRef.length = suffix;\n      //    System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + IDVersionSegmentTermsEnum.brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20"],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["6256acedd658c13275a01e4ba106a621956a22f6"],"4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"],"6256acedd658c13275a01e4ba106a621956a22f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":[],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20"],"4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"6256acedd658c13275a01e4ba106a621956a22f6":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6256acedd658c13275a01e4ba106a621956a22f6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}