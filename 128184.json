{"path":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","commits":[{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finall) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    if (inTransaction) {\n      throw new IOException(\"transaction is already in process\");\n    }\n    rollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    protectedSegments = new HashSet();\n    for(int i=0;i<segmentInfos.size();i++) {\n      SegmentInfo si = (SegmentInfo) segmentInfos.elementAt(i);\n      protectedSegments.add(si.name);\n    }\n    inTransaction = true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dbb18b6a222f2507f22fab7cc7eed06658d59772","6456e4ba6cdce20f5615173eb208f063c8cb74b7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flushRamSegments();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    }\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finall) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    if (inTransaction) {\n      throw new IOException(\"transaction is already in process\");\n    }\n    rollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    protectedSegments = new HashSet();\n    for(int i=0;i<segmentInfos.size();i++) {\n      SegmentInfo si = (SegmentInfo) segmentInfos.elementAt(i);\n      protectedSegments.add(si.name);\n    }\n    inTransaction = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6456e4ba6cdce20f5615173eb208f063c8cb74b7","date":1174828735,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flushRamSegments();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flushRamSegments();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    }\n  }\n\n","bugFix":["eeefd99c477417e5c7c574228461ebafe92469d4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flushRamSegments();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abd5d0ae26eed0e7cbbbbed19f6480fe16055e9b","date":1184336627,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    assert numBufferedDeleteTerms == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   */\n  private void startTransaction() throws IOException {\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fde68de507dbf344495d7b5e8052866fe5f254ab","date":1189434831,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    assert numBufferedDeleteTerms == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":["abd5d0ae26eed0e7cbbbbed19f6480fe16055e9b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67006a60923e2124212d3baa0d29b444bcbd8373","date":1191425052,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"346d5897e4c4e77ed5dbd31f7730ff30973d5971","date":1198317988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush(true, false);\n\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush();\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    localFlushedDocCount = docWriter.getFlushedDocCount();\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush(true, false, false);\n\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush(true, false);\n\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbb18b6a222f2507f22fab7cc7eed06658d59772","date":1204804366,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private synchronized void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    localFlushedDocCount = docWriter.getFlushedDocCount();\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush(true, false, false);\n\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    localFlushedDocCount = docWriter.getFlushedDocCount();\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush(true, false, false);\n\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":["eeefd99c477417e5c7c574228461ebafe92469d4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2586f96f60332eb97ecd2934b0763791462568b2","date":1220116589,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startTransaction().mjava","sourceNew":null,"sourceOld":"  /*\n   * Begin a transaction.  During a transaction, any segment\n   * merges that happen (or ram segments flushed) will not\n   * write a new segments file and will not remove any files\n   * that were present at the start of the transaction.  You\n   * must make a matched (try/finally) call to\n   * commitTransaction() or rollbackTransaction() to finish\n   * the transaction.\n   *\n   * Note that buffered documents and delete terms are not handled\n   * within the transactions, so they must be flushed before the\n   * transaction is started.\n   */\n  private synchronized void startTransaction() throws IOException {\n\n    if (infoStream != null)\n      message(\"now start transaction\");\n\n    assert docWriter.getNumBufferedDeleteTerms() == 0 :\n           \"calling startTransaction with buffered delete terms not supported\";\n    assert docWriter.getNumDocsInRAM() == 0 :\n           \"calling startTransaction with buffered documents not supported\";\n\n    localRollbackSegmentInfos = (SegmentInfos) segmentInfos.clone();\n    localAutoCommit = autoCommit;\n    localFlushedDocCount = docWriter.getFlushedDocCount();\n\n    if (localAutoCommit) {\n\n      if (infoStream != null)\n        message(\"flush at startTransaction\");\n\n      flush(true, false, false);\n\n      // Turn off auto-commit during our local transaction:\n      autoCommit = false;\n    } else\n      // We must \"protect\" our files at this point from\n      // deletion in case we need to rollback:\n      deleter.incRef(segmentInfos, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["67006a60923e2124212d3baa0d29b444bcbd8373"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["abd5d0ae26eed0e7cbbbbed19f6480fe16055e9b"],"67006a60923e2124212d3baa0d29b444bcbd8373":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["e82780afe6097066eb5befb86e9432f077667e3d"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["6456e4ba6cdce20f5615173eb208f063c8cb74b7"],"dbb18b6a222f2507f22fab7cc7eed06658d59772":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"6456e4ba6cdce20f5615173eb208f063c8cb74b7":["8b6187898fc4413ccd18229711786550a280383c"],"eeefd99c477417e5c7c574228461ebafe92469d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"abd5d0ae26eed0e7cbbbbed19f6480fe16055e9b":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"e82780afe6097066eb5befb86e9432f077667e3d":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"8b6187898fc4413ccd18229711786550a280383c":["eeefd99c477417e5c7c574228461ebafe92469d4"],"2586f96f60332eb97ecd2934b0763791462568b2":["dbb18b6a222f2507f22fab7cc7eed06658d59772"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2586f96f60332eb97ecd2934b0763791462568b2"]},"commit2Childs":{"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["e82780afe6097066eb5befb86e9432f077667e3d"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["67006a60923e2124212d3baa0d29b444bcbd8373"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"67006a60923e2124212d3baa0d29b444bcbd8373":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["dbb18b6a222f2507f22fab7cc7eed06658d59772"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["abd5d0ae26eed0e7cbbbbed19f6480fe16055e9b"],"dbb18b6a222f2507f22fab7cc7eed06658d59772":["2586f96f60332eb97ecd2934b0763791462568b2"],"6456e4ba6cdce20f5615173eb208f063c8cb74b7":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"eeefd99c477417e5c7c574228461ebafe92469d4":["8b6187898fc4413ccd18229711786550a280383c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eeefd99c477417e5c7c574228461ebafe92469d4"],"abd5d0ae26eed0e7cbbbbed19f6480fe16055e9b":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"e82780afe6097066eb5befb86e9432f077667e3d":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"8b6187898fc4413ccd18229711786550a280383c":["6456e4ba6cdce20f5615173eb208f063c8cb74b7"],"2586f96f60332eb97ecd2934b0763791462568b2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}