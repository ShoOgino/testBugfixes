{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,BestShape,boolean).mjava","commits":[{"id":"8825024cedab6612bf17c2b808f4f86abe6e45bb","date":1462272353,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,BestShape,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,List[GeoPoint]).mjava","sourceNew":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static BestShape convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, BestShape testPointShape, final boolean mustBeInside) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.points.size() > filteredPoints.size()) {\n        testPointShape = new BestShape(filteredPoints, mustBeInside);\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape, !mustBeInside);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","sourceOld":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static List<GeoPoint> convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, List<GeoPoint> testPointShape) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.size() > filteredPoints.size()) {\n        testPointShape = filteredPoints;\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,BestShape,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static BestShape convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, BestShape testPointShape, final boolean mustBeInside) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.points.size() > filteredPoints.size()) {\n        testPointShape = new BestShape(filteredPoints, mustBeInside);\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape, !mustBeInside);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8825024cedab6612bf17c2b808f4f86abe6e45bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8825024cedab6612bf17c2b808f4f86abe6e45bb"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8825024cedab6612bf17c2b808f4f86abe6e45bb"]},"commit2Childs":{"8825024cedab6612bf17c2b808f4f86abe6e45bb":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8825024cedab6612bf17c2b808f4f86abe6e45bb","55b50463286869f584cf849d1587a0fcd54d1dfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}