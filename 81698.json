{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager,boolean).mjava","commits":[{"id":"e17627eb9673daf01d17fdfb583c621c55c34208","date":1593028963,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager,boolean).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the\n     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>\n     *\n     * Some waiting is done in two cases:\n     * <ul>\n     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait\n     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>\n     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a\n     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation\n     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>\n     * </ul>\n     *\n     * The random wait prevents the \"thundering herd\" effect when all threads needing a session at the same time create a new\n     * one even though some differentiated waits could have led to better reuse and less session creations.\n     *\n     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing\n     *                  will happen...\n     */\n    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n\n      synchronized (lockObj) {\n        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n\n        // Best case scenario: an available session\n        if (sw != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"reusing session {}\", sw.getCreateTime());\n          }\n          return sw;\n        }\n\n        // Wait for a while before deciding what to do if waiting could help...\n        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {\n          // Either an existing session might be returned and become usable while we wait, or a session in the process of being\n          // created might finish creation, be used then returned and become usable. So we wait.\n          // wait 1 to 10 secs. Random to help spread wakeups.\n          long waitForMs = (long) (Math.random() * 9 * 1000) + 1000;\n\n          if (log.isDebugEnabled()) {\n            log.debug(\"No sessions are available, all busy COMPUTING (or {} creations in progress). starting wait of {}ms\",\n                creationsInProgress, waitForMs);\n          }\n          long waitStart = time(timeSource, MILLISECONDS);\n          try {\n            lockObj.wait(waitForMs);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n          }\n\n          // We've waited, now we can either reuse immediately an available session, or immediately create a new one\n          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n\n          // Second best case scenario: an available session\n          if (sw != null) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"reusing session {} after wait\", sw.getCreateTime());\n            }\n            return sw;\n          }\n        }\n\n        // We're going to create a new Session OUTSIDE of the critical section because session creation can take quite some time\n        creationsInProgress++;\n      }\n\n      SessionWrapper newSessionWrapper = null;\n      try {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Creating a new session\");\n        }\n        Policy.Session session = cloudManager.getDistribStateManager().getAutoScalingConfig().getPolicy().createSession(cloudManager);\n        newSessionWrapper = new SessionWrapper(session, this);\n        if (log.isDebugEnabled()) {\n          log.debug(\"New session created, {}\", newSessionWrapper.getCreateTime());\n        }\n        return newSessionWrapper;\n      } finally {\n        synchronized (lockObj) {\n          creationsInProgress--;\n\n          if (newSessionWrapper != null) {\n            // Session created successfully\n            sessionWrapperSet.add(newSessionWrapper);\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager,boolean).mjava","sourceNew":null,"sourceOld":"    /**\n     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the\n     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>\n     *\n     * Some waiting is done in two cases:\n     * <ul>\n     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait\n     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>\n     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a\n     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation\n     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>\n     * </ul>\n     *\n     * The random wait prevents the \"thundering herd\" effect when all threads needing a session at the same time create a new\n     * one even though some differentiated waits could have led to better reuse and less session creations.\n     *\n     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing\n     *                  will happen...\n     */\n    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n\n      synchronized (lockObj) {\n        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n\n        // Best case scenario: an available session\n        if (sw != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"reusing session {}\", sw.getCreateTime());\n          }\n          return sw;\n        }\n\n        // Wait for a while before deciding what to do if waiting could help...\n        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {\n          // Either an existing session might be returned and become usable while we wait, or a session in the process of being\n          // created might finish creation, be used then returned and become usable. So we wait.\n          // wait 1 to 10 secs. Random to help spread wakeups.\n          long waitForMs = (long) (Math.random() * 9 * 1000) + 1000;\n\n          if (log.isDebugEnabled()) {\n            log.debug(\"No sessions are available, all busy COMPUTING (or {} creations in progress). starting wait of {}ms\",\n                creationsInProgress, waitForMs);\n          }\n          long waitStart = time(timeSource, MILLISECONDS);\n          try {\n            lockObj.wait(waitForMs);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n          }\n\n          // We've waited, now we can either reuse immediately an available session, or immediately create a new one\n          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n\n          // Second best case scenario: an available session\n          if (sw != null) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"reusing session {} after wait\", sw.getCreateTime());\n            }\n            return sw;\n          }\n        }\n\n        // We're going to create a new Session OUTSIDE of the critical section because session creation can take quite some time\n        creationsInProgress++;\n      }\n\n      SessionWrapper newSessionWrapper = null;\n      try {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Creating a new session\");\n        }\n        Policy.Session session = cloudManager.getDistribStateManager().getAutoScalingConfig().getPolicy().createSession(cloudManager);\n        newSessionWrapper = new SessionWrapper(session, this);\n        if (log.isDebugEnabled()) {\n          log.debug(\"New session created, {}\", newSessionWrapper.getCreateTime());\n        }\n        return newSessionWrapper;\n      } finally {\n        synchronized (lockObj) {\n          creationsInProgress--;\n\n          if (newSessionWrapper != null) {\n            // Session created successfully\n            sessionWrapperSet.add(newSessionWrapper);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e17627eb9673daf01d17fdfb583c621c55c34208":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["e17627eb9673daf01d17fdfb583c621c55c34208"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"e17627eb9673daf01d17fdfb583c621c55c34208":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e17627eb9673daf01d17fdfb583c621c55c34208"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}