{"path":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#buildMultiValueSortedDocuments(String,List[Object]).mjava","commits":[{"id":"4cf2282b6a7c3f113e7a233b785b80527c03d590","date":1516129064,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#buildMultiValueSortedDocuments(String,List[Object]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a (multivalued) field name and an (ascending) sorted list of values, this method will generate a List of Solr Documents of the same size such that:\n   * <ul>\n   *  <li>For each non-null value in the original list, the corrisponding document in the result will have that value in the specified field.</li>\n   *  <li>For each null value in the original list, the corrisponding document in teh result will have <em>NO</em> values in the specified field.</li>\n   *  <li>If a document has a value in the field, then some random number of values that come <em>after</em> that value in the original list may also be included in the specified field.</li>\n   *  <li>Every document in the result will have a randomly asssigned 'id', unique realitive to all other documents in the result.</li>\n   * </ul>\n   */\n  private static final List<SolrInputDocument> buildMultiValueSortedDocuments(final String f,\n                                                                              final List<Object> vals) {\n    // build a list of docIds that we can shuffle (so the id order doesn't match the value order)\n    List<Integer> ids = new ArrayList<>(vals.size());\n    for (int i = 0; i < vals.size(); i++) {\n      ids.add(i+1);\n    }\n    Collections.shuffle(ids, random());\n    \n    final List<SolrInputDocument> docs = new ArrayList<>(vals.size());\n    for (int i = 0; i < vals.size(); i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", ids.get(i));\n      Object primaryValue = vals.get(i);\n      if (null != primaryValue) {\n        doc.addField(f, primaryValue);\n        final int extraValCount = random().nextInt(vals.size() - i);\n        for (int j = 0; j < extraValCount; j++) {\n          Object extraVal = vals.get(TestUtil.nextInt(random(), i+1, vals.size() - 1));\n          if (null != extraVal) {\n            doc.addField(f, extraVal);\n          }\n        }\n      }\n      docs.add(doc);\n    }\n    return docs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#buildMultiValueSortedDocuments(String,List[Object]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a (multivalued) field name and an (ascending) sorted list of values, this method will generate a List of Solr Documents of the same size such that:\n   * <ul>\n   *  <li>For each non-null value in the original list, the corrisponding document in the result will have that value in the specified field.</li>\n   *  <li>For each null value in the original list, the corrisponding document in teh result will have <em>NO</em> values in the specified field.</li>\n   *  <li>If a document has a value in the field, then some random number of values that come <em>after</em> that value in the original list may also be included in the specified field.</li>\n   *  <li>Every document in the result will have a randomly asssigned 'id', unique realitive to all other documents in the result.</li>\n   * </ul>\n   */\n  private static final List<SolrInputDocument> buildMultiValueSortedDocuments(final String f,\n                                                                              final List<Object> vals) {\n    // build a list of docIds that we can shuffle (so the id order doesn't match the value order)\n    List<Integer> ids = new ArrayList<>(vals.size());\n    for (int i = 0; i < vals.size(); i++) {\n      ids.add(i+1);\n    }\n    Collections.shuffle(ids, random());\n    \n    final List<SolrInputDocument> docs = new ArrayList<>(vals.size());\n    for (int i = 0; i < vals.size(); i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", ids.get(i));\n      Object primaryValue = vals.get(i);\n      if (null != primaryValue) {\n        doc.addField(f, primaryValue);\n        final int extraValCount = random().nextInt(vals.size() - i);\n        for (int j = 0; j < extraValCount; j++) {\n          Object extraVal = vals.get(TestUtil.nextInt(random(), i+1, vals.size() - 1));\n          if (null != extraVal) {\n            doc.addField(f, extraVal);\n          }\n        }\n      }\n      docs.add(doc);\n    }\n    return docs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}