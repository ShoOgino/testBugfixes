{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","commits":[{"id":"3955a9511098c96b652734b2f2d4160d07cc2d63","date":1504780677,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    double rate = 1.0;\n    CoreContainer container = cluster.getJettySolrRunners().get(0).getCoreContainer();\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds, rate);\n    final List<TriggerEvent> events = new ArrayList<>();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\", props, container)) {\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 200; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000 + 2000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f2ba631afa835c2dfd14555cf19ae7e73663c17","date":1505762504,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    double rate = 1.0;\n    CoreContainer container = cluster.getJettySolrRunners().get(0).getCoreContainer();\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds, rate);\n    final List<TriggerEvent> events = new ArrayList<>();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\", props, container)) {\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 200; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000 + 2000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3f354f2175f861ee625bb3c9572d53b77cd8545","date":1508405819,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    double rate = 1.0;\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CoreContainer container = cluster.getJettySolrRunner(0).getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds, rate);\n    final List<TriggerEvent> events = new ArrayList<>();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\", props, loader, cloudManager)) {\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 200; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000 + 2000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","date":1522763990,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    double rate = 1.0;\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CoreContainer container = cluster.getJettySolrRunner(0).getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds, rate);\n    final List<TriggerEvent> events = new ArrayList<>();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 200; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000 + 2000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    double rate = 1.0;\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CoreContainer container = cluster.getJettySolrRunner(0).getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds, rate);\n    final List<TriggerEvent> events = new ArrayList<>();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\", props, loader, cloudManager)) {\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 200; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000 + 2000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a","date":1524514741,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CoreContainer container = cluster.getJettySolrRunner(0).getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        trigger.run();\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    double rate = 1.0;\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CoreContainer container = cluster.getJettySolrRunner(0).getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds, rate);\n    final List<TriggerEvent> events = new ArrayList<>();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 200; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000 + 2000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n      }\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 + 2000);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cfc21bbd4847bfc63b67c0b0db15e526ccdc764","date":1527475702,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CoreContainer container = cluster.getJettySolrRunner(0).getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = cluster.getJettySolrRunners().get(1).getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        trigger.run();\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e","date":1529622176,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate node and collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate node and collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertEquals(3, hotNodes.size());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n    }\n  }\n\n","bugFix":["c3f354f2175f861ee625bb3c9572d53b77cd8545"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2018-06-18\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 500; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      cluster.stopJettySolrRunner(1);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 500; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 1000; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":["c3f354f2175f861ee625bb3c9572d53b77cd8545","f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudTestUtils.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @SuppressWarnings({\"unchecked\"})\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @SuppressWarnings({\"unchecked\"})\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @SuppressWarnings({\"unchecked\"})\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @SuppressWarnings({\"unchecked\"})\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<Replica> infos = (List<Replica>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        Replica info = infos.get(0);\n        assertEquals(coreName, info.getCoreName());\n        assertTrue((Double)info.get(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @SuppressWarnings({\"unchecked\"})\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<ReplicaInfo> infos = (List<ReplicaInfo>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        ReplicaInfo info = infos.get(0);\n        assertEquals(coreName, info.getCore());\n        assertTrue((Double)info.getVariable(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testTrigger().mjava","sourceNew":null,"sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @SuppressWarnings({\"unchecked\"})\n  public void testTrigger() throws Exception {\n    JettySolrRunner targetNode = cluster.getJettySolrRunner(0);\n    SolrZkClient zkClient = cluster.getSolrClient().getZkStateReader().getZkClient();\n    SolrResourceLoader loader = targetNode.getCoreContainer().getResourceLoader();\n    CoreContainer container = targetNode.getCoreContainer();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), cluster.getSolrClient());\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n    create = CollectionAdminRequest.createCollection(COLL2,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n    CloudUtil.waitForState(cloudManager, COLL2, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    double rate = 1.0;\n    URL baseUrl = targetNode.getBaseUrl();\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, rate, -1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // generate replica traffic\n      String coreName = container.getLoadedCoreNames().iterator().next();\n      String url = baseUrl.toString() + \"/\" + coreName;\n      try (HttpSolrClient simpleClient = new HttpSolrClient.Builder(url).build()) {\n        SolrParams query = params(CommonParams.Q, \"*:*\", CommonParams.DISTRIB, \"false\");\n        for (int i = 0; i < 130; i++) {\n          simpleClient.query(query);\n        }\n        String registryCoreName = coreName.replaceFirst(\"_\", \".\").replaceFirst(\"_\", \".\");\n        SolrMetricManager manager = targetNode.getCoreContainer().getMetricManager();\n        MetricRegistry registry = manager.registry(\"solr.core.\"+registryCoreName);\n        TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        // If we getting the rate too early, it will return 0\n        timeOut.waitFor(\"Timeout waiting for rate is not zero\",\n            () -> registry.timer(\"QUERY./select.requestTimes\").getOneMinuteRate()!=0.0);\n        trigger.run();\n        // waitFor delay\n        assertEquals(0, events.size());\n        Thread.sleep(waitForSeconds * 1000);\n        // should generate replica event\n        trigger.run();\n        assertEquals(1, events.size());\n        TriggerEvent event = events.get(0);\n        assertEquals(TriggerEventType.SEARCHRATE, event.eventType);\n        List<Replica> infos = (List<Replica>)event.getProperty(SearchRateTrigger.HOT_REPLICAS);\n        assertEquals(1, infos.size());\n        Replica info = infos.get(0);\n        assertEquals(coreName, info.getCoreName());\n        assertTrue((Double)info.get(AutoScalingParams.RATE) > rate);\n      }\n      // close that jetty to remove the violation - alternatively wait for 1 min...\n      JettySolrRunner j = cluster.stopJettySolrRunner(1);\n      cluster.waitForJettyToStop(j);\n      events.clear();\n      SolrParams query = params(CommonParams.Q, \"*:*\");\n      for (int i = 0; i < 130; i++) {\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      TriggerEvent event = events.get(0);\n      Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Double Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      assertTrue(Rate > rate);\n      events.clear();\n\n      for (int i = 0; i < 150; i++) {\n        solrClient.query(COLL2, query);\n        solrClient.query(COLL1, query);\n      }\n      Thread.sleep(waitForSeconds * 1000);\n      trigger.run();\n      // should generate collection event but not for COLL2 because of waitFor\n      assertEquals(1, events.size());\n      event = events.get(0);\n      Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n      hotNodes.forEach((n, r) -> assertTrue(n, r > rate));\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(1, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n\n      events.clear();\n      // assert that waitFor prevents new events from being generated\n      trigger.run();\n      // should not generate any events\n      assertEquals(0, events.size());\n\n      Thread.sleep(waitForSeconds * 1000 * 2);\n      trigger.run();\n      // should generate collection event\n      assertEquals(1, events.size());\n      event = events.get(0);\n      hotCollections = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_COLLECTIONS);\n      assertEquals(2, hotCollections.size());\n      Rate = hotCollections.get(COLL1);\n      assertNotNull(Rate);\n      Rate = hotCollections.get(COLL2);\n      assertNotNull(Rate);\n      hotNodes = (Map<String, Double>)event.getProperty(SearchRateTrigger.HOT_NODES);\n      assertTrue(\"hotNodes\", hotNodes.isEmpty());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3955a9511098c96b652734b2f2d4160d07cc2d63":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["c3f354f2175f861ee625bb3c9572d53b77cd8545"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"c3f354f2175f861ee625bb3c9572d53b77cd8545":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cfc21bbd4847bfc63b67c0b0db15e526ccdc764":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["4cfc21bbd4847bfc63b67c0b0db15e526ccdc764","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e":["4cfc21bbd4847bfc63b67c0b0db15e526ccdc764"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["4cfc21bbd4847bfc63b67c0b0db15e526ccdc764","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"4f2ba631afa835c2dfd14555cf19ae7e73663c17":["3955a9511098c96b652734b2f2d4160d07cc2d63"]},"commit2Childs":{"3955a9511098c96b652734b2f2d4160d07cc2d63":["4f2ba631afa835c2dfd14555cf19ae7e73663c17"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["4cfc21bbd4847bfc63b67c0b0db15e526ccdc764"],"c3f354f2175f861ee625bb3c9572d53b77cd8545":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"4cfc21bbd4847bfc63b67c0b0db15e526ccdc764":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3955a9511098c96b652734b2f2d4160d07cc2d63","c3f354f2175f861ee625bb3c9572d53b77cd8545"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"4f2ba631afa835c2dfd14555cf19ae7e73663c17":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","4f2ba631afa835c2dfd14555cf19ae7e73663c17"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}