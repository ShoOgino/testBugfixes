{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","commits":[{"id":"1794a0eb180b7d4e51424fbb32694cbb787ebc93","date":1496796881,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"/dev/null","sourceNew":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c05b634713ca09b2267477408773904d4c69dd9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"/dev/null","sourceNew":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"/dev/null","sourceNew":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"/dev/null","sourceNew":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c05b634713ca09b2267477408773904d4c69dd9d","date":1530894845,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should prbably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-useing this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","sourceOld":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":["1794a0eb180b7d4e51424fbb32694cbb787ebc93"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should prbably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-useing this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","sourceOld":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should prbably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-useing this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","sourceOld":"  // this refineFacets method is patterned after FacetFieldProcessor.refineFacets and should\n  // probably be merged when range facet becomes more like field facet in it's ability to sort and limit\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List leaves = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // currently, only _s should be present for range facets.  In the future, range facets will\n    // be more like field facets and will have the same refinement cases.  When that happens, we should try to unify the refinement code more\n    assert leaves.size() == 0;\n    assert partial.size() == 0;\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    /*** special buckets\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n     **********/\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45","date":1569046571,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should probably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-using this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should prbably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-useing this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    //\n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    //\n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should probably be refactored to share more code.\n\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n\n      // NOTE: we're re-using this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetParams.FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetParams.FacetRangeOther.BEFORE.toString(),\n            refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetParams.FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetParams.FacetRangeOther.AFTER.toString(),\n            refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetParams.FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetParams.FacetRangeOther.BETWEEN.toString(),\n            refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should probably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-using this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","c05b634713ca09b2267477408773904d4c69dd9d"],"1794a0eb180b7d4e51424fbb32694cbb787ebc93":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1794a0eb180b7d4e51424fbb32694cbb787ebc93"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["c05b634713ca09b2267477408773904d4c69dd9d"],"c05b634713ca09b2267477408773904d4c69dd9d":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["28288370235ed02234a64753cdbf0c6ec096304a","c05b634713ca09b2267477408773904d4c69dd9d"]},"commit2Childs":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"1794a0eb180b7d4e51424fbb32694cbb787ebc93":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1794a0eb180b7d4e51424fbb32694cbb787ebc93","f344bb33ca91f48e99c061980115b46fa84fc8f5","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"28288370235ed02234a64753cdbf0c6ec096304a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c05b634713ca09b2267477408773904d4c69dd9d","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"c05b634713ca09b2267477408773904d4c69dd9d":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}