{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","commits":[{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<SegmentCommitInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentCommitInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentCommitInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<SegmentCommitInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentCommitInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentCommitInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06805da26538ed636bd89b10c2699cc3834032ae","date":1395132972,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), rld, reader, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), rld, reader, dvUpdates);\n          if (dvUpdates.any()) {\n            rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n            if (dvUpdates.any()) {\n              rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final long segStartNS = System.nanoTime();\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        long termVisitedCount = 0;\n        final boolean segAllDeletes;\n        try {\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedDeletes != null) {\n            TermDeleteCounts counts = applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += counts.delCount;\n            termVisitedCount += counts.termVisitedCount;\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), rld, reader, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), rld, reader, dvUpdates);\n          if (dvUpdates.any()) {\n            rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        totDelCount += delCount;\n        totTermVisitedCount += termVisitedCount;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", String.format(Locale.ROOT, \"%.3fs\", ((System.nanoTime() - segStartNS)/1000000000.0)) + \" seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + \" termVisitedCount=\" + termVisitedCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          long termVisitedCount = 0;\n          final boolean segAllDeletes;\n          try {\n            TermDeleteCounts counts = applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += counts.delCount;\n            termVisitedCount += counts.termVisitedCount;\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n            if (dvUpdates.any()) {\n              rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n\n          totDelCount += delCount;\n          totTermVisitedCount += termVisitedCount;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", String.format(Locale.ROOT, \"%.3fs\", ((System.nanoTime() - segStartNS)/1000000000.0)) + \" seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + \" termVisitedCount=\" + termVisitedCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec for \" + infos.size() + \" segments, \" + totDelCount + \" deleted docs, \" + totTermVisitedCount + \" visited terms\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(totDelCount > 0, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), rld, reader, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), rld, reader, dvUpdates);\n          if (dvUpdates.any()) {\n            rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n            if (dvUpdates.any()) {\n              rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final long segStartNS = System.nanoTime();\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        long termVisitedCount = 0;\n        final boolean segAllDeletes;\n        try {\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedDeletes != null) {\n            TermDeleteCounts counts = applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += counts.delCount;\n            termVisitedCount += counts.termVisitedCount;\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), rld, reader, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), rld, reader, dvUpdates);\n          if (dvUpdates.any()) {\n            rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        totDelCount += delCount;\n        totTermVisitedCount += termVisitedCount;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", String.format(Locale.ROOT, \"%.3fs\", ((System.nanoTime() - segStartNS)/1000000000.0)) + \" seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + \" termVisitedCount=\" + termVisitedCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          long termVisitedCount = 0;\n          final boolean segAllDeletes;\n          try {\n            TermDeleteCounts counts = applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += counts.delCount;\n            termVisitedCount += counts.termVisitedCount;\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, dvUpdates);\n            applyDocValuesUpdates(coalescedDeletes.binaryDVUpdates, rld, reader, dvUpdates);\n            if (dvUpdates.any()) {\n              rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n\n          totDelCount += delCount;\n          totTermVisitedCount += termVisitedCount;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", String.format(Locale.ROOT, \"%.3fs\", ((System.nanoTime() - segStartNS)/1000000000.0)) + \" seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + \" termVisitedCount=\" + termVisitedCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec for \" + infos.size() + \" segments, \" + totDelCount + \" deleted docs, \" + totTermVisitedCount + \" visited terms\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(totDelCount > 0, gen, allDeleted);\n  }\n\n","bugFix":["203d7d3cb7712e10ef33009a63247ae40c302d7a","634f330c54fd3f9f491d52036dc3f40b4f4d8934","9ce667c6d3400b22523701c549c0d35e26da8b46","5faf65b6692f15cca0f87bf8666c87899afc619f","06584e6e98d592b34e1329b384182f368d2025e8","73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","e072d0b1fc19e0533d8ce432eed245196bca6fde","1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe","c19f985e36a65cc969e8e564fe337a0d41512075","327863a2fd61e831028b6c56c8fef6b00a44eb0b","ccad4bab070f323ce610caa0040346d4a87213dc","f6f4cae61e16730201371ab7e9912721c19324e7","119ae5b0966bbb5d6948c7f86207613595764d2e","58c6bbc222f074c844e736e6fb23647e3db9cfe3","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","06805da26538ed636bd89b10c2699cc3834032ae","ae695f21c50b03702b5d0fa2543d5af844bb7cd3","69a6d2d525aeab53c867ed26934185e5bb627d0e"],"bugIntro":["84c1ba52905cc7eaf624aac5e10414eccc0af92d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84c1ba52905cc7eaf624aac5e10414eccc0af92d","date":1464805673,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f69e96b07e265f3e18957be540909b01fae36f8","date":1464859090,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":null,"sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":null,"sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","sourceNew":null,"sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    final long gen = nextGen++;\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, gen, null);\n    }\n\n    // We only init these on demand, when we find our first deletes that need to be applied:\n    SegmentState[] segStates = null;\n\n    long totDelCount = 0;\n    long totTermVisitedCount = 0;\n\n    boolean success = false;\n\n    ApplyDeletesResult result = null;\n\n    try {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT, \"applyDeletes: open segment readers took %d msec\", System.currentTimeMillis()-t0));\n      }\n\n      assert checkDeleteStats();\n\n      if (!any()) {\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"applyDeletes: no segments; skipping\");\n        }\n        return new ApplyDeletesResult(false, gen, null);\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n      }\n\n      infos = sortByDelGen(infos);\n\n      CoalescedUpdates coalescedUpdates = null;\n      int infosIDX = infos.size()-1;\n      int delIDX = updates.size()-1;\n\n      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:\n      while (infosIDX >= 0) {\n        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n        final SegmentCommitInfo info = infos.get(infosIDX);\n        final long segGen = info.getBufferedDeletesGen();\n\n        if (packet != null && segGen < packet.delGen()) {\n          if (!packet.isSegmentPrivate && packet.any()) {\n            /*\n             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted\n             * from the SI since it had no more documents remaining after some del packets younger than\n             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n             * removed.\n             */\n            if (coalescedUpdates == null) {\n              coalescedUpdates = new CoalescedUpdates();\n            }\n            coalescedUpdates.update(packet);\n          }\n\n          delIDX--;\n        } else if (packet != null && segGen == packet.delGen()) {\n          assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n\n          if (segStates == null) {\n            segStates = openSegmentStates(pool, infos);\n          }\n\n          SegmentState segState = segStates[infosIDX];\n\n          // Lock order: IW -> BD -> RP\n          assert pool.infoIsLive(info);\n          int delCount = 0;\n          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n\n          // first apply segment-private deletes/updates\n          delCount += applyQueryDeletes(packet.queriesIterable(), segState);\n          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);\n          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);\n\n          // ... then coalesced deletes/updates, so that if there is an update that appears in both, the coalesced updates (carried from\n          // updates ahead of the segment-privates ones) win:\n          if (coalescedUpdates != null) {\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n          }\n          if (dvUpdates.any()) {\n            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n          }\n\n          totDelCount += delCount;\n\n          /*\n           * Since we are on a segment private del packet we must not\n           * update the coalescedUpdates here! We can simply advance to the \n           * next packet and seginfo.\n           */\n          delIDX--;\n          infosIDX--;\n\n        } else {\n          if (coalescedUpdates != null) {\n            if (segStates == null) {\n              segStates = openSegmentStates(pool, infos);\n            }\n            SegmentState segState = segStates[infosIDX];\n            // Lock order: IW -> BD -> RP\n            assert pool.infoIsLive(info);\n            int delCount = 0;\n            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);\n            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();\n            applyDocValuesUpdatesList(coalescedUpdates.numericDVUpdates, segState, dvUpdates);\n            applyDocValuesUpdatesList(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);\n            if (dvUpdates.any()) {\n              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);\n            }\n\n            totDelCount += delCount;\n          }\n\n          infosIDX--;\n        }\n      }\n\n      // Now apply all term deletes:\n      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {\n        if (segStates == null) {\n          segStates = openSegmentStates(pool, infos);\n        }\n        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);\n      }\n\n      assert checkDeleteStats();\n\n      success = true;\n\n    } finally {\n      if (segStates != null) {\n        result = closeSegmentStates(pool, segStates, success, gen);\n      }\n    }\n\n    if (result == null) {\n      result = new ApplyDeletesResult(false, gen, null);      \n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\",\n                         String.format(Locale.ROOT,\n                                       \"applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s\",\n                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["1f69e96b07e265f3e18957be540909b01fae36f8"],"06805da26538ed636bd89b10c2699cc3834032ae":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["7e4c214a1f904dde76f5611b56d4081533055b3b","84c1ba52905cc7eaf624aac5e10414eccc0af92d"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["1f69e96b07e265f3e18957be540909b01fae36f8","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["1f69e96b07e265f3e18957be540909b01fae36f8","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7e4c214a1f904dde76f5611b56d4081533055b3b","1f69e96b07e265f3e18957be540909b01fae36f8"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["7e4c214a1f904dde76f5611b56d4081533055b3b","5b8ee93140fd0efef7e101786e3ed5160a700b5f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1f69e96b07e265f3e18957be540909b01fae36f8":["7e4c214a1f904dde76f5611b56d4081533055b3b","84c1ba52905cc7eaf624aac5e10414eccc0af92d"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["06805da26538ed636bd89b10c2699cc3834032ae"],"84c1ba52905cc7eaf624aac5e10414eccc0af92d":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["06805da26538ed636bd89b10c2699cc3834032ae"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"06805da26538ed636bd89b10c2699cc3834032ae":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"1f69e96b07e265f3e18957be540909b01fae36f8":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","1f69e96b07e265f3e18957be540909b01fae36f8","84c1ba52905cc7eaf624aac5e10414eccc0af92d"],"84c1ba52905cc7eaf624aac5e10414eccc0af92d":["5b8ee93140fd0efef7e101786e3ed5160a700b5f","1f69e96b07e265f3e18957be540909b01fae36f8"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}