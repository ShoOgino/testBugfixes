{"path":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,int,HLLType).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,int,HLLType).mjava","pathOld":"/dev/null","sourceNew":"    // -------------------------------------------------------------------------\n    /**\n     * Convenience constructor for testing. Assumes that both {@link HLLType#EXPLICIT}\n     * and {@link HLLType#SPARSE} representations should be enabled.\n     *\n     * @param log2m log-base-2 of the number of registers used in the HyperLogLog\n     *        algorithm. Must be at least 4 and at most 30.\n     * @param regwidth number of bits used per register in the HyperLogLog\n     *        algorithm. Must be at least 1 and at most 8.\n     * @param explicitThreshold cardinality threshold at which the {@link HLLType#EXPLICIT}\n     *        representation should be promoted to {@link HLLType#SPARSE}.\n     *        This must be greater than zero and less than or equal to {@value #MAXIMUM_EXPLICIT_THRESHOLD}.\n     * @param sparseThreshold register count threshold at which the {@link HLLType#SPARSE}\n     *        representation should be promoted to {@link HLLType#FULL}.\n     *        This must be greater than zero.\n     * @param type the type in the promotion hierarchy which this instance should\n     *        start at. This cannot be <code>null</code>.\n     */\n    /*package, for testing*/ HLL(final int log2m, final int regwidth, final int explicitThreshold, final int sparseThreshold, final HLLType type) {\n        this.log2m = log2m;\n        if((log2m < MINIMUM_LOG2M_PARAM) || (log2m > MAXIMUM_LOG2M_PARAM)) {\n            throw new IllegalArgumentException(\"'log2m' must be at least \" + MINIMUM_LOG2M_PARAM + \" and at most \" + MAXIMUM_LOG2M_PARAM + \" (was: \" + log2m + \")\");\n        }\n\n        this.regwidth = regwidth;\n        if((regwidth < MINIMUM_REGWIDTH_PARAM) || (regwidth > MAXIMUM_REGWIDTH_PARAM)) {\n            throw new IllegalArgumentException(\"'regwidth' must be at least \" + MINIMUM_REGWIDTH_PARAM + \" and at most \" + MAXIMUM_REGWIDTH_PARAM + \" (was: \" + regwidth + \")\");\n        }\n\n        this.m = (1 << log2m);\n        this.mBitsMask = m - 1;\n        this.valueMask = (1 << regwidth) - 1;\n        this.pwMaxMask = HLLUtil.pwMaxMask(regwidth);\n        this.alphaMSquared = HLLUtil.alphaMSquared(m);\n        this.smallEstimatorCutoff = HLLUtil.smallEstimatorCutoff(m);\n        this.largeEstimatorCutoff = HLLUtil.largeEstimatorCutoff(log2m, regwidth);\n\n        this.explicitAuto = false;\n        this.explicitOff = false;\n        this.explicitThreshold = explicitThreshold;\n        if((explicitThreshold < 1) || (explicitThreshold > MAXIMUM_EXPLICIT_THRESHOLD)) {\n            throw new IllegalArgumentException(\"'explicitThreshold' must be at least 1 and at most \" + MAXIMUM_EXPLICIT_THRESHOLD + \" (was: \" + explicitThreshold + \")\");\n        }\n\n        this.shortWordLength = (regwidth + log2m);\n        this.sparseOff = false;\n        this.sparseThreshold = sparseThreshold;\n\n        initializeStorage(type);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#HLL(int,int,int,int,HLLType).mjava","pathOld":"/dev/null","sourceNew":"    // -------------------------------------------------------------------------\n    /**\n     * Convenience constructor for testing. Assumes that both {@link HLLType#EXPLICIT}\n     * and {@link HLLType#SPARSE} representations should be enabled.\n     *\n     * @param log2m log-base-2 of the number of registers used in the HyperLogLog\n     *        algorithm. Must be at least 4 and at most 30.\n     * @param regwidth number of bits used per register in the HyperLogLog\n     *        algorithm. Must be at least 1 and at most 8.\n     * @param explicitThreshold cardinality threshold at which the {@link HLLType#EXPLICIT}\n     *        representation should be promoted to {@link HLLType#SPARSE}.\n     *        This must be greater than zero and less than or equal to {@value #MAXIMUM_EXPLICIT_THRESHOLD}.\n     * @param sparseThreshold register count threshold at which the {@link HLLType#SPARSE}\n     *        representation should be promoted to {@link HLLType#FULL}.\n     *        This must be greater than zero.\n     * @param type the type in the promotion hierarchy which this instance should\n     *        start at. This cannot be <code>null</code>.\n     */\n    /*package, for testing*/ HLL(final int log2m, final int regwidth, final int explicitThreshold, final int sparseThreshold, final HLLType type) {\n        this.log2m = log2m;\n        if((log2m < MINIMUM_LOG2M_PARAM) || (log2m > MAXIMUM_LOG2M_PARAM)) {\n            throw new IllegalArgumentException(\"'log2m' must be at least \" + MINIMUM_LOG2M_PARAM + \" and at most \" + MAXIMUM_LOG2M_PARAM + \" (was: \" + log2m + \")\");\n        }\n\n        this.regwidth = regwidth;\n        if((regwidth < MINIMUM_REGWIDTH_PARAM) || (regwidth > MAXIMUM_REGWIDTH_PARAM)) {\n            throw new IllegalArgumentException(\"'regwidth' must be at least \" + MINIMUM_REGWIDTH_PARAM + \" and at most \" + MAXIMUM_REGWIDTH_PARAM + \" (was: \" + regwidth + \")\");\n        }\n\n        this.m = (1 << log2m);\n        this.mBitsMask = m - 1;\n        this.valueMask = (1 << regwidth) - 1;\n        this.pwMaxMask = HLLUtil.pwMaxMask(regwidth);\n        this.alphaMSquared = HLLUtil.alphaMSquared(m);\n        this.smallEstimatorCutoff = HLLUtil.smallEstimatorCutoff(m);\n        this.largeEstimatorCutoff = HLLUtil.largeEstimatorCutoff(log2m, regwidth);\n\n        this.explicitAuto = false;\n        this.explicitOff = false;\n        this.explicitThreshold = explicitThreshold;\n        if((explicitThreshold < 1) || (explicitThreshold > MAXIMUM_EXPLICIT_THRESHOLD)) {\n            throw new IllegalArgumentException(\"'explicitThreshold' must be at least 1 and at most \" + MAXIMUM_EXPLICIT_THRESHOLD + \" (was: \" + explicitThreshold + \")\");\n        }\n\n        this.shortWordLength = (regwidth + log2m);\n        this.sparseOff = false;\n        this.sparseThreshold = sparseThreshold;\n\n        initializeStorage(type);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}