{"path":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","sourceNew":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @return the given {@link BytesRef}\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @return the given {@link BytesRef}\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa968010b9c6598d02666b7b879c12e3cb0db4ee","date":1359063766,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","sourceNew":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @return the given {@link BytesRef}\n     * \n     * @lucene.internal\n     **/\n    // nocommit: move this shit and any other vint bogusness to fieldcacheimpl!\n    public BytesRef fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @return the given {@link BytesRef}\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"caa40272511a69bd4ad04b8242ae420932f5799b","date":1359341326,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","sourceNew":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    // nocommit: move this shit and any other vint bogusness to fieldcacheimpl!\n    public void fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @return the given {@link BytesRef}\n     * \n     * @lucene.internal\n     **/\n    // nocommit: move this shit and any other vint bogusness to fieldcacheimpl!\n    public BytesRef fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9eafdf27a0bda3d70664dd39f3a1683d8416dcf","date":1359644871,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","sourceNew":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    // TODO: this really needs to be refactored into fieldcacheimpl\n    public void fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    // nocommit: move this shit and any other vint bogusness to fieldcacheimpl!\n    public void fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fill(BytesRef,long).mjava","sourceNew":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    // TODO: this really needs to be refactored into fieldcacheimpl\n    public void fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.\n     * <p>\n     * <b>Note:</b> this method does not support slices spanning across block\n     * borders.\n     * </p>\n     * \n     * @return the given {@link BytesRef}\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fill(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      final int offset = (int) (start & blockMask);\n      final byte[] block = b.bytes = blocks[index];\n\n      if ((block[offset] & 128) == 0) {\n        b.length = block[offset];\n        b.offset = offset+1;\n      } else {\n        b.length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        b.offset = offset+2;\n        assert b.length > 0;\n      }\n      return b;\n    }\n\n","bugFix":["224555f245128127dc8d161673eb9e867d67857c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","e9eafdf27a0bda3d70664dd39f3a1683d8416dcf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9eafdf27a0bda3d70664dd39f3a1683d8416dcf":["caa40272511a69bd4ad04b8242ae420932f5799b"],"caa40272511a69bd4ad04b8242ae420932f5799b":["fa968010b9c6598d02666b7b879c12e3cb0db4ee"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["caa40272511a69bd4ad04b8242ae420932f5799b"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fa968010b9c6598d02666b7b879c12e3cb0db4ee","d4d69c535930b5cce125cff868d40f6373dc27d4"],"e9eafdf27a0bda3d70664dd39f3a1683d8416dcf":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"caa40272511a69bd4ad04b8242ae420932f5799b":["e9eafdf27a0bda3d70664dd39f3a1683d8416dcf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}