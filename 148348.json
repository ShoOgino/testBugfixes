{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#encodeRefinementValuePath(List[String]).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#encodeRefinementValuePath(List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Encodes a value path as a string for the purposes of a refinement request\n   *\n   * @see PivotFacetValue#getValuePath\n   * @see #decodeRefinementValuePath\n   */\n  public static String encodeRefinementValuePath(List<String> values) {\n    // HACK: prefix flag every value to account for empty string vs null\n    // NOTE: even if we didn't have to worry about null's smartSplit is stupid about\n    // pruning empty strings from list\n    // \"^\" prefix = null\n    // \"~\" prefix = not null, may be empty string\n\n    assert null != values;\n\n    // special case: empty list => empty string\n    if (values.isEmpty()) { return \"\"; }\n\n    \n    StringBuilder out = new StringBuilder();\n    for (String val : values) {\n      if (null == val) {\n        out.append('^');\n      } else {\n        out.append('~');\n        StrUtils.appendEscapedTextToBuilder(out, val, ',');\n      }\n      out.append(',');\n    }\n    out.deleteCharAt(out.length()-1);  // prune the last seperator\n    return out.toString();\n    // return StrUtils.join(values, ',');\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c169312e8f621502de0661c48a43e492983cd28a","date":1423728604,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#encodeRefinementValuePath(List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#encodeRefinementValuePath(List[String]).mjava","sourceNew":"  /**\n   * Encodes a value path as a string for the purposes of a refinement request\n   *\n   * @see PivotFacetValue#getValuePath\n   * @see #decodeRefinementValuePath\n   */\n  public static String encodeRefinementValuePath(List<String> values) {\n    // HACK: prefix flag every value to account for empty string vs null\n    // NOTE: even if we didn't have to worry about null's smartSplit is stupid about\n    // pruning empty strings from list\n    // \"^\" prefix = null\n    // \"~\" prefix = not null, may be empty string\n\n    assert null != values;\n\n    // special case: empty list => empty string\n    if (values.isEmpty()) { return \"\"; }\n\n    \n    StringBuilder out = new StringBuilder();\n    for (String val : values) {\n      if (null == val) {\n        out.append('^');\n      } else {\n        out.append('~');\n        StrUtils.appendEscapedTextToBuilder(out, val, ',');\n      }\n      out.append(',');\n    }\n    out.deleteCharAt(out.length()-1);  // prune the last separator\n    return out.toString();\n    // return StrUtils.join(values, ',');\n  }\n\n","sourceOld":"  /**\n   * Encodes a value path as a string for the purposes of a refinement request\n   *\n   * @see PivotFacetValue#getValuePath\n   * @see #decodeRefinementValuePath\n   */\n  public static String encodeRefinementValuePath(List<String> values) {\n    // HACK: prefix flag every value to account for empty string vs null\n    // NOTE: even if we didn't have to worry about null's smartSplit is stupid about\n    // pruning empty strings from list\n    // \"^\" prefix = null\n    // \"~\" prefix = not null, may be empty string\n\n    assert null != values;\n\n    // special case: empty list => empty string\n    if (values.isEmpty()) { return \"\"; }\n\n    \n    StringBuilder out = new StringBuilder();\n    for (String val : values) {\n      if (null == val) {\n        out.append('^');\n      } else {\n        out.append('~');\n        StrUtils.appendEscapedTextToBuilder(out, val, ',');\n      }\n      out.append(',');\n    }\n    out.deleteCharAt(out.length()-1);  // prune the last seperator\n    return out.toString();\n    // return StrUtils.join(values, ',');\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#encodeRefinementValuePath(List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#encodeRefinementValuePath(List[String]).mjava","sourceNew":"  /**\n   * Encodes a value path as a string for the purposes of a refinement request\n   *\n   * @see PivotFacetValue#getValuePath\n   * @see #decodeRefinementValuePath\n   */\n  public static String encodeRefinementValuePath(List<String> values) {\n    // HACK: prefix flag every value to account for empty string vs null\n    // NOTE: even if we didn't have to worry about null's smartSplit is stupid about\n    // pruning empty strings from list\n    // \"^\" prefix = null\n    // \"~\" prefix = not null, may be empty string\n\n    assert null != values;\n\n    // special case: empty list => empty string\n    if (values.isEmpty()) {\n      return \"\";\n    }\n    \n    StringBuilder out = new StringBuilder();\n    for (String val : values) {\n      if (null == val) {\n        out.append('^');\n      } else {\n        out.append('~');\n        StrUtils.appendEscapedTextToBuilder(out, val, ',');\n      }\n      out.append(',');\n    }\n    out.deleteCharAt(out.length()-1);  // prune the last separator\n    return out.toString();\n    // return StrUtils.join(values, ',');\n  }\n\n","sourceOld":"  /**\n   * Encodes a value path as a string for the purposes of a refinement request\n   *\n   * @see PivotFacetValue#getValuePath\n   * @see #decodeRefinementValuePath\n   */\n  public static String encodeRefinementValuePath(List<String> values) {\n    // HACK: prefix flag every value to account for empty string vs null\n    // NOTE: even if we didn't have to worry about null's smartSplit is stupid about\n    // pruning empty strings from list\n    // \"^\" prefix = null\n    // \"~\" prefix = not null, may be empty string\n\n    assert null != values;\n\n    // special case: empty list => empty string\n    if (values.isEmpty()) { return \"\"; }\n\n    \n    StringBuilder out = new StringBuilder();\n    for (String val : values) {\n      if (null == val) {\n        out.append('^');\n      } else {\n        out.append('~');\n        StrUtils.appendEscapedTextToBuilder(out, val, ',');\n      }\n      out.append(',');\n    }\n    out.deleteCharAt(out.length()-1);  // prune the last separator\n    return out.toString();\n    // return StrUtils.join(values, ',');\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["c169312e8f621502de0661c48a43e492983cd28a"],"c169312e8f621502de0661c48a43e492983cd28a":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["c169312e8f621502de0661c48a43e492983cd28a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c169312e8f621502de0661c48a43e492983cd28a":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}