{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21311a17d5c0c14b384b0fe7946ffb3997855720","date":1332342305,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (indexPossiblyExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d19974432be9aed28ee7dca73bdf01d139e763a9","date":1342822166,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (indexPossiblyExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278","21311a17d5c0c14b384b0fe7946ffb3997855720","d85277fe0f487ec4ed00df56cce41f715e1a5a1c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (indexPossiblyExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (indexPossiblyExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6493bfa10477745a1307895992b7323b6e19ec6","date":1343781089,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eae2a56dc810a17cf807d831f720dec931a03de","date":1349262073,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              try {\n                SegmentInfos sis = new SegmentInfos();\n                sis.read(delegate, file);\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable ignore) {}\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            StringBuilder sb = new StringBuilder();\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c17031cb223ff09d763bb8ba49ca9d9eb1871ba7","date":1349268148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            StringBuilder sb = new StringBuilder();\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              try {\n                SegmentInfos sis = new SegmentInfos();\n                sis.read(delegate, file);\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable ignore) {}\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            StringBuilder sb = new StringBuilder();\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9773480aa9e800d0a232ab6ccac265e874b0c51","date":1349461188,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            StringBuilder sb = new StringBuilder();\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30e0912f3a3069b115cfea44ff612c44d6906386","date":1365631344,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      if (indexPossiblyExists()) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bac2bd9d901ec1ee7111a77c8e616d745fb2a362","date":1368131212,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"399ef3ff6c22f0627c82ac65f32726f3587a2aa1","date":1379005174,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(delegate, iwc).rollback();\n          String[] endFiles = delegate.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(delegate, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(delegate, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"527cc14542789f47d75da436cb4287d1ab887e34","date":1391705548,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<String>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<String>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<String>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<String>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<String>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<String>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<String>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"959c85e26b626bdc806252d9410817c987d0d0c9","date":1398680923,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose());\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).shutdown();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis;\n              try {\n                sis = SegmentInfos.readCommit(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n                sis = new SegmentInfos();\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","date":1414017220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras;\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis;\n              try {\n                sis = SegmentInfos.readCommit(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n                sis = new SegmentInfos();\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis = new SegmentInfos();\n              try {\n                sis.read(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07132423639577d6f68cebbec9c83599d5d5a3a","date":1419020622,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as its very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // its possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    // files that we tried to delete, but couldn't because readers were open.\n    // all that matters is that we tried! (they will eventually go away)\n    //   still open when we tried to delete\n    Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n    //   virus scanner when we tried to delete\n    pendingDeletions.addAll(triedToDelete);\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<>();\n      openFilesDeleted = new HashSet<>();\n    }\n    if (openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (openLocks.size() > 0) {\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openLocks.values().iterator();\n      if (stacktraces.hasNext()) {\n        cause = stacktraces.next();\n      }\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n    }\n\n    isOpen = false;\n    if (getCheckIndexOnClose()) {\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        crash(); // corrupt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n\n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          allFiles.removeAll(pendingDeletions);\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n\n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n          \n          if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n            // this is possible if we hit an exception while writing segments.gen, we try to delete it\n            // and it ends out in pendingDeletions (but IFD wont remove this).\n            startSet.add(\"segments.gen\");\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n            }\n          }\n          \n          // its possible we cannot delete the segments_N on windows if someone has it open and\n          // maybe other files too, depending on timing. normally someone on windows wouldnt have\n          // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n          for (String file : pendingDeletions) {\n            if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n              startSet.add(file);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n              }\n              SegmentInfos sis;\n              try {\n                sis = SegmentInfos.readCommit(in, file);\n              } catch (IOException ioe) {\n                // OK: likely some of the .si files were deleted\n                sis = new SegmentInfos();\n              }\n\n              try {\n                Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                for (String s : ghosts) {\n                  if (endSet.contains(s) && !startSet.contains(s)) {\n                    assert pendingDeletions.contains(s);\n                    if (LuceneTestCase.VERBOSE) {\n                      System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                         \"from \" + file + \" that we could not delete.\");\n                    }\n                    startSet.add(s);\n                  }\n                }\n              } catch (Throwable t) {\n                System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                t.printStackTrace();\n              }\n            }\n          }\n\n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n\n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n\n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n\n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n\n            if (pendingDeletions.size() != 0) {\n              extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n            }\n             \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as its very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // its possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fba839b7548159227edcb740033d0f814b323d8d","date":1424455904,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(in, false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cd448926db19517b82cc7c775c62c57f7d2ee6a","date":1432845380,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n\n            Set<String> files = new HashSet<>(Arrays.asList(listAll()));\n            // Disregard what happens with the pendingDeletions files:\n            files.removeAll(pendingDeletions);\n            String[] endFiles = files.toArray(new String[0]);\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                           \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(this + \": unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          // nocommit: we should also confirm all prior segments_N are not corrupt?\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"240cd0f67652ccfb87d7c5f8b2486d0f42012daa","date":1454536570,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          // nocommit: we should also confirm all prior segments_N are not corrupt?\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34d6426cef006e0c3625cabe7a7ec1c2b08bc501","date":1454683374,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n\n            Set<String> files = new HashSet<>(Arrays.asList(listAll()));\n            String[] endFiles = files.toArray(new String[0]);\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(this + \": unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n\n            Set<String> files = new HashSet<>(Arrays.asList(listAll()));\n            // Disregard what happens with the pendingDeletions files:\n            files.removeAll(pendingDeletions);\n            String[] endFiles = files.toArray(new String[0]);\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                                           \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(this + \": unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      Set<String> pendingDeletions = new HashSet<>(openFilesDeleted);\n      //   virus scanner when we tried to delete\n      pendingDeletions.addAll(triedToDelete);\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            allFiles.removeAll(pendingDeletions);\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            if (pendingDeletions.contains(\"segments.gen\") && endSet.contains(\"segments.gen\")) {\n              // this is possible if we hit an exception while writing segments.gen, we try to delete it\n              // and it ends out in pendingDeletions (but IFD wont remove this).\n              startSet.add(\"segments.gen\");\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"MDW: Unreferenced check: Ignoring segments.gen that we could not delete.\");\n              }\n            }\n            \n            // it's possible we cannot delete the segments_N on windows if someone has it open and\n            // maybe other files too, depending on timing. normally someone on windows wouldnt have\n            // an issue (IFD would nuke this stuff eventually), but we pass NoDeletionPolicy...\n            for (String file : pendingDeletions) {\n              if (file.startsWith(\"segments\") && !file.equals(\"segments.gen\") && endSet.contains(file)) {\n                startSet.add(file);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"MDW: Unreferenced check: Ignoring segments file: \" + file + \" that we could not delete.\");\n                }\n                SegmentInfos sis;\n                try {\n                  sis = SegmentInfos.readCommit(in, file);\n                } catch (IOException ioe) {\n                  // OK: likely some of the .si files were deleted\n                  sis = new SegmentInfos();\n                }\n                \n                try {\n                  Set<String> ghosts = new HashSet<>(sis.files(false));\n                  for (String s : ghosts) {\n                    if (endSet.contains(s) && !startSet.contains(s)) {\n                      assert pendingDeletions.contains(s);\n                      if (LuceneTestCase.VERBOSE) {\n                        System.out.println(\"MDW: Unreferenced check: Ignoring referenced file: \" + s + \" \" +\n                            \"from \" + file + \" that we could not delete.\");\n                      }\n                      startSet.add(s);\n                    }\n                  }\n                } catch (Throwable t) {\n                  System.err.println(\"ERROR processing leftover segments file \" + file + \":\");\n                  t.printStackTrace();\n                }\n              }\n            }\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              if (pendingDeletions.size() != 0) {\n                extras += \"\\n\\nThese files we had previously tried to delete, but couldn't: \" + pendingDeletions;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"929380bc7480c5244874c5df3e8ae1ba7a743877","date":1454854797,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        if (getCheckIndexOnClose()) {\n\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n            String[] endFiles = in.listAll();\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68318a4ba46080d6fee00b79975bce61491c7d1f","date":1454855183,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n        }\n        if (getCheckIndexOnClose()) {\n\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a8ec0889b27701f0ad90a25c95b75454e898cf3","date":1454871481,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n\n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          // nocommit pull this outside of \"getCheckIndexOnClose\"\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n\n            Set<String> files = new HashSet<>(Arrays.asList(listAll()));\n            String[] endFiles = files.toArray(new String[0]);\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(this + \": unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n\n            Set<String> files = new HashSet<>(Arrays.asList(listAll()));\n            String[] endFiles = files.toArray(new String[0]);\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(this + \": unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd75f58072bba84066e89d61bd7028de1bd5b632","date":1454871793,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n\n      if (getCheckIndexOnClose()) {\n        randomIOExceptionRate = 0.0;\n        randomIOExceptionRateOnOpen = 0.0;\n\n        if (DirectoryReader.indexExists(this)) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n          \n          // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n          // nocommit pull this outside of \"getCheckIndexOnClose\"\n          if (assertNoUnreferencedFilesOnClose) {\n\n            // now look for unreferenced files: discount ones that we tried to delete but could not\n            Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n            String[] startFiles = allFiles.toArray(new String[0]);\n            IndexWriterConfig iwc = new IndexWriterConfig(null);\n            iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n            // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n            TestUtil.disableVirusChecker(in);\n\n            new IndexWriter(in, iwc).rollback();\n\n            Set<String> files = new HashSet<>(Arrays.asList(listAll()));\n            String[] endFiles = files.toArray(new String[0]);\n            \n            Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n            Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n            startFiles = startSet.toArray(new String[0]);\n            endFiles = endSet.toArray(new String[0]);\n            \n            if (!Arrays.equals(startFiles, endFiles)) {\n              List<String> removed = new ArrayList<>();\n              for(String fileName : startFiles) {\n                if (!endSet.contains(fileName)) {\n                  removed.add(fileName);\n                }\n              }\n              \n              List<String> added = new ArrayList<>();\n              for(String fileName : endFiles) {\n                if (!startSet.contains(fileName)) {\n                  added.add(fileName);\n                }\n              }\n              \n              String extras;\n              if (removed.size() != 0) {\n                extras = \"\\n\\nThese files were removed: \" + removed;\n              } else {\n                extras = \"\";\n              }\n              \n              if (added.size() != 0) {\n                extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n              }\n              \n              throw new RuntimeException(this + \": unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n            }\n            \n            DirectoryReader ir1 = DirectoryReader.open(this);\n            int numDocs1 = ir1.numDocs();\n            ir1.close();\n            new IndexWriter(this, new IndexWriterConfig(null)).close();\n            DirectoryReader ir2 = DirectoryReader.open(this);\n            int numDocs2 = ir2.numDocs();\n            ir2.close();\n            assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      \n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab","date":1457539417,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28","date":1471613297,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still \" + openFiles.size() + \" open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still \" + openFiles.size() + \" open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still \" + openFiles.size() + \" open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still \" + openFiles.size() + \" open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"MDW: now assert no unref'd files at close\");\n          }\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (isOpen) {\n      isOpen = false;\n    } else {\n      in.close(); // but call it again on our wrapped dir\n      return;\n    }\n\n    boolean success = false;\n    try {\n      // files that we tried to delete, but couldn't because readers were open.\n      // all that matters is that we tried! (they will eventually go away)\n      //   still open when we tried to delete\n      maybeYield();\n      if (openFiles == null) {\n        openFiles = new HashMap<>();\n        openFilesDeleted = new HashSet<>();\n      }\n      if (openFiles.size() > 0) {\n        // print the first one as it's very verbose otherwise\n        Exception cause = null;\n        Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        // RuntimeException instead of IOException because\n        // super() does not throw IOException currently:\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still \" + openFiles.size() + \" open files: \" + openFiles, cause);\n      }\n      if (openLocks.size() > 0) {\n        Exception cause = null;\n        Iterator<RuntimeException> stacktraces = openLocks.values().iterator();\n        if (stacktraces.hasNext()) {\n          cause = stacktraces.next();\n        }\n        throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks, cause);\n      }\n      randomIOExceptionRate = 0.0;\n      randomIOExceptionRateOnOpen = 0.0;\n\n      if ((getCheckIndexOnClose() || assertNoUnreferencedFilesOnClose) && DirectoryReader.indexExists(this)) {\n        if (getCheckIndexOnClose()) {\n\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crush\");\n          }\n          crash(); // corrupt any unsynced-files\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n          } \n\n          TestUtil.checkIndex(this, getCrossCheckTermVectorsOnClose(), true, null);\n        }\n          \n        // TODO: factor this out / share w/ TestIW.assertNoUnreferencedFiles\n        if (assertNoUnreferencedFilesOnClose) {\n          System.out.println(\"MDW: now assert no unref'd files at close\");\n\n          // now look for unreferenced files: discount ones that we tried to delete but could not\n          Set<String> allFiles = new HashSet<>(Arrays.asList(listAll()));\n          String[] startFiles = allFiles.toArray(new String[0]);\n          IndexWriterConfig iwc = new IndexWriterConfig(null);\n          iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n          // We must do this before opening writer otherwise writer will be angry if there are pending deletions:\n          TestUtil.disableVirusChecker(in);\n\n          new IndexWriter(in, iwc).rollback();\n          String[] endFiles = in.listAll();\n            \n          Set<String> startSet = new TreeSet<>(Arrays.asList(startFiles));\n          Set<String> endSet = new TreeSet<>(Arrays.asList(endFiles));\n            \n          startFiles = startSet.toArray(new String[0]);\n          endFiles = endSet.toArray(new String[0]);\n            \n          if (!Arrays.equals(startFiles, endFiles)) {\n            List<String> removed = new ArrayList<>();\n            for(String fileName : startFiles) {\n              if (!endSet.contains(fileName)) {\n                removed.add(fileName);\n              }\n            }\n              \n            List<String> added = new ArrayList<>();\n            for(String fileName : endFiles) {\n              if (!startSet.contains(fileName)) {\n                added.add(fileName);\n              }\n            }\n              \n            String extras;\n            if (removed.size() != 0) {\n              extras = \"\\n\\nThese files were removed: \" + removed;\n            } else {\n              extras = \"\";\n            }\n              \n            if (added.size() != 0) {\n              extras += \"\\n\\nThese files were added (waaaaaaaaaat!): \" + added;\n            }\n              \n            throw new RuntimeException(\"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles) + extras);\n          }\n            \n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b07132423639577d6f68cebbec9c83599d5d5a3a":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"959c85e26b626bdc806252d9410817c987d0d0c9":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1","7615b855702e008d91a95a2578bf05d27372f599"],"fba839b7548159227edcb740033d0f814b323d8d":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"399ef3ff6c22f0627c82ac65f32726f3587a2aa1":["bac2bd9d901ec1ee7111a77c8e616d745fb2a362"],"7cd448926db19517b82cc7c775c62c57f7d2ee6a":["fba839b7548159227edcb740033d0f814b323d8d"],"aba371508186796cc6151d8223a5b4e16d02e26e":["21311a17d5c0c14b384b0fe7946ffb3997855720","d19974432be9aed28ee7dca73bdf01d139e763a9"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["7cd448926db19517b82cc7c775c62c57f7d2ee6a"],"68496c2200e559fb7802f7575427b7a482659afb":["68318a4ba46080d6fee00b79975bce61491c7d1f","13ea66b549e25413e4e3057bf3492ab828899110"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"30e0912f3a3069b115cfea44ff612c44d6906386":["d9773480aa9e800d0a232ab6ccac265e874b0c51"],"13ea66b549e25413e4e3057bf3492ab828899110":["dd75f58072bba84066e89d61bd7028de1bd5b632"],"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["959c85e26b626bdc806252d9410817c987d0d0c9"],"527cc14542789f47d75da436cb4287d1ab887e34":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"264935965977b4a9e2f3920420647072c9c49176":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"240cd0f67652ccfb87d7c5f8b2486d0f42012daa":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["0d49a158012a8ff48f328a4558e4bfcffbaed16f","b470f36a9372c97283360b1304eacbde22df6c0d"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"bac2bd9d901ec1ee7111a77c8e616d745fb2a362":["30e0912f3a3069b115cfea44ff612c44d6906386"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["21311a17d5c0c14b384b0fe7946ffb3997855720"],"b470f36a9372c97283360b1304eacbde22df6c0d":["7cd448926db19517b82cc7c775c62c57f7d2ee6a","34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","b6493bfa10477745a1307895992b7323b6e19ec6"],"929380bc7480c5244874c5df3e8ae1ba7a743877":["5a207d19eac354d649c3f0e2cce070017c78125e"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"5a207d19eac354d649c3f0e2cce070017c78125e":["7cd448926db19517b82cc7c775c62c57f7d2ee6a","b470f36a9372c97283360b1304eacbde22df6c0d"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"21311a17d5c0c14b384b0fe7946ffb3997855720":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["b07132423639577d6f68cebbec9c83599d5d5a3a"],"dd75f58072bba84066e89d61bd7028de1bd5b632":["4a8ec0889b27701f0ad90a25c95b75454e898cf3","68318a4ba46080d6fee00b79975bce61491c7d1f"],"aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28":["aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["21311a17d5c0c14b384b0fe7946ffb3997855720","d19974432be9aed28ee7dca73bdf01d139e763a9"],"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["240cd0f67652ccfb87d7c5f8b2486d0f42012daa"],"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d9773480aa9e800d0a232ab6ccac265e874b0c51":["c17031cb223ff09d763bb8ba49ca9d9eb1871ba7"],"1b0febf62c2d9baeee7db38998d9197700ccbab9":["dd75f58072bba84066e89d61bd7028de1bd5b632","13ea66b549e25413e4e3057bf3492ab828899110"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab","bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","959c85e26b626bdc806252d9410817c987d0d0c9"],"9eae2a56dc810a17cf807d831f720dec931a03de":["b6493bfa10477745a1307895992b7323b6e19ec6"],"6613659748fe4411a7dcf85266e55db1f95f7315":["527cc14542789f47d75da436cb4287d1ab887e34"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","b6493bfa10477745a1307895992b7323b6e19ec6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"c17031cb223ff09d763bb8ba49ca9d9eb1871ba7":["9eae2a56dc810a17cf807d831f720dec931a03de"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"7615b855702e008d91a95a2578bf05d27372f599":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1"],"b6493bfa10477745a1307895992b7323b6e19ec6":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","3384e6013a93e4d11b7d75388693f8d0388602bf"],"68318a4ba46080d6fee00b79975bce61491c7d1f":["929380bc7480c5244874c5df3e8ae1ba7a743877"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["264935965977b4a9e2f3920420647072c9c49176"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["7cd448926db19517b82cc7c775c62c57f7d2ee6a"]},"commit2Childs":{"b07132423639577d6f68cebbec9c83599d5d5a3a":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"959c85e26b626bdc806252d9410817c987d0d0c9":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["527cc14542789f47d75da436cb4287d1ab887e34"],"fba839b7548159227edcb740033d0f814b323d8d":["7cd448926db19517b82cc7c775c62c57f7d2ee6a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["21311a17d5c0c14b384b0fe7946ffb3997855720"],"399ef3ff6c22f0627c82ac65f32726f3587a2aa1":["27ab7b234eab0cbc020836989b96ed430e1065bb","7615b855702e008d91a95a2578bf05d27372f599"],"7cd448926db19517b82cc7c775c62c57f7d2ee6a":["6bfe104fc023fadc9e709f8d17403d2cc61133fe","b470f36a9372c97283360b1304eacbde22df6c0d","5a207d19eac354d649c3f0e2cce070017c78125e","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["240cd0f67652ccfb87d7c5f8b2486d0f42012daa"],"68496c2200e559fb7802f7575427b7a482659afb":["aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["959c85e26b626bdc806252d9410817c987d0d0c9","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"30e0912f3a3069b115cfea44ff612c44d6906386":["bac2bd9d901ec1ee7111a77c8e616d745fb2a362"],"13ea66b549e25413e4e3057bf3492ab828899110":["68496c2200e559fb7802f7575427b7a482659afb","1b0febf62c2d9baeee7db38998d9197700ccbab9"],"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"527cc14542789f47d75da436cb4287d1ab887e34":["6613659748fe4411a7dcf85266e55db1f95f7315"],"264935965977b4a9e2f3920420647072c9c49176":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"240cd0f67652ccfb87d7c5f8b2486d0f42012daa":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"bac2bd9d901ec1ee7111a77c8e616d745fb2a362":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","b6493bfa10477745a1307895992b7323b6e19ec6"],"b470f36a9372c97283360b1304eacbde22df6c0d":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","5a207d19eac354d649c3f0e2cce070017c78125e"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"929380bc7480c5244874c5df3e8ae1ba7a743877":["68318a4ba46080d6fee00b79975bce61491c7d1f"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"5a207d19eac354d649c3f0e2cce070017c78125e":["929380bc7480c5244874c5df3e8ae1ba7a743877"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["3384e6013a93e4d11b7d75388693f8d0388602bf","9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"21311a17d5c0c14b384b0fe7946ffb3997855720":["aba371508186796cc6151d8223a5b4e16d02e26e","d19974432be9aed28ee7dca73bdf01d139e763a9","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["fba839b7548159227edcb740033d0f814b323d8d"],"dd75f58072bba84066e89d61bd7028de1bd5b632":["13ea66b549e25413e4e3057bf3492ab828899110","1b0febf62c2d9baeee7db38998d9197700ccbab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab":["bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28","403d05f7f8d69b65659157eff1bc1d2717f04c66","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["b470f36a9372c97283360b1304eacbde22df6c0d"],"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["dd75f58072bba84066e89d61bd7028de1bd5b632"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"d9773480aa9e800d0a232ab6ccac265e874b0c51":["30e0912f3a3069b115cfea44ff612c44d6906386"],"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["264935965977b4a9e2f3920420647072c9c49176","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"9eae2a56dc810a17cf807d831f720dec931a03de":["c17031cb223ff09d763bb8ba49ca9d9eb1871ba7"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c17031cb223ff09d763bb8ba49ca9d9eb1871ba7":["d9773480aa9e800d0a232ab6ccac265e874b0c51"],"7615b855702e008d91a95a2578bf05d27372f599":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"b6493bfa10477745a1307895992b7323b6e19ec6":["d6f074e73200c07d54f242d3880a8da5a35ff97b","9eae2a56dc810a17cf807d831f720dec931a03de","8fd5be977c105554c6a7b68afcdbc511439723ab"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["b07132423639577d6f68cebbec9c83599d5d5a3a"],"68318a4ba46080d6fee00b79975bce61491c7d1f":["68496c2200e559fb7802f7575427b7a482659afb","dd75f58072bba84066e89d61bd7028de1bd5b632"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d6f074e73200c07d54f242d3880a8da5a35ff97b","1b0febf62c2d9baeee7db38998d9197700ccbab9","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","8fd5be977c105554c6a7b68afcdbc511439723ab","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}