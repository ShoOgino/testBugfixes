{"path":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","commits":[{"id":"b4804614e0358954d5d9f51128fcf3cd79e6e25b","date":1352831451,"type":1,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>(); \n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null; \n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    //One second in the future ensures a change time after the last import (DIH uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {    \n      conn = newConnection();\n      change = conn.prepareStatement(\"update people set name=?, last_modified=? where id=?\");  \n      delete  = conn.prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn.prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for(int i=0 ; i<numberToChange ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if(!changeSet.contains(id) && !deleteSet.contains(id)) {\n            boolean changeDontDelete = random().nextBoolean();\n            if(changeDontDelete) {\n              changeSet.add(id);\n              change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n              change.setTimestamp(2, theTime);\n              change.setInt(3, id);\n              Assert.assertEquals(1, change.executeUpdate());\n            } else {\n              deleteSet.add(id);\n              delete.setTimestamp(1, theTime);\n              delete.setInt(2, id);\n              Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for(int i=0 ; i<numberToAdd ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id+1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if(!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try { change.close(); } catch(Exception ex) { }\n      try { conn.close(); } catch(Exception ex) { }\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys=changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys=deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys=addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9996c9e8eaf37a4104c98ae4e08f2d78514021c3","date":1354643140,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.info(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"602d00a40b81360150f946906e46824f91cd3860","date":1354739380,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.info(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"/dev/null","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<>();\n    Set<Integer> deleteSet = new HashSet<>();\n    Set<Integer> addSet = new HashSet<>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to set change time for SQL query\")\n  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<>();\n    Set<Integer> deleteSet = new HashSet<>();\n    Set<Integer> addSet = new HashSet<>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<>();\n    Set<Integer> deleteSet = new HashSet<>();\n    Set<Integer> addSet = new HashSet<>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to set change time for SQL query\")\n  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<>();\n    Set<Integer> deleteSet = new HashSet<>();\n    Set<Integer> addSet = new HashSet<>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    if (log.isDebugEnabled()) {\n      log.debug(\"PEOPLE UPDATE USING TIMESTAMP: {}\"\n          , new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT).format(theTime));\n    }\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to set change time for SQL query\")\n  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<>();\n    Set<Integer> deleteSet = new HashSet<>();\n    Set<Integer> addSet = new HashSet<>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    log.debug(\"PEOPLE UPDATE USING TIMESTAMP: \"\n        + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT)\n            .format(theTime));\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","sourceNew":null,"sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to set change time for SQL query\")\n  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<>();\n    Set<Integer> deleteSet = new HashSet<>();\n    Set<Integer> addSet = new HashSet<>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    if (log.isDebugEnabled()) {\n      log.debug(\"PEOPLE UPDATE USING TIMESTAMP: {}\"\n          , new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", Locale.ROOT).format(theTime));\n    }\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["602d00a40b81360150f946906e46824f91cd3860"],"b4804614e0358954d5d9f51128fcf3cd79e6e25b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","602d00a40b81360150f946906e46824f91cd3860"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"602d00a40b81360150f946906e46824f91cd3860":["9996c9e8eaf37a4104c98ae4e08f2d78514021c3"],"9996c9e8eaf37a4104c98ae4e08f2d78514021c3":["b4804614e0358954d5d9f51128fcf3cd79e6e25b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"b4804614e0358954d5d9f51128fcf3cd79e6e25b":["9996c9e8eaf37a4104c98ae4e08f2d78514021c3"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4804614e0358954d5d9f51128fcf3cd79e6e25b","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"602d00a40b81360150f946906e46824f91cd3860":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","407687e67faf6e1f02a211ca078d8e3eed631027"],"9996c9e8eaf37a4104c98ae4e08f2d78514021c3":["602d00a40b81360150f946906e46824f91cd3860"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}