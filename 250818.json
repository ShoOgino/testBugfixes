{"path":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","commits":[{"id":"43adc163640856c8b07e4cf1b2046c9af56d3ae7","date":1286989273,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n        \n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n        \n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n        \n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"828f199c76d70a5ea0ddc4d9605063f1d323a28d","date":1308738340,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n        \n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n        \n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n        \n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"c26f00b574427b55127e869b935845554afde1fa":["828f199c76d70a5ea0ddc4d9605063f1d323a28d","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"2553b00f699380c64959ccb27991289aae87be2e":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"828f199c76d70a5ea0ddc4d9605063f1d323a28d":["43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","828f199c76d70a5ea0ddc4d9605063f1d323a28d","4ecea1664e8617d82eca3b8055a3c37cb4da8511","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"828f199c76d70a5ea0ddc4d9605063f1d323a28d":["c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","4ecea1664e8617d82eca3b8055a3c37cb4da8511","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}