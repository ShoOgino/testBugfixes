{"path":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","commits":[{"id":"0fcdcf196523675146a4df3193e91413533857ab","date":1390686560,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#release().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (lockExists()) {\n      try {\n        lock.release();\n      } finally {\n        lock = null;\n        try {\n          channel.close();\n        } finally {\n          channel = null;\n          try {\n            f.close();\n          } finally {\n            f = null;\n            synchronized(LOCK_HELD) {\n              LOCK_HELD.remove(path.getCanonicalPath());\n            }\n          }\n        }\n      }\n      // LUCENE-2421: we don't care anymore if the file cannot be deleted\n      // because it's held up by another process (e.g. AntiVirus). NativeFSLock\n      // does not depend on the existence/absence of the lock file\n      path.delete();\n    } else {\n      // if we don't hold the lock, and somebody still called release(), for\n      // example as a result of calling IndexWriter.unlock(), we should attempt\n      // to obtain the lock and release it. If the obtain fails, it means the\n      // lock cannot be released, and we should throw a proper exception rather\n      // than silently failing/not doing anything.\n      boolean obtained = false;\n      try {\n        if (!(obtained = obtain())) {\n          throw new LockReleaseFailedException(\n              \"Cannot forcefully unlock a NativeFSLock which is held by another indexer component: \"\n                  + path);\n        }\n      } finally {\n        if (obtained) {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void release() throws IOException {\n    if (lockExists()) {\n      try {\n        lock.release();\n      } finally {\n        lock = null;\n        try {\n          channel.close();\n        } finally {\n          channel = null;\n          try {\n            f.close();\n          } finally {\n            f = null;\n            synchronized(LOCK_HELD) {\n              LOCK_HELD.remove(path.getCanonicalPath());\n            }\n          }\n        }\n      }\n      // LUCENE-2421: we don't care anymore if the file cannot be deleted\n      // because it's held up by another process (e.g. AntiVirus). NativeFSLock\n      // does not depend on the existence/absence of the lock file\n      path.delete();\n    } else {\n      // if we don't hold the lock, and somebody still called release(), for\n      // example as a result of calling IndexWriter.unlock(), we should attempt\n      // to obtain the lock and release it. If the obtain fails, it means the\n      // lock cannot be released, and we should throw a proper exception rather\n      // than silently failing/not doing anything.\n      boolean obtained = false;\n      try {\n        if (!(obtained = obtain())) {\n          throw new LockReleaseFailedException(\n              \"Cannot forcefully unlock a NativeFSLock which is held by another indexer component: \"\n                  + path);\n        }\n      } finally {\n        if (obtained) {\n          release();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50805be75df24f05d29a4d2a496c7ec825cde9eb","date":1398078566,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    if (lockExists()) {\n      try {\n        lock.release();\n      } finally {\n        lock = null;\n        try {\n          channel.close();\n        } finally {\n          channel = null;\n        }\n      }\n    } else {\n      // if we don't hold the lock, and somebody still called release(), for\n      // example as a result of calling IndexWriter.unlock(), we should attempt\n      // to obtain the lock and release it. If the obtain fails, it means the\n      // lock cannot be released, and we should throw a proper exception rather\n      // than silently failing/not doing anything.\n      boolean obtained = false;\n      try {\n        if (!(obtained = obtain())) {\n          throw new LockReleaseFailedException(\n              \"Cannot forcefully unlock a NativeFSLock which is held by another indexer component: \"\n                  + path);\n        }\n      } finally {\n        if (obtained) {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (lockExists()) {\n      try {\n        lock.release();\n      } finally {\n        lock = null;\n        try {\n          channel.close();\n        } finally {\n          channel = null;\n          try {\n            f.close();\n          } finally {\n            f = null;\n            synchronized(LOCK_HELD) {\n              LOCK_HELD.remove(path.getCanonicalPath());\n            }\n          }\n        }\n      }\n      // LUCENE-2421: we don't care anymore if the file cannot be deleted\n      // because it's held up by another process (e.g. AntiVirus). NativeFSLock\n      // does not depend on the existence/absence of the lock file\n      path.delete();\n    } else {\n      // if we don't hold the lock, and somebody still called release(), for\n      // example as a result of calling IndexWriter.unlock(), we should attempt\n      // to obtain the lock and release it. If the obtain fails, it means the\n      // lock cannot be released, and we should throw a proper exception rather\n      // than silently failing/not doing anything.\n      boolean obtained = false;\n      try {\n        if (!(obtained = obtain())) {\n          throw new LockReleaseFailedException(\n              \"Cannot forcefully unlock a NativeFSLock which is held by another indexer component: \"\n                  + path);\n        }\n      } finally {\n        if (obtained) {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b","date":1398175632,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    try {\n      if (lock != null) {\n        lock.release();\n        lock = null;\n      }\n    } finally {\n      if (channel != null) {\n        channel.close();\n        channel = null;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (lockExists()) {\n      try {\n        lock.release();\n      } finally {\n        lock = null;\n        try {\n          channel.close();\n        } finally {\n          channel = null;\n        }\n      }\n    } else {\n      // if we don't hold the lock, and somebody still called release(), for\n      // example as a result of calling IndexWriter.unlock(), we should attempt\n      // to obtain the lock and release it. If the obtain fails, it means the\n      // lock cannot be released, and we should throw a proper exception rather\n      // than silently failing/not doing anything.\n      boolean obtained = false;\n      try {\n        if (!(obtained = obtain())) {\n          throw new LockReleaseFailedException(\n              \"Cannot forcefully unlock a NativeFSLock which is held by another indexer component: \"\n                  + path);\n        }\n      } finally {\n        if (obtained) {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":["245fee3e499fae1fc0c33a80a6dd979f9c5f49e2","0fcdcf196523675146a4df3193e91413533857ab","2cf040795587947011604327cf9538e12d298d8b","f118a5ec962b5e2658d313e6f4e6f28faa3bcb39","60e34c62b11034ddc6f3799b5c9a38cbe6de4042"],"bugIntro":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    try {\n      if (lock != null) {\n        lock.release();\n        lock = null;\n      }\n    } finally {\n      if (channel != null) {\n        channel.close();\n        channel = null;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    if (lockExists()) {\n      try {\n        lock.release();\n      } finally {\n        lock = null;\n        try {\n          channel.close();\n        } finally {\n          channel = null;\n        }\n      }\n    } else {\n      // if we don't hold the lock, and somebody still called release(), for\n      // example as a result of calling IndexWriter.unlock(), we should attempt\n      // to obtain the lock and release it. If the obtain fails, it means the\n      // lock cannot be released, and we should throw a proper exception rather\n      // than silently failing/not doing anything.\n      boolean obtained = false;\n      try {\n        if (!(obtained = obtain())) {\n          throw new LockReleaseFailedException(\n              \"Cannot forcefully unlock a NativeFSLock which is held by another indexer component: \"\n                  + path);\n        }\n      } finally {\n        if (obtained) {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fa71d5bc6be53f5f21420ccbcaecad4dd879728","date":1402044934,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    try {\n      if (lock != null) {\n        try {\n          lock.release();\n          lock = null;\n        } finally {\n          clearLockHeld(path);\n        }\n      }\n    } finally {\n      IOUtils.close(channel);\n      channel = null;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    try {\n      if (lock != null) {\n        lock.release();\n        lock = null;\n      }\n    } finally {\n      if (channel != null) {\n        channel.close();\n        channel = null;\n      }\n    }\n  }\n\n","bugFix":["2cf040795587947011604327cf9538e12d298d8b","ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b","60e34c62b11034ddc6f3799b5c9a38cbe6de4042"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#close().mjava","sourceNew":null,"sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    try {\n      if (lock != null) {\n        try {\n          lock.release();\n          lock = null;\n        } finally {\n          clearLockHeld(path);\n        }\n      }\n    } finally {\n      IOUtils.close(channel);\n      channel = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b":["50805be75df24f05d29a4d2a496c7ec825cde9eb"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["50805be75df24f05d29a4d2a496c7ec825cde9eb","ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b"],"285cdc737de75b7cc7c284a156b20214deb67bca":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"50805be75df24f05d29a4d2a496c7ec825cde9eb":["0fcdcf196523675146a4df3193e91413533857ab"],"0fcdcf196523675146a4df3193e91413533857ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["285cdc737de75b7cc7c284a156b20214deb67bca"],"8fa71d5bc6be53f5f21420ccbcaecad4dd879728":["ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b"]},"commit2Childs":{"ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"285cdc737de75b7cc7c284a156b20214deb67bca":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0fcdcf196523675146a4df3193e91413533857ab"],"50805be75df24f05d29a4d2a496c7ec825cde9eb":["ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"0fcdcf196523675146a4df3193e91413533857ab":["50805be75df24f05d29a4d2a496c7ec825cde9eb"],"8fa71d5bc6be53f5f21420ccbcaecad4dd879728":["285cdc737de75b7cc7c284a156b20214deb67bca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}