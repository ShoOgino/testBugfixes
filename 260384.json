{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","commits":[{"id":"bd7a2b4785d366164d3cd69f9948de6ff34d23a1","date":1500527874,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#create(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore create(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d301cb76d81de80d07b44735622a04d49ed938eb","date":1500536382,"type":1,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#create(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore create(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":1,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#create(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore create(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"004ec9e26487ae9b6205e790f8f77ef5e98d8daf","date":1506366751,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9efa9c0fcd87863d1a86eed29d4304c11bc7d50a","date":1506410441,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27d63bd6ea608c208e37fd3e13e7b27f06da6b60","date":1507105517,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["85032ab568b3f50eabd577aaa994ba197db93758"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = coreConfigService.getConfig(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f15af35d55d70c34451f9df5edeaeff6b31f8cbe","date":1519625627,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4aea71c8b6a44bbbd3b8fcc42e5838a92b35634f","date":1522415499,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                           <code>\n   *                                           try {\n   *                                              solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                              createFromDescriptor(...);\n   *                                           } finally {\n   *                                              solrCores.removeFromPendingOps(dcore.getName());\n   *                                           }\n   *                                           </code>\n   *                                         </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *\n   * WARNING: Any call to this method should be surrounded by a try/finally block\n   *          that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *  <pre>\n   *   <code>\n   *   try {\n   *      solrCores.waitAddPendingCoreOps(dcore.getName());\n   *      createFromDescriptor(...);\n   *   } finally {\n   *      solrCores.removeFromPendingOps(dcore.getName());\n   *   }\n   *   </code>\n   * </pre>\n   *\n   *  Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *  getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *  If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *  to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *  introduce a race condition, see getCore() for the place it would be a problem\n   *\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if(core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954ae83b7dfacaa33d48ea056448ae11f7745a93","date":1571867711,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                                               <code>\n   *                                                               try {\n   *                                                                  solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                                                  createFromDescriptor(...);\n   *                                                               } finally {\n   *                                                                  solrCores.removeFromPendingOps(dcore.getName());\n   *                                                               }\n   *                                                               </code>\n   *                                                             </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                           <code>\n   *                                           try {\n   *                                              solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                              createFromDescriptor(...);\n   *                                           } finally {\n   *                                              solrCores.removeFromPendingOps(dcore.getName());\n   *                                           }\n   *                                           </code>\n   *                                         </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e4fb176991e13ab85dfe62dceeb287dde115745","date":1579630717,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                                               <code>\n   *                                                               try {\n   *                                                                  solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                                                  createFromDescriptor(...);\n   *                                                               } finally {\n   *                                                                  solrCores.removeFromPendingOps(dcore.getName());\n   *                                                               }\n   *                                                               </code>\n   *                                                             </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = coreConfigService.loadConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                                               <code>\n   *                                                               try {\n   *                                                                  solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                                                  createFromDescriptor(...);\n   *                                                               } finally {\n   *                                                                  solrCores.removeFromPendingOps(dcore.getName());\n   *                                                               }\n   *                                                               </code>\n   *                                                             </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = getConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#createFromDescriptor(CoreDescriptor,boolean,boolean).mjava","sourceNew":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                                               <code>\n   *                                                               try {\n   *                                                                  solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                                                  createFromDescriptor(...);\n   *                                                               } finally {\n   *                                                                  solrCores.removeFromPendingOps(dcore.getName());\n   *                                                               }\n   *                                                               </code>\n   *                                                             </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = coreConfigService.loadConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      if (log.isInfoEnabled()) {\n        log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      }\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core based on a CoreDescriptor.\n   *\n   * @param dcore        a core descriptor\n   * @param publishState publish core state to the cluster if true\n   *                     <p>\n   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n   *\n   *                     <pre>\n   *                                                               <code>\n   *                                                               try {\n   *                                                                  solrCores.waitAddPendingCoreOps(dcore.getName());\n   *                                                                  createFromDescriptor(...);\n   *                                                               } finally {\n   *                                                                  solrCores.removeFromPendingOps(dcore.getName());\n   *                                                               }\n   *                                                               </code>\n   *                                                             </pre>\n   *                     <p>\n   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n   *                     introduce a race condition, see getCore() for the place it would be a problem\n   * @return the newly created core\n   */\n  @SuppressWarnings(\"resource\")\n  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n\n    if (isShutDown) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n    }\n\n    SolrCore core = null;\n    try {\n      MDCLoggingContext.setCoreDescriptor(this, dcore);\n      SolrIdentifierValidator.validateCoreName(dcore.getName());\n      if (zkSys.getZkController() != null) {\n        zkSys.getZkController().preRegister(dcore, publishState);\n      }\n\n      ConfigSet coreConfig = coreConfigService.loadConfigSet(dcore);\n      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n      log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n      try {\n        core = new SolrCore(this, dcore, coreConfig);\n      } catch (SolrException e) {\n        core = processCoreCreateException(e, dcore, coreConfig);\n      }\n\n      // always kick off recovery if we are in non-Cloud mode\n      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n      }\n\n      registerCore(dcore, core, publishState, newCollection);\n\n      return core;\n    } catch (Exception e) {\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n        // this mostly happen when the core is deleted when this node is down\n        unload(dcore.getName(), true, true, true);\n        throw e;\n      }\n      solrCores.removeCoreDescriptor(dcore);\n      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw solrException;\n    } catch (Throwable t) {\n      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n      solrCores.removeCoreDescriptor(dcore);\n      if (core != null && !core.isClosed())\n        IOUtils.closeQuietly(core);\n      throw t;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"27d63bd6ea608c208e37fd3e13e7b27f06da6b60":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a"],"9efa9c0fcd87863d1a86eed29d4304c11bc7d50a":["d301cb76d81de80d07b44735622a04d49ed938eb","004ec9e26487ae9b6205e790f8f77ef5e98d8daf"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a","6240b74b884c5587f2a4062dd27d6c32bf228889"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["936cdd5882761db3b844afd6f84ab81cbb011a75"],"3e4fb176991e13ab85dfe62dceeb287dde115745":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d301cb76d81de80d07b44735622a04d49ed938eb"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe","4aea71c8b6a44bbbd3b8fcc42e5838a92b35634f"],"d301cb76d81de80d07b44735622a04d49ed938eb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bd7a2b4785d366164d3cd69f9948de6ff34d23a1"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1","9efa9c0fcd87863d1a86eed29d4304c11bc7d50a"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"140be51d03394488536f4aacedace29f9b318347":["3e4fb176991e13ab85dfe62dceeb287dde115745"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["560c18d71dad43d675158783c3840f8c80d6d39c"],"bd7a2b4785d366164d3cd69f9948de6ff34d23a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"560c18d71dad43d675158783c3840f8c80d6d39c":["27d63bd6ea608c208e37fd3e13e7b27f06da6b60","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"4aea71c8b6a44bbbd3b8fcc42e5838a92b35634f":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["140be51d03394488536f4aacedace29f9b318347"],"004ec9e26487ae9b6205e790f8f77ef5e98d8daf":["d301cb76d81de80d07b44735622a04d49ed938eb"]},"commit2Childs":{"27d63bd6ea608c208e37fd3e13e7b27f06da6b60":["560c18d71dad43d675158783c3840f8c80d6d39c"],"9efa9c0fcd87863d1a86eed29d4304c11bc7d50a":["27d63bd6ea608c208e37fd3e13e7b27f06da6b60","c304e97e7c1d472bc70e801b35ee78583916c6cd","6240b74b884c5587f2a4062dd27d6c32bf228889"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"3e4fb176991e13ab85dfe62dceeb287dde115745":["140be51d03394488536f4aacedace29f9b318347"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"d301cb76d81de80d07b44735622a04d49ed938eb":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a","936cdd5882761db3b844afd6f84ab81cbb011a75","004ec9e26487ae9b6205e790f8f77ef5e98d8daf"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["3e4fb176991e13ab85dfe62dceeb287dde115745"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["936cdd5882761db3b844afd6f84ab81cbb011a75","d301cb76d81de80d07b44735622a04d49ed938eb","bd7a2b4785d366164d3cd69f9948de6ff34d23a1"],"140be51d03394488536f4aacedace29f9b318347":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","4aea71c8b6a44bbbd3b8fcc42e5838a92b35634f"],"bd7a2b4785d366164d3cd69f9948de6ff34d23a1":["d301cb76d81de80d07b44735622a04d49ed938eb"],"560c18d71dad43d675158783c3840f8c80d6d39c":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"4aea71c8b6a44bbbd3b8fcc42e5838a92b35634f":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"004ec9e26487ae9b6205e790f8f77ef5e98d8daf":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}