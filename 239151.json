{"path":"modules/spatial-lucene/src/main/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","commits":[{"id":"b17c5c53627893d93f9261826cc6d9c447c5ee3a","date":1329777932,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"modules/spatial-lucene/src/main/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","pathOld":"/dev/null","sourceNew":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef186f4ac90644cd4e8df6b66acb56a52e5ca602","date":1329778037,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"modules/spatial/src/main/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","pathOld":"modules/spatial-lucene/src/main/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","sourceNew":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","sourceOld":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ef186f4ac90644cd4e8df6b66acb56a52e5ca602":["b17c5c53627893d93f9261826cc6d9c447c5ee3a"],"b17c5c53627893d93f9261826cc6d9c447c5ee3a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b17c5c53627893d93f9261826cc6d9c447c5ee3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ef186f4ac90644cd4e8df6b66acb56a52e5ca602":[],"b17c5c53627893d93f9261826cc6d9c447c5ee3a":["ef186f4ac90644cd4e8df6b66acb56a52e5ca602"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ef186f4ac90644cd4e8df6b66acb56a52e5ca602","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}