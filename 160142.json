{"path":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","commits":[{"id":"6e02c0d6a64df9c63897458b31d88b5ec3b854a5","date":1454964111,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Builds a MergePolicy, may also modify the value returned by\n   * getUseCompoundFile() for use by the IndexWriterConfig if \n   * \"useCompoundFile\" is specified as an init arg for \n   * an out of the box MergePolicy that no longer supports it\n   *\n   * @see #fixUseCFMergePolicyInitArg\n   * @see #getUseCompoundFile\n   */\n  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {\n    final MergePolicy policy;\n    if (mergePolicyInfo == null) {\n      policy = defaultMergePolicyFactory.getMergePolicy();\n    } else {\n      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);\n    }\n\n    if (policy instanceof LogMergePolicy) {\n      LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n\n      if (maxMergeDocs != -1)\n        logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n\n      if (mergeFactor != -1)\n        logMergePolicy.setMergeFactor(mergeFactor);\n    } else if (policy instanceof TieredMergePolicy) {\n      TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n\n      if (mergeFactor != -1) {\n        tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n        tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n      }\n    } else if (mergeFactor != -1) {\n      log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n    }\n\n    if (mergePolicyInfo != null) {\n      SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);\n    }\n\n    return policy;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b531d6853cf691cd84ab58193ce7a89a424289e","date":1455121686,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Builds a MergePolicy, may also modify the value returned by\n   * getUseCompoundFile() for use by the IndexWriterConfig if \n   * \"useCompoundFile\" is specified as an init arg for \n   * an out of the box MergePolicy that no longer supports it\n   *\n   * @see #fixUseCFMergePolicyInitArg\n   * @see #getUseCompoundFile\n   */\n  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {\n    final MergePolicy policy;\n    if (mergePolicyInfo == null) {\n      final SolrResourceLoader resourceLoader = schema.getResourceLoader();\n      final MergePolicyFactoryArgs mpfArgs = new MergePolicyFactoryArgs();\n      final MergePolicyFactory defaultMergePolicyFactory = resourceLoader.newInstance(\n          DEFAULT_MERGE_POLICY_FACTORY_CLASSNAME,\n          MergePolicyFactory.class,\n          NO_SUB_PACKAGES,\n          new Class[] { SolrResourceLoader.class, MergePolicyFactoryArgs.class, IndexSchema.class },\n          new Object[] { resourceLoader, mpfArgs, schema });\n      policy = defaultMergePolicyFactory.getMergePolicy();\n    } else {\n      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);\n    }\n\n    if (policy instanceof LogMergePolicy) {\n      LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n\n      if (maxMergeDocs != -1)\n        logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n\n      if (mergeFactor != -1)\n        logMergePolicy.setMergeFactor(mergeFactor);\n    } else if (policy instanceof TieredMergePolicy) {\n      TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n\n      if (mergeFactor != -1) {\n        tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n        tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n      }\n    } else if (mergeFactor != -1) {\n      log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n    }\n\n    if (mergePolicyInfo != null) {\n      SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);\n    }\n\n    return policy;\n  }\n\n","sourceOld":"  /**\n   * Builds a MergePolicy, may also modify the value returned by\n   * getUseCompoundFile() for use by the IndexWriterConfig if \n   * \"useCompoundFile\" is specified as an init arg for \n   * an out of the box MergePolicy that no longer supports it\n   *\n   * @see #fixUseCFMergePolicyInitArg\n   * @see #getUseCompoundFile\n   */\n  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {\n    final MergePolicy policy;\n    if (mergePolicyInfo == null) {\n      policy = defaultMergePolicyFactory.getMergePolicy();\n    } else {\n      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);\n    }\n\n    if (policy instanceof LogMergePolicy) {\n      LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n\n      if (maxMergeDocs != -1)\n        logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n\n      if (mergeFactor != -1)\n        logMergePolicy.setMergeFactor(mergeFactor);\n    } else if (policy instanceof TieredMergePolicy) {\n      TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n\n      if (mergeFactor != -1) {\n        tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n        tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n      }\n    } else if (mergeFactor != -1) {\n      log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n    }\n\n    if (mergePolicyInfo != null) {\n      SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);\n    }\n\n    return policy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70d848516a5d0b23d183a2ceb4f4fb8634205956","date":1496408348,"type":4,"author":"Christine Poerschke","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds a MergePolicy, may also modify the value returned by\n   * getUseCompoundFile() for use by the IndexWriterConfig if \n   * \"useCompoundFile\" is specified as an init arg for \n   * an out of the box MergePolicy that no longer supports it\n   *\n   * @see #fixUseCFMergePolicyInitArg\n   * @see #getUseCompoundFile\n   */\n  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {\n    final MergePolicy policy;\n    if (mergePolicyInfo == null) {\n      final SolrResourceLoader resourceLoader = schema.getResourceLoader();\n      final MergePolicyFactoryArgs mpfArgs = new MergePolicyFactoryArgs();\n      final MergePolicyFactory defaultMergePolicyFactory = resourceLoader.newInstance(\n          DEFAULT_MERGE_POLICY_FACTORY_CLASSNAME,\n          MergePolicyFactory.class,\n          NO_SUB_PACKAGES,\n          new Class[] { SolrResourceLoader.class, MergePolicyFactoryArgs.class, IndexSchema.class },\n          new Object[] { resourceLoader, mpfArgs, schema });\n      policy = defaultMergePolicyFactory.getMergePolicy();\n    } else {\n      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);\n    }\n\n    if (policy instanceof LogMergePolicy) {\n      LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n\n      if (maxMergeDocs != -1)\n        logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n\n      if (mergeFactor != -1)\n        logMergePolicy.setMergeFactor(mergeFactor);\n    } else if (policy instanceof TieredMergePolicy) {\n      TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n\n      if (mergeFactor != -1) {\n        tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n        tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n      }\n    } else if (mergeFactor != -1) {\n      log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n    }\n\n    if (mergePolicyInfo != null) {\n      SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);\n    }\n\n    return policy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds a MergePolicy, may also modify the value returned by\n   * getUseCompoundFile() for use by the IndexWriterConfig if \n   * \"useCompoundFile\" is specified as an init arg for \n   * an out of the box MergePolicy that no longer supports it\n   *\n   * @see #fixUseCFMergePolicyInitArg\n   * @see #getUseCompoundFile\n   */\n  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {\n    final MergePolicy policy;\n    if (mergePolicyInfo == null) {\n      final SolrResourceLoader resourceLoader = schema.getResourceLoader();\n      final MergePolicyFactoryArgs mpfArgs = new MergePolicyFactoryArgs();\n      final MergePolicyFactory defaultMergePolicyFactory = resourceLoader.newInstance(\n          DEFAULT_MERGE_POLICY_FACTORY_CLASSNAME,\n          MergePolicyFactory.class,\n          NO_SUB_PACKAGES,\n          new Class[] { SolrResourceLoader.class, MergePolicyFactoryArgs.class, IndexSchema.class },\n          new Object[] { resourceLoader, mpfArgs, schema });\n      policy = defaultMergePolicyFactory.getMergePolicy();\n    } else {\n      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);\n    }\n\n    if (policy instanceof LogMergePolicy) {\n      LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n\n      if (maxMergeDocs != -1)\n        logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n\n      if (mergeFactor != -1)\n        logMergePolicy.setMergeFactor(mergeFactor);\n    } else if (policy instanceof TieredMergePolicy) {\n      TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n\n      if (mergeFactor != -1) {\n        tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n        tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n      }\n    } else if (mergeFactor != -1) {\n      log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n    }\n\n    if (mergePolicyInfo != null) {\n      SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);\n    }\n\n    return policy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#buildMergePolicyFromInfo(IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds a MergePolicy, may also modify the value returned by\n   * getUseCompoundFile() for use by the IndexWriterConfig if \n   * \"useCompoundFile\" is specified as an init arg for \n   * an out of the box MergePolicy that no longer supports it\n   *\n   * @see #fixUseCFMergePolicyInitArg\n   * @see #getUseCompoundFile\n   */\n  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {\n    final MergePolicy policy;\n    if (mergePolicyInfo == null) {\n      final SolrResourceLoader resourceLoader = schema.getResourceLoader();\n      final MergePolicyFactoryArgs mpfArgs = new MergePolicyFactoryArgs();\n      final MergePolicyFactory defaultMergePolicyFactory = resourceLoader.newInstance(\n          DEFAULT_MERGE_POLICY_FACTORY_CLASSNAME,\n          MergePolicyFactory.class,\n          NO_SUB_PACKAGES,\n          new Class[] { SolrResourceLoader.class, MergePolicyFactoryArgs.class, IndexSchema.class },\n          new Object[] { resourceLoader, mpfArgs, schema });\n      policy = defaultMergePolicyFactory.getMergePolicy();\n    } else {\n      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);\n    }\n\n    if (policy instanceof LogMergePolicy) {\n      LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n\n      if (maxMergeDocs != -1)\n        logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n\n      if (mergeFactor != -1)\n        logMergePolicy.setMergeFactor(mergeFactor);\n    } else if (policy instanceof TieredMergePolicy) {\n      TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n      fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n\n      if (mergeFactor != -1) {\n        tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n        tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n      }\n    } else if (mergeFactor != -1) {\n      log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n    }\n\n    if (mergePolicyInfo != null) {\n      SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);\n    }\n\n    return policy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["0b531d6853cf691cd84ab58193ce7a89a424289e","70d848516a5d0b23d183a2ceb4f4fb8634205956"],"6e02c0d6a64df9c63897458b31d88b5ec3b854a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0b531d6853cf691cd84ab58193ce7a89a424289e":["6e02c0d6a64df9c63897458b31d88b5ec3b854a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"70d848516a5d0b23d183a2ceb4f4fb8634205956":["0b531d6853cf691cd84ab58193ce7a89a424289e"],"28288370235ed02234a64753cdbf0c6ec096304a":["0b531d6853cf691cd84ab58193ce7a89a424289e","70d848516a5d0b23d183a2ceb4f4fb8634205956"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"6e02c0d6a64df9c63897458b31d88b5ec3b854a5":["0b531d6853cf691cd84ab58193ce7a89a424289e"],"0b531d6853cf691cd84ab58193ce7a89a424289e":["e9017cf144952056066919f1ebc7897ff9bd71b1","70d848516a5d0b23d183a2ceb4f4fb8634205956","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e02c0d6a64df9c63897458b31d88b5ec3b854a5"],"70d848516a5d0b23d183a2ceb4f4fb8634205956":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}