{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":null,"sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f492fe129985750df09c8dac738aecc503158bb3","date":1464099630,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"122251c49e5a9fa95f056ea257ae3ab452099fc7","date":1464820065,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","date":1512420564,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":["33e096accda90a8bd2279f890efe2e287f47c743"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads(IndexWriter writer)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b8498afacfc8322268ca0d659d274fcce08d557","date":1524577248,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads(IndexWriter writer)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9664831d785795f0f380fccc6db560efb979fdbb","date":1526559002,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34067df01cbbefc83d0b316037fe4e10d89ba6a3","date":1559054674,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assert assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n      flushingDeleteQueue.close(); // all DWPT have been processed and this queue has been fully flushed to the ticket-queue\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9","date":1559371943,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assert assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n      flushingDeleteQueue.close(); // all DWPT have been processed and this queue has been fully flushed to the ticket-queue\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07024a7318c25225dc4d070cf6d047315b73aaf","date":1586885963,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assert assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n      flushingDeleteQueue.close(); // all DWPT have been processed and this queue has been fully flushed to the ticket-queue\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assert assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n      flushingDeleteQueue.close(); // all DWPT have been processed and this queue has been fully flushed to the ticket-queue\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"7af110b00ea8df9429309d83e38e0533d82e144f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["c02b804ab16489b95429791a2d8fb0e0728354d4","6483e4260c08168709c02238ae083a51519a28dd"],"6b8498afacfc8322268ca0d659d274fcce08d557":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"9664831d785795f0f380fccc6db560efb979fdbb":["6b8498afacfc8322268ca0d659d274fcce08d557"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"34067df01cbbefc83d0b316037fe4e10d89ba6a3":["9664831d785795f0f380fccc6db560efb979fdbb"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["f492fe129985750df09c8dac738aecc503158bb3"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","7af110b00ea8df9429309d83e38e0533d82e144f"],"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9":["9664831d785795f0f380fccc6db560efb979fdbb","34067df01cbbefc83d0b316037fe4e10d89ba6a3"],"6483e4260c08168709c02238ae083a51519a28dd":["c02b804ab16489b95429791a2d8fb0e0728354d4","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["191128ac5b85671b1671e2c857437694283b6ebf","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["f492fe129985750df09c8dac738aecc503158bb3","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"28288370235ed02234a64753cdbf0c6ec096304a":["191128ac5b85671b1671e2c857437694283b6ebf","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c02b804ab16489b95429791a2d8fb0e0728354d4","191128ac5b85671b1671e2c857437694283b6ebf"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"b07024a7318c25225dc4d070cf6d047315b73aaf":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"],"f492fe129985750df09c8dac738aecc503158bb3":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["7af110b00ea8df9429309d83e38e0533d82e144f"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b07024a7318c25225dc4d070cf6d047315b73aaf"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"7af110b00ea8df9429309d83e38e0533d82e144f":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","9299079153fd7895bf3cf6835cf7019af2ba89b3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["6b8498afacfc8322268ca0d659d274fcce08d557"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"191128ac5b85671b1671e2c857437694283b6ebf":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6b8498afacfc8322268ca0d659d274fcce08d557":["9664831d785795f0f380fccc6db560efb979fdbb"],"9664831d785795f0f380fccc6db560efb979fdbb":["34067df01cbbefc83d0b316037fe4e10d89ba6a3","34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"34067df01cbbefc83d0b316037fe4e10d89ba6a3":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["6483e4260c08168709c02238ae083a51519a28dd"],"28288370235ed02234a64753cdbf0c6ec096304a":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c02b804ab16489b95429791a2d8fb0e0728354d4":["191128ac5b85671b1671e2c857437694283b6ebf","6483e4260c08168709c02238ae083a51519a28dd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f492fe129985750df09c8dac738aecc503158bb3"],"b07024a7318c25225dc4d070cf6d047315b73aaf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f492fe129985750df09c8dac738aecc503158bb3":["122251c49e5a9fa95f056ea257ae3ab452099fc7","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}