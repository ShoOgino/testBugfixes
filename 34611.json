{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","commits":[{"id":"e70df4d80cde893a6897f8e6543c2d7666b73d7a","date":1365615272,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","sourceNew":"  void verifyEquals(List<FacetRequest> requests, String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    int numExpected = 0;\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] != null) {\n        numExpected++;\n      }\n    }\n\n    assertEquals(numExpected, actual.facetResults.size());\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] == null) {\n        continue;\n      }\n      int idx = -1;\n      for(int i=0;i<requests.size();i++) {\n        if (Integer.parseInt(requests.get(i).categoryPath.components[0].substring(3)) == dim) {\n          idx = i;\n          break;\n        }\n      }\n      assert idx != -1;\n      FacetResult fr = actual.facetResults.get(idx);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    assertEquals(expected.counts.length, actual.facetResults.size());\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      FacetResult fr = actual.facetResults.get(dim);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      int idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a","date":1365621037,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","sourceNew":"  void verifyEquals(List<FacetRequest> requests, String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    int numExpected = 0;\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] != null) {\n        numExpected++;\n      }\n    }\n\n    assertEquals(numExpected, actual.facetResults.size());\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] == null) {\n        continue;\n      }\n      int idx = -1;\n      for(int i=0;i<requests.size();i++) {\n        if (Integer.parseInt(requests.get(i).categoryPath.components[0].substring(3)) == dim) {\n          idx = i;\n          break;\n        }\n      }\n      assert idx != -1;\n      FacetResult fr = actual.facetResults.get(idx);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","sourceOld":"  void verifyEquals(List<FacetRequest> requests, String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    int numExpected = 0;\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] != null) {\n        numExpected++;\n      }\n    }\n\n    assertEquals(numExpected, actual.facetResults.size());\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] == null) {\n        continue;\n      }\n      int idx = -1;\n      for(int i=0;i<requests.size();i++) {\n        if (Integer.parseInt(requests.get(i).categoryPath.components[0].substring(3)) == dim) {\n          idx = i;\n          break;\n        }\n      }\n      assert idx != -1;\n      FacetResult fr = actual.facetResults.get(idx);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce7aff7772c162c15d520e31af46c555f60d5c3b","date":1385135519,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","sourceNew":null,"sourceOld":"  void verifyEquals(List<FacetRequest> requests, String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    int numExpected = 0;\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] != null) {\n        numExpected++;\n      }\n    }\n\n    assertEquals(numExpected, actual.facetResults.size());\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] == null) {\n        continue;\n      }\n      int idx = -1;\n      for(int i=0;i<requests.size();i++) {\n        if (Integer.parseInt(requests.get(i).categoryPath.components[0].substring(3)) == dim) {\n          idx = i;\n          break;\n        }\n      }\n      assert idx != -1;\n      FacetResult fr = actual.facetResults.get(idx);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","sourceNew":null,"sourceOld":"  void verifyEquals(List<FacetRequest> requests, String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    int numExpected = 0;\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] != null) {\n        numExpected++;\n      }\n    }\n\n    assertEquals(numExpected, actual.facetResults.size());\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] == null) {\n        continue;\n      }\n      int idx = -1;\n      for(int i=0;i<requests.size();i++) {\n        if (Integer.parseInt(requests.get(i).categoryPath.components[0].substring(3)) == dim) {\n          idx = i;\n          break;\n        }\n      }\n      assert idx != -1;\n      FacetResult fr = actual.facetResults.get(idx);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a","ce7aff7772c162c15d520e31af46c555f60d5c3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a":["ce7aff7772c162c15d520e31af46c555f60d5c3b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}