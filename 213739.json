{"path":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","commits":[{"id":"ad5c037f4cf3ce8870b782e5228d9f308eeda6f9","date":1391560885,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    Map<String, Class<QParserPlugin>> standardPlugins = getStandardQParsers();\n\n    List<String> notStatic = new ArrayList<String>(standardPlugins.size());\n    List<String> notFinal = new ArrayList<String>(standardPlugins.size());\n    List<String> mismatch = new ArrayList<String>(standardPlugins.size());\n \n    for (Map.Entry<String,Class<QParserPlugin>> pair : standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n               standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    Map<String, Class<QParserPlugin>> standardPlugins = getStandardQParsers();\n\n    List<String> notStatic = new ArrayList<>(standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(standardPlugins.size());\n \n    for (Map.Entry<String,Class<QParserPlugin>> pair : standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n               standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    Map<String, Class<QParserPlugin>> standardPlugins = getStandardQParsers();\n\n    List<String> notStatic = new ArrayList<String>(standardPlugins.size());\n    List<String> notFinal = new ArrayList<String>(standardPlugins.size());\n    List<String> mismatch = new ArrayList<String>(standardPlugins.size());\n \n    for (Map.Entry<String,Class<QParserPlugin>> pair : standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n               standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, Class<? extends QParserPlugin>> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    Map<String, Class<QParserPlugin>> standardPlugins = getStandardQParsers();\n\n    List<String> notStatic = new ArrayList<>(standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(standardPlugins.size());\n \n    for (Map.Entry<String,Class<QParserPlugin>> pair : standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n               standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, Class<? extends QParserPlugin>> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    Map<String, Class<QParserPlugin>> standardPlugins = getStandardQParsers();\n\n    List<String> notStatic = new ArrayList<>(standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(standardPlugins.size());\n \n    for (Map.Entry<String,Class<QParserPlugin>> pair : standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n               standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf6d72d9a6aa495633b49f3d36910c508b8ccf77","date":1528225892,"type":3,"author":"Jeff","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, Class<? extends QParserPlugin>> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, Class<? extends QParserPlugin>> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, Class<? extends QParserPlugin>> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue();\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d46ef4f5628f059a25b616ca1ae764c69dc6741","date":1530637775,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    // for Solr 7.x backcompat only\n    mismatch.remove(SignificantTermsQParserPlugin.OLD_NAME\n        + \" != \" + SignificantTermsQParserPlugin.NAME\n        + \"(\" + SignificantTermsQParserPlugin.class.getName() + \")\");\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac72b82669b3ac5f28f627c47032815c8109274d","date":1530710036,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStandardQParsers#testRegisteredName().mjava","sourceNew":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","sourceOld":"  /**\n   * Test standard query parsers registered in {@link org.apache.solr.search.QParserPlugin#standardPlugins}\n   * have NAME field which is final, static, and matches the registered name.\n   */\n  @Test\n  public void testRegisteredName() throws Exception {\n    List<String> notStatic = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> notFinal = new ArrayList<>(QParserPlugin.standardPlugins.size());\n    List<String> mismatch = new ArrayList<>(QParserPlugin.standardPlugins.size());\n\n    for (Map.Entry<String, QParserPlugin> pair : QParserPlugin.standardPlugins.entrySet()) {\n      String regName = pair.getKey();\n      Class<? extends QParserPlugin> clazz = pair.getValue().getClass();;\n\n      Field nameField = clazz.getField(FIELD_NAME);\n      int modifiers = nameField.getModifiers();\n      if (!Modifier.isFinal(modifiers)) {\n        notFinal.add(clazz.getName());\n      }\n      if (!Modifier.isStatic(modifiers)) {\n        notStatic.add(clazz.getName());\n      } else if (! regName.equals(nameField.get(null))) {\n        mismatch.add(regName +\" != \"+ nameField.get(null) +\"(\"+ clazz.getName() +\")\");\n      }\n    }\n\n    // for Solr 7.x backcompat only\n    mismatch.remove(SignificantTermsQParserPlugin.OLD_NAME\n        + \" != \" + SignificantTermsQParserPlugin.NAME\n        + \"(\" + SignificantTermsQParserPlugin.class.getName() + \")\");\n\n    assertTrue(\"All standard QParsers must have final NAME, broken: \" + notFinal, \n               notFinal.isEmpty());\n    assertTrue(\"All standard QParsers must have static NAME, broken: \" + notStatic, \n               notStatic.isEmpty());\n    assertTrue(\"All standard QParsers must be registered using NAME, broken: \" + mismatch, \n               mismatch.isEmpty());\n\n    assertTrue(\"DEFAULT_QTYPE is not in the standard set of registered names: \" + \n               QParserPlugin.DEFAULT_QTYPE,\n        QParserPlugin.standardPlugins.keySet().contains(QParserPlugin.DEFAULT_QTYPE));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ad5c037f4cf3ce8870b782e5228d9f308eeda6f9"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9aea0485ecacb6734c17da2d02569816c23a69c1"],"bf6d72d9a6aa495633b49f3d36910c508b8ccf77":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"ad5c037f4cf3ce8870b782e5228d9f308eeda6f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["9aea0485ecacb6734c17da2d02569816c23a69c1","bf6d72d9a6aa495633b49f3d36910c508b8ccf77"],"4d46ef4f5628f059a25b616ca1ae764c69dc6741":["bf6d72d9a6aa495633b49f3d36910c508b8ccf77"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f592209545c71895260367152601e9200399776d":["9aea0485ecacb6734c17da2d02569816c23a69c1","bf6d72d9a6aa495633b49f3d36910c508b8ccf77"],"ac72b82669b3ac5f28f627c47032815c8109274d":["4d46ef4f5628f059a25b616ca1ae764c69dc6741"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ac72b82669b3ac5f28f627c47032815c8109274d"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"bf6d72d9a6aa495633b49f3d36910c508b8ccf77":["b70042a8a492f7054d480ccdd2be9796510d4327","4d46ef4f5628f059a25b616ca1ae764c69dc6741","f592209545c71895260367152601e9200399776d"],"ad5c037f4cf3ce8870b782e5228d9f308eeda6f9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad5c037f4cf3ce8870b782e5228d9f308eeda6f9"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"4d46ef4f5628f059a25b616ca1ae764c69dc6741":["ac72b82669b3ac5f28f627c47032815c8109274d"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","bf6d72d9a6aa495633b49f3d36910c508b8ccf77","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"ac72b82669b3ac5f28f627c47032815c8109274d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}