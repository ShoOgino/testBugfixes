{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"671279fa1676e7f2755c2745a25abd77a169f992","date":1312053489,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":["c3465573b8d89796a7dc94c1b6461292f8708c6d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b09644855fe79c27cf261552509561b8ce34c4c7","date":1312056839,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e","date":1313005033,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cec585935ebadb78352a93e4a429d2b89fb2d53e","date":1313269561,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( cmd.commitWithin );\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16a110e87d79276dcf4554fb1d02324feb891795","date":1313710986,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( cmd.commitWithin );\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c518d12136e15c9de6fa3d2c4bf5add07311a685","date":1313718511,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":["70663341fea7eaba7572ef11c033a2c631fa3142"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd0ef6574805f3cb9880e0983b7548a6aa933508","date":1315345052,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98fa1aca20a29db3d3d1a867eeed78f65448febe","date":1317919012,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e","date":1320267737,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument());\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96f4704474fc1727a4b78bdc1d5ba60d74e46394","date":1321349326,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n      commitTracker.addedDocument( cmd.commitWithin );\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      commitTracker.addedDocument( cmd.commitWithin );\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":["70663341fea7eaba7572ef11c033a2c631fa3142"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70663341fea7eaba7572ef11c033a2c631fa3142","date":1321392414,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      commitTracker.addedDocument( cmd.commitWithin );\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n      commitTracker.addedDocument( cmd.commitWithin );\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":["96f4704474fc1727a4b78bdc1d5ba60d74e46394","c518d12136e15c9de6fa3d2c4bf5add07311a685"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( cmd.commitWithin );\n        softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      commitTracker.addedDocument( cmd.commitWithin );\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( cmd.commitWithin );\n        softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      commitTracker.addedDocument( cmd.commitWithin );\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( cmd.commitWithin );\n        softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      ulog.add(cmd);\n\n      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      commitTracker.addedDocument( cmd.commitWithin );\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad31de9d3b830bc174d4c41df9f80f4cac82576","date":1328107867,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( cmd.commitWithin );\n        softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","date":1341327930,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument);\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":["c3465573b8d89796a7dc94c1b6461292f8708c6d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3465573b8d89796a7dc94c1b6461292f8708c6d","date":1341336998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument);\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":["671279fa1676e7f2755c2745a25abd77a169f992","fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"829b444e514261ac0213cfb2339311017f302310","date":1341418875,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          log.info(\"Reordered DBQs detected.  Update=\"+cmd+\" DBQs=\"+deletesAfter);\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08bcaef9e931052e4ca24133a89cc6aefaf61829","date":1342469326,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          log.info(\"Reordered DBQs detected.  Update=\"+cmd+\" DBQs=\"+deletesAfter);\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n        Term updateTerm;\n        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        Document luceneDocument = cmd.getLuceneDocument();\n        // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n        writer.updateDocument(updateTerm, luceneDocument);\n        // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument());\n      }\n\n      // Add to the transaction log *after* successfully adding to the index, if there was no error.\n      // This ordering ensures that if we log it, it's definitely been added to the the index.\n      // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n      // log version was definitely committed.\n      if (ulog != null) ulog.add(cmd);\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n\n      if (cmd.overwrite) {\n\n        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          log.info(\"Reordered DBQs detected.  Update=\"+cmd+\" DBQs=\"+deletesAfter);\n          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n          for (UpdateLog.DBQ dbq : deletesAfter) {\n            try {\n              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n              tmpDel.query = dbq.q;\n              tmpDel.version = -dbq.version;\n              dbqList.add( getQuery(tmpDel) );\n            } catch (Exception e) {\n              log.error(\"Exception parsing reordered query : \" + dbq, e);\n            }\n          }\n\n          addAndDelete(cmd, dbqList);\n        } else {\n          // normal update\n\n          Term updateTerm;\n          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n          boolean del = false;\n          if (cmd.updateTerm == null) {\n            updateTerm = idTerm;\n          } else {\n            del = true;\n            updateTerm = cmd.updateTerm;\n          }\n\n          Document luceneDocument = cmd.getLuceneDocument();\n          // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n          writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n          // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n\n\n          if(del) { // ensure id remains unique\n            BooleanQuery bq = new BooleanQuery();\n            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n            writer.deleteDocuments(bq);\n          }\n\n\n          // Add to the transaction log *after* successfully adding to the index, if there was no error.\n          // This ordering ensures that if we log it, it's definitely been added to the the index.\n          // This also ensures that if a commit sneaks in-between, that we know everything in a particular\n          // log version was definitely committed.\n          if (ulog != null) ulog.add(cmd);\n        }\n\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n        if (ulog != null) ulog.add(cmd);\n      }\n\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        commitTracker.addedDocument( -1 );\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"039186fd2452232060d10c35a255715d6147dd91","date":1359732548,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c47e57a9659cee31304e7b75b71b252d2f33b6f9","date":1359743123,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"637a392e2e05d4e1179ac3c532cfeef0cde977ba","date":1376347977,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n            \n            Document luceneDocument = cmd.getLuceneDocument();\n            // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n            writer.updateDocument(updateTerm, luceneDocument,\n                schema.getAnalyzer());\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"070e0f665721fd467c6fcea5721fce31017180b7","date":1391560323,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    }  catch (RuntimeException t) {\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, String.format(\"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1cac04441b737c4c358cb9b88ed114059e2c8d7","date":1391595947,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    }  catch (RuntimeException t) {\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, String.format(\"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","bugFix":null,"bugIntro":["2e6b05830c192ca6f808471cb0639a269af46e25"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e6b05830c192ca6f808471cb0639a269af46e25","date":1416915751,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","bugFix":["d1cac04441b737c4c358cb9b88ed114059e2c8d7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e69b85e159f9ef10d98c83ba78d1f77b278ec61","date":1452118789,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c96c6402e44d386e86f90412fcf0f5ad5c689d2d","date":1532997723,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (AlreadyClosedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Server error writing document id %s to the index\", cmd.getPrintableId()), e);\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (AlreadyClosedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Server error writing document id %s to the index\", cmd.getPrintableId()), e);\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (AlreadyClosedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Server error writing document id %s to the index\", cmd.getPrintableId()), e);\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (AlreadyClosedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Server error writing document id %s to the index\", cmd.getPrintableId()), e);\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    try {\n      return addDoc0(cmd);\n    } catch (SolrException e) {\n      throw e;\n    } catch (AlreadyClosedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          String.format(Locale.ROOT, \"Server error writing document id %s to the index\", cmd.getPrintableId()), e);\n    } catch (IllegalArgumentException iae) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error: \"\n              + iae.getMessage()\n              + (iae.getCause() instanceof BytesRefHash.MaxBytesLengthExceededException ?\n              \". Perhaps the document has an indexed string field (solr.StrField) which is too large\" : \"\"),\n              cmd.getPrintableId()), iae);\n    } catch (RuntimeException t) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"Exception writing document id %s to the index; possible analysis error.\",\n          cmd.getPrintableId()), t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"d1cac04441b737c4c358cb9b88ed114059e2c8d7":["070e0f665721fd467c6fcea5721fce31017180b7"],"637a392e2e05d4e1179ac3c532cfeef0cde977ba":["08970e5b8411182a29412c177eff67ec1110095b"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"98fa1aca20a29db3d3d1a867eeed78f65448febe":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"c3465573b8d89796a7dc94c1b6461292f8708c6d":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"08970e5b8411182a29412c177eff67ec1110095b":["039186fd2452232060d10c35a255715d6147dd91"],"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e":["98fa1aca20a29db3d3d1a867eeed78f65448febe"],"671279fa1676e7f2755c2745a25abd77a169f992":["c26f00b574427b55127e869b935845554afde1fa"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["70663341fea7eaba7572ef11c033a2c631fa3142","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a229cb50768e988c50a2106bdae3a92154f428bf":["c96c6402e44d386e86f90412fcf0f5ad5c689d2d","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["829b444e514261ac0213cfb2339311017f302310","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"96f4704474fc1727a4b78bdc1d5ba60d74e46394":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e"],"829b444e514261ac0213cfb2339311017f302310":["c3465573b8d89796a7dc94c1b6461292f8708c6d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c47e57a9659cee31304e7b75b71b252d2f33b6f9":["08bcaef9e931052e4ca24133a89cc6aefaf61829","039186fd2452232060d10c35a255715d6147dd91"],"70663341fea7eaba7572ef11c033a2c631fa3142":["96f4704474fc1727a4b78bdc1d5ba60d74e46394"],"c518d12136e15c9de6fa3d2c4bf5add07311a685":["16a110e87d79276dcf4554fb1d02324feb891795"],"070e0f665721fd467c6fcea5721fce31017180b7":["637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"039186fd2452232060d10c35a255715d6147dd91":["08bcaef9e931052e4ca24133a89cc6aefaf61829"],"b09644855fe79c27cf261552509561b8ce34c4c7":["671279fa1676e7f2755c2745a25abd77a169f992"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["c96c6402e44d386e86f90412fcf0f5ad5c689d2d"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["08970e5b8411182a29412c177eff67ec1110095b","637a392e2e05d4e1179ac3c532cfeef0cde977ba"],"7e69b85e159f9ef10d98c83ba78d1f77b278ec61":["2e6b05830c192ca6f808471cb0639a269af46e25"],"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e":["b09644855fe79c27cf261552509561b8ce34c4c7"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["70663341fea7eaba7572ef11c033a2c631fa3142","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c96c6402e44d386e86f90412fcf0f5ad5c689d2d":["7e69b85e159f9ef10d98c83ba78d1f77b278ec61"],"2e6b05830c192ca6f808471cb0639a269af46e25":["d1cac04441b737c4c358cb9b88ed114059e2c8d7"],"cec585935ebadb78352a93e4a429d2b89fb2d53e":["0e8cb6e9df9d6fc873383924f02d9aacfffebf4e"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["c518d12136e15c9de6fa3d2c4bf5add07311a685"],"16a110e87d79276dcf4554fb1d02324feb891795":["cec585935ebadb78352a93e4a429d2b89fb2d53e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["0ad31de9d3b830bc174d4c41df9f80f4cac82576","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["70663341fea7eaba7572ef11c033a2c631fa3142"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["829b444e514261ac0213cfb2339311017f302310"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"]},"commit2Childs":{"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["c3465573b8d89796a7dc94c1b6461292f8708c6d"],"d1cac04441b737c4c358cb9b88ed114059e2c8d7":["2e6b05830c192ca6f808471cb0639a269af46e25"],"637a392e2e05d4e1179ac3c532cfeef0cde977ba":["070e0f665721fd467c6fcea5721fce31017180b7","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"c26f00b574427b55127e869b935845554afde1fa":["671279fa1676e7f2755c2745a25abd77a169f992"],"98fa1aca20a29db3d3d1a867eeed78f65448febe":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e"],"c3465573b8d89796a7dc94c1b6461292f8708c6d":["829b444e514261ac0213cfb2339311017f302310"],"08970e5b8411182a29412c177eff67ec1110095b":["637a392e2e05d4e1179ac3c532cfeef0cde977ba","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e":["96f4704474fc1727a4b78bdc1d5ba60d74e46394"],"671279fa1676e7f2755c2745a25abd77a169f992":["b09644855fe79c27cf261552509561b8ce34c4c7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"96f4704474fc1727a4b78bdc1d5ba60d74e46394":["70663341fea7eaba7572ef11c033a2c631fa3142"],"829b444e514261ac0213cfb2339311017f302310":["aba371508186796cc6151d8223a5b4e16d02e26e","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c47e57a9659cee31304e7b75b71b252d2f33b6f9":[],"70663341fea7eaba7572ef11c033a2c631fa3142":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c518d12136e15c9de6fa3d2c4bf5add07311a685":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"070e0f665721fd467c6fcea5721fce31017180b7":["d1cac04441b737c4c358cb9b88ed114059e2c8d7"],"039186fd2452232060d10c35a255715d6147dd91":["08970e5b8411182a29412c177eff67ec1110095b","c47e57a9659cee31304e7b75b71b252d2f33b6f9"],"b09644855fe79c27cf261552509561b8ce34c4c7":["0e8cb6e9df9d6fc873383924f02d9aacfffebf4e"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"7e69b85e159f9ef10d98c83ba78d1f77b278ec61":["c96c6402e44d386e86f90412fcf0f5ad5c689d2d"],"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e":["cec585935ebadb78352a93e4a429d2b89fb2d53e"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"c96c6402e44d386e86f90412fcf0f5ad5c689d2d":["a229cb50768e988c50a2106bdae3a92154f428bf","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"2e6b05830c192ca6f808471cb0639a269af46e25":["7e69b85e159f9ef10d98c83ba78d1f77b278ec61"],"cec585935ebadb78352a93e4a429d2b89fb2d53e":["16a110e87d79276dcf4554fb1d02324feb891795"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["98fa1aca20a29db3d3d1a867eeed78f65448febe"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"16a110e87d79276dcf4554fb1d02324feb891795":["c518d12136e15c9de6fa3d2c4bf5add07311a685"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["aba371508186796cc6151d8223a5b4e16d02e26e","c47e57a9659cee31304e7b75b71b252d2f33b6f9","039186fd2452232060d10c35a255715d6147dd91","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a229cb50768e988c50a2106bdae3a92154f428bf","aba371508186796cc6151d8223a5b4e16d02e26e","c47e57a9659cee31304e7b75b71b252d2f33b6f9","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}