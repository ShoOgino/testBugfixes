{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","commits":[{"id":"f60f33a488eaf8a55781c331299c44c2dc19dc32","date":1440094205,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(50);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(1);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), 1, 10);\n\n        final int numQualifications = atLeast(1);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), 1, 10);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(NumericRangeQuery.newIntRange(\"year\", qjv, qjv, true, true),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8e804ce17e8a4a99ab4978f7bec3ffecb2344d0","date":1440109455,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(NumericRangeQuery.newIntRange(\"year\", qjv, qjv, true, true),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(50);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(1);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), 1, 10);\n\n        final int numQualifications = atLeast(1);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), 1, 10);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(NumericRangeQuery.newIntRange(\"year\", qjv, qjv, true, true),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(LegacyNumericRangeQuery.newIntRange(\"year\", qjv, qjv, true, true),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(NumericRangeQuery.newIntRange(\"year\", qjv, qjv, true, true),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a8a6e8618a812308bce0a978e52ca5c453a112","date":1457444484,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(LegacyNumericRangeQuery.newIntRange(\"year\", qjv, qjv, true, true),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d3c6656a576996d73c1ac211d08e3f7a8fc02a4","date":1457550664,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r, false);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n\n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r, false);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n\n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n\n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n\n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n\n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n\n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r, false);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testMultiChildQueriesOfDiffParentLevels().mjava","sourceNew":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n\n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r, false);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n\n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n\n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n\n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n\n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n\n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMultiChildQueriesOfDiffParentLevels() throws Exception {\n    \n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    // randomly generate resume->jobs[]->qualifications[]\n    final int numResumes = atLeast(100);\n    for (int r = 0; r < numResumes; r++) {\n      final List<Document> docs = new ArrayList<>();\n      \n      final int rv = TestUtil.nextInt(random(), 1, 10);\n      final int numJobs = atLeast(10);\n      for (int j = 0; j < numJobs; j++) {\n        final int jv = TestUtil.nextInt(random(), -10, -1); // neg so no overlap with q (both used for \"year\")\n\n        final int numQualifications = atLeast(10);\n        for (int q = 0; q < numQualifications; q++) {\n          docs.add(makeQualification(\"q\" + q + \"_rv\" + rv + \"_jv\" + jv, q));\n        }\n        docs.add(makeJob(\"j\" + j, jv));\n      }\n      docs.add(makeResume(\"r\" + r, \"rv\"+rv));\n      w.addDocuments(docs);\n    }\n\n    final IndexReader r = w.getReader();\n    final IndexSearcher s = newSearcher(r, false);\n    w.close();\n\n    BitSetProducer resumeFilter = new QueryBitSetProducer(new TermQuery(new Term(\"docType\", \"resume\")));\n    // anything with a skill is a job\n    BitSetProducer jobFilter = new QueryBitSetProducer(new PrefixQuery(new Term(\"skill\", \"\")));\n\n\n    final int numQueryIters = atLeast(1);\n    for (int i = 0; i < numQueryIters; i++) {\n      final int qjv = TestUtil.nextInt(random(), -10, -1);\n      final int qrv = TestUtil.nextInt(random(), 1, 10);\n      \n      Query resumeQuery = new ToChildBlockJoinQuery(new TermQuery(new Term(\"country\",\"rv\" + qrv)),\n                                                    resumeFilter);\n      \n      Query jobQuery = new ToChildBlockJoinQuery(IntPoint.newRangeQuery(\"year\", qjv, qjv),\n                                                 jobFilter);\n      \n      BooleanQuery.Builder fullQuery = new BooleanQuery.Builder();\n      fullQuery.add(new BooleanClause(jobQuery, Occur.MUST));\n      fullQuery.add(new BooleanClause(resumeQuery, Occur.MUST));\n      \n      TopDocs hits = s.search(fullQuery.build(), 100); // NOTE: totally possible that we'll get no matches\n      \n      for (ScoreDoc sd : hits.scoreDocs) {\n        // since we're looking for children of jobs, all results must be qualifications\n        String q = r.document(sd.doc).get(\"qualification\");\n        assertNotNull(sd.doc + \" has no qualification\", q);\n        assertTrue(q + \" MUST contain jv\" + qjv, q.contains(\"jv\"+qjv));\n        assertTrue(q + \" MUST contain rv\" + qrv, q.contains(\"rv\"+qrv));\n      }\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f60f33a488eaf8a55781c331299c44c2dc19dc32":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0e7bc21595222ae4f75509300fbb7726691f387f":["8d3c6656a576996d73c1ac211d08e3f7a8fc02a4"],"37a8a6e8618a812308bce0a978e52ca5c453a112":["770342641f7b505eaa8dccdc666158bff2419109"],"8d3c6656a576996d73c1ac211d08e3f7a8fc02a4":["37a8a6e8618a812308bce0a978e52ca5c453a112"],"770342641f7b505eaa8dccdc666158bff2419109":["f8e804ce17e8a4a99ab4978f7bec3ffecb2344d0"],"f8e804ce17e8a4a99ab4978f7bec3ffecb2344d0":["f60f33a488eaf8a55781c331299c44c2dc19dc32"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8d3c6656a576996d73c1ac211d08e3f7a8fc02a4","0e7bc21595222ae4f75509300fbb7726691f387f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e7bc21595222ae4f75509300fbb7726691f387f"]},"commit2Childs":{"f60f33a488eaf8a55781c331299c44c2dc19dc32":["f8e804ce17e8a4a99ab4978f7bec3ffecb2344d0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f60f33a488eaf8a55781c331299c44c2dc19dc32"],"0e7bc21595222ae4f75509300fbb7726691f387f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a8a6e8618a812308bce0a978e52ca5c453a112":["8d3c6656a576996d73c1ac211d08e3f7a8fc02a4"],"8d3c6656a576996d73c1ac211d08e3f7a8fc02a4":["0e7bc21595222ae4f75509300fbb7726691f387f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"770342641f7b505eaa8dccdc666158bff2419109":["37a8a6e8618a812308bce0a978e52ca5c453a112"],"f8e804ce17e8a4a99ab4978f7bec3ffecb2344d0":["770342641f7b505eaa8dccdc666158bff2419109"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}